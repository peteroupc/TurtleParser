<docs>
<doc name="T:PeterO.IMarkableCharacterInput">

            <summary>Not documented yet.</summary>

</doc>
<doc name="M:PeterO.IMarkableCharacterInput.GetMarkPosition">

            <summary>Gets the zero-based character position in the stream from
            the last-set mark.</summary>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="M:PeterO.IMarkableCharacterInput.MoveBack(System.Int32)">

            <summary>Moves the stream position back the given number of
            characters.</summary>
            <param name='count'>The parameter <paramref name='count'/> is a
            32-bit signed integer.</param>

</doc>
<doc name="M:PeterO.IMarkableCharacterInput.SetHardMark">

            <summary>Sets a mark on the stream's current position.</summary>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="M:PeterO.IMarkableCharacterInput.SetMarkPosition(System.Int32)">

            <summary>Sets the stream's position from the last set mark.
            <param name='pos'>Zero-based character offset from the last set
            mark.</param>.</summary>

</doc>
<doc name="M:PeterO.IMarkableCharacterInput.SetSoftMark">

            <summary>If no mark is set, sets a mark on the stream, and
            characters read before the currently set mark are no longer
            available, while characters read after will be available if
            MoveBack is called. Otherwise, behaves like
            GetMarkPosition.</summary>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="M:PeterO.IMarkableCharacterInput.getMarkPosition">
<summary>Gets the zero-based character position in the stream from the last-set
      mark.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
</doc>
<doc name="M:PeterO.IMarkableCharacterInput.moveBack(System.Int32)">
<summary>Moves the stream position back the given number of characters.
    </summary>
</doc>
<doc name="M:PeterO.IMarkableCharacterInput.setHardMark">
<summary>Sets a mark on the stream's current position.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
</doc>
<doc name="M:PeterO.IMarkableCharacterInput.setMarkPosition(System.Int32)">
<summary>Sets the stream's position from the last set mark.
      <param name='pos'>Zero-based character offset from the last set mark.
      </param>
    </summary>
</doc>
<doc name="M:PeterO.IMarkableCharacterInput.setSoftMark">
<summary>If no mark is set, sets a mark on the stream, and characters read before
      the currently set mark are no longer available, while characters read
      after will be available if moveBack is called. Otherwise, behaves like
      getMarkPosition.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
</doc>

<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int32">
<summary>Converts an arbitrary-precision integer to a 32-bit signed integer if it
      can fit in a 32-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 32-bit signed integer.
    </returns>
    <exception cref='OverflowException'>The parameter
      <paramref name='input'/>
       is less than -2147483648 or greater than 2147483647.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int64">
<summary>Converts an arbitrary-precision integer to a 64-bit signed integer if it
      can fit in a 64-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 64-bit signed integer.
    </returns>
    <exception cref='OverflowException'>The parameter
      <paramref name='input'/>
       is less than -9223372036854775808 or greater than 9223372036854775807.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.SByte">
<summary>Converts an arbitrary-precision integer to an 8-bit signed integer if it
      can fit in an 8-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as an 8-bit signed integer.
    </returns>
    <exception cref='OverflowException'>The parameter
      <paramref name='input'/>
       is less than -128 or greater than 127.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt16">
<summary>Converts an arbitrary-precision integer to a 16-bit unsigned integer if it
      can fit in a 16-bit unsigned integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 16-bit unsigned integer.
    </returns>
    <exception cref='OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 65535.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt32">
<summary>Converts an arbitrary-precision integer to a 32-bit signed integer if it
      can fit in a 32-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 32-bit signed integer.
    </returns>
    <exception cref='OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 4294967295.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt64">
<summary>Converts an arbitrary-precision integer to a 64-bit unsigned integer if it
      can fit in a 64-bit unsigned integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 64-bit unsigned integer.
    </returns>
    <exception cref='OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 18446744073709551615.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_GreaterThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Determines whether an arbitrary-precision integer is greater than another
      arbitrary-precision integer.
    </summary>
    <param name='thisValue'>The first arbitrary-precision integer.
    </param>
    <param name='otherValue'>The second arbitrary-precision integer.
    </param>
    <returns><c>true</c> if
      <paramref name='thisValue'/>
       is greater than
      <paramref name='otherValue'/>
       ; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_GreaterThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Determines whether an arbitrary-precision integer value is greater than
      another arbitrary-precision integer.
    </summary>
    <param name='thisValue'>The first arbitrary-precision integer.
    </param>
    <param name='otherValue'>The second arbitrary-precision integer.
    </param>
    <returns><c>true</c> if
      <paramref name='thisValue'/>
       is at least
      <paramref name='otherValue'/>
       ; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.Byte)~PeterO.Numbers.EInteger">
<summary>Converts a byte (from 0 to 255) to an arbitrary-precision integer.
    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int16)~PeterO.Numbers.EInteger">
<summary>Converts a 16-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int32)~PeterO.Numbers.EInteger">
<summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.Int64)~PeterO.Numbers.EInteger">
<summary>Converts a 64-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.SByte)~PeterO.Numbers.EInteger">
<summary>Converts an 8-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt16)~PeterO.Numbers.EInteger">
<summary>Converts a 16-bit unsigned integer to an arbitrary-precision integer.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt32)~PeterO.Numbers.EInteger">
<summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Implicit(System.UInt64)~PeterO.Numbers.EInteger">
<summary>Converts a 64-bit unsigned integer to an arbitrary-precision integer.
    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_LeftShift(PeterO.Numbers.EInteger,System.Int32)">
<summary>Returns an arbitrary-precision integer with the bits shifted to the left
      by a number of bits. A value of 1 doubles this value, a value of 2
      multiplies it by 4, a value of 3 × by, a value of 4 × by, and so on.
    </summary>
    <param name='bthis'>The arbitrary-precision integer to shift left.
    </param>
    <param name='bitCount'>The number of bits to shift. Can be negative, in which case this is the
      same as shiftRight with the absolute value of this parameter.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_LessThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Determines whether an arbitrary-precision integer is less than another
      arbitrary-precision integer.
    </summary>
    <param name='thisValue'>The first arbitrary-precision integer.
    </param>
    <param name='otherValue'>The second arbitrary-precision integer.
    </param>
    <returns><c>true</c> if
      <paramref name='thisValue'/>
       is less than
      <paramref name='otherValue'/>
       ; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_LessThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Determines whether an arbitrary-precision integer is up to another
      arbitrary-precision integer.
    </summary>
    <param name='thisValue'>The first arbitrary-precision integer.
    </param>
    <param name='otherValue'>The second arbitrary-precision integer.
    </param>
    <returns><c>true</c> if
      <paramref name='thisValue'/>
       is up to
      <paramref name='otherValue'/>
       ; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Modulus(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Finds the remainder that results when an arbitrary-precision integer is
      divided by the value of another arbitrary-precision integer.
    </summary>
    <param name='dividend'>The first operand.
    </param>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Multiply(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Multiplies an arbitrary-precision integer by the value of an
      arbitrary-precision integer.
    </summary>
    <param name='operand1'>The first operand.
    </param>
    <param name='operand2'>The second operand.
    </param>
    <returns>The product of the two numbers.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_OnesComplement(PeterO.Numbers.EInteger)">
<summary>Returns an arbitrary-precision integer with every bit flipped.
    </summary>
    <param name='thisValue'>The operand as an arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='thisValue'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_RightShift(PeterO.Numbers.EInteger,System.Int32)">
<summary>Shifts the bits of an arbitrary-precision integer to the right.
    </summary>
    <param name='bthis'>Another arbitrary-precision integer.
    </param>
    <param name='smallValue'>The parameter
      <paramref name='smallValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <remarks>
       For this operation, the arbitrary-precision integer is treated as a
      two's-complement form (see
      <see cref='PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ). Thus, for negative values, the arbitrary-precision integer is
      sign-extended.
    </remarks>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_Subtraction(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Subtracts two arbitrary-precision integer values.
    </summary>
    <param name='bthis'>An arbitrary-precision integer.
    </param>
    <param name='subtrahend'>Another arbitrary-precision integer.
    </param>
    <returns>The difference of the two objects.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.EInteger.op_UnaryNegation(PeterO.Numbers.EInteger)">
<summary>Negates an arbitrary-precision integer.
    </summary>
    <param name='bigValue'>An arbitrary-precision integer to negate.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
</doc>
<doc name="T:PeterO.Numbers.ERational">
<summary>Represents an arbitrary-precision rational number. This class can't be
      inherited. (The "E" stands for "extended", meaning that instances of this
      class can be values other than numbers proper, such as infinity and
      not-a-number.)
      <para><b>Thread safety:</b> Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
    </summary>
</doc>
<doc name="M:PeterO.Numbers.ERational.#ctor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Numbers.ERational'/>
       class.
    </summary>
    <param name='numerator'>The numerator.
    </param>
    <param name='denominator'>The denominator.
    </param>
    <exception cref='ArgumentException'>The denominator is zero.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.Abs">
<summary>Returns the absolute value of this rational number, that is, a number with
      the same value as this one but as a nonnegative number.
    </summary>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.Add(PeterO.Numbers.ERational)">
<summary>Adds two rational numbers.
    </summary>
    <param name='otherValue'>Another arbitrary-precision rational number.
    </param>
    <returns>The sum of the two numbers. Returns not-a-number (NaN) if either operand
      is NaN.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.CompareTo(PeterO.Numbers.ERational)">
<summary>Compares an arbitrary-precision rational number with this instance.
    </summary>
    <param name='other'>An arbitrary-precision rational number.
    </param>
    <returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.CompareToBinary(PeterO.Numbers.EFloat)">
<summary>Compares an arbitrary-precision binary float with this instance.
    </summary>
    <param name='other'>An arbitrary-precision binary float.
    </param>
    <returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.CompareToDecimal(PeterO.Numbers.EDecimal)">
<summary>Compares an arbitrary-precision decimal number with this instance.
    </summary>
    <param name='other'>An arbitrary-precision decimal number.
    </param>
    <returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.CompareToTotal(PeterO.Numbers.ERational)">
<summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher denominator
          has a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision rational number to compare with this one.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.CompareToTotalMagnitude(PeterO.Numbers.ERational)">
<summary>Compares the absolute values of this object and another object, imposing a
      total ordering on all possible values (ignoring their signs). In this
      method:
      <list>
        <item>For objects with the same value, the one with the higher denominator
          has a greater "absolute value".
        </item>
        <item>Negative zero and positive zero are considered equal.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision rational number to compare with this one.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.CopySign(PeterO.Numbers.ERational)">
<summary>Returns a number with the same value as this one, but copying the sign
      (positive or negative) of another number.
    </summary>
    <param name='other'>A number whose sign will be copied.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
<summary>Creates a rational number with the given numerator and denominator.
    </summary>
    <param name='numerator'>The numerator.
    </param>
    <param name='denominator'>The denominator.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.Create(System.Int32,System.Int32)">
<summary>Creates a rational number with the given numerator and denominator.
    </summary>
    <param name='numeratorSmall'>The numerator.
    </param>
    <param name='denominatorSmall'>The denominator.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger)">
<summary>Creates a not-a-number arbitrary-precision rational number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean)">
<summary>Creates a not-a-number arbitrary-precision rational number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <param name='signaling'>Whether the return value will be signaling (true) or quiet (false).
    </param>
    <param name='negative'>Whether the return value is negative.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="P:PeterO.Numbers.ERational.Denominator">
<summary>Gets this object's denominator.
    </summary>
    <value>This object's denominator.
    </value>
</doc>
<doc name="M:PeterO.Numbers.ERational.Divide(PeterO.Numbers.ERational)">
<summary>Divides this instance by the value of an arbitrary-precision rational
      number object.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The quotient of the two objects.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.Equals(PeterO.Numbers.ERational)">
<summary>Determines whether this object's numerator, denominator, and properties
      are equal to those of another object. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary>
    <param name='other'>An arbitrary-precision rational number to compare to.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.Equals(System.Object)">
<summary>Determines whether this object's numerator, denominator, and properties
      are equal to those of another object and that other object is an
      arbitrary-precision rational number. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromByte(System.Byte)">
<summary>Converts a byte (from 0 to 255) to an arbitrary-precision rational number.

    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromDecimal(System.Decimal)">
<summary>Converts a
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal) to a rational number.
    </summary>
    <param name='eint'>The number to convert as a
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromDouble(System.Double)">
<summary>Converts a 64-bit floating-point number to a rational number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the number to a string.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A rational number with the same value as
      <paramref name='flt'/>
       .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromEDecimal(PeterO.Numbers.EDecimal)">
<summary>Converts an arbitrary-precision decimal number to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromEFloat(PeterO.Numbers.EFloat)">
<summary>Converts an arbitrary-precision binary float to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromEInteger(PeterO.Numbers.EInteger)">
<summary>Converts an arbitrary-precision integer to a rational number.
    </summary>
    <param name='bigint'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The exact value of the integer as a rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromExtendedDecimal(PeterO.Numbers.EDecimal)">
<summary>Converts an arbitrary-precision decimal number to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromExtendedFloat(PeterO.Numbers.EFloat)">
<summary>Converts an arbitrary-precision binary float to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromInt16(System.Int16)">
<summary>Converts a 16-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromInt32(System.Int32)">
<summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromInt64(System.Int64)">
<summary>Converts a 64-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromSByte(System.SByte)">
<summary>Converts an 8-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromSingle(System.Single)">
<summary>Converts a 32-bit binary floating-point number to a rational number. This
      method computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the number to a string.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>A rational number with the same value as
      <paramref name='flt'/>
       .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromString(System.String)">
<summary>Creates a rational number from a text string that represents a number. See

      <c>FromString(String, int, int)</c> for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <returns>An arbitrary-precision rational number with the same value as the given
      string.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromString(System.String,System.Int32,System.Int32)">
<summary><para>Creates a rational number from a text string that represents a number.
      </para>
      <para>The format of the string generally consists of:
      </para>
      <list type=''>
        <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if
          '-' , the value is negative.)
        </item>
        <item>The numerator in the form of one or more digits.
        </item>
        <item>Optionally, "/" followed by the denominator in the form of one or more
          digits. If a denominator is not given, it's equal to 1.
        </item>
      </list>
      <para>The string can also be "-INF", "-Infinity", "Infinity", "INF", quiet NaN
        ("NaN" /"-NaN") followed by any number of digits, or signaling NaN
        ("sNaN" /"-sNaN") followed by any number of digits, all in any
        combination of uppercase and lowercase.
      </para>
      <para>All characters mentioned earlier are the corresponding characters in the
        Basic Latin range. In particular, the digits must be the basic digits 0
        to 9 (U+0030 to U+0039). The string is not allowed to contain white
        space characters, including spaces.
      </para>
    </summary>
    <param name='str'>A text string, a portion of which represents a number.
    </param>
    <param name='offset'>A zero-based index that identifies the start of the number.
    </param>
    <param name='length'>The length of the number within the string.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromUInt16(System.UInt16)">
<summary>Converts a 16-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromUInt32(System.UInt32)">
<summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.FromUInt64(System.UInt64)">
<summary>Converts a 64-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.GetHashCode">
<summary>Returns the hash code for this instance. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
</doc>
<doc name="P:PeterO.Numbers.ERational.IsFinite">
<summary>Gets a value indicating whether this object is finite (not infinity or
      NaN).
    </summary>
    <value><c>true</c> if this object is finite (not infinity or not-a-number (NaN)); otherwise, <c>false</c> .
    </value>
</doc>
<doc name="M:PeterO.Numbers.ERational.IsInfinity">
<summary>Gets a value indicating whether this object's value is infinity.
    </summary>
    <returns><c>true</c> if this object's value is infinity; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.IsNaN">
<summary>Returns whether this object is a not-a-number value.
    </summary>
    <returns><c>true</c> if this object is a not-a-number value; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="P:PeterO.Numbers.ERational.IsNegative">
<summary>Gets a value indicating whether this object's value is negative (including
      negative zero).
    </summary>
    <value><c>true</c> if this object's value is negative; otherwise, <c>false</c> .
    </value>
</doc>
<doc name="M:PeterO.Numbers.ERational.IsNegativeInfinity">
<summary>Returns whether this object is negative infinity.
    </summary>
    <returns><c>true</c> if this object is negative infinity; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.IsPositiveInfinity">
<summary>Returns whether this object is positive infinity.
    </summary>
    <returns><c>true</c> if this object is positive infinity; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.IsQuietNaN">
<summary>Returns whether this object is a quiet not-a-number value.
    </summary>
    <returns><c>true</c> if this object is a quiet not-a-number value; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.IsSignalingNaN">
<summary>Returns whether this object is a signaling not-a-number value (which
      causes an error if the value is passed to any arithmetic operation in this
      class).
    </summary>
    <returns><c>true</c> if this object is a signaling not-a-number value (which causes an error
      if the value is passed to any arithmetic operation in this class); otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="P:PeterO.Numbers.ERational.IsZero">
<summary>Gets a value indicating whether this object's value equals 0.
    </summary>
    <value><c>true</c> if this object's value equals 0; otherwise, .
      <c>false</c> .
    </value>
</doc>
<doc name="M:PeterO.Numbers.ERational.Multiply(PeterO.Numbers.ERational)">
<summary>Multiplies this instance by the value of an arbitrary-precision rational
      number.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The product of the two numbers.
    </returns>
</doc>
<doc name="F:PeterO.Numbers.ERational.NaN">
<summary>A not-a-number value.
    </summary>
</doc>
<doc name="M:PeterO.Numbers.ERational.Negate">
<summary>Returns a rational number with the same value as this one but with the
      sign reversed.
    </summary>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="F:PeterO.Numbers.ERational.NegativeInfinity">
<summary>Negative infinity, less than any other number.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERational.NegativeZero">
<summary>A rational number for negative zero.
    </summary>
</doc>
<doc name="P:PeterO.Numbers.ERational.Numerator">
<summary>Gets this object's numerator.
    </summary>
    <value>This object's numerator. If this object is a not-a-number value, returns
      the diagnostic information (which will be negative if this object is
      negative).
    </value>
</doc>
<doc name="F:PeterO.Numbers.ERational.One">
<summary>The rational number one.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERational.PositiveInfinity">
<summary>Positive infinity, greater than any other number.
    </summary>
</doc>
<doc name="M:PeterO.Numbers.ERational.Remainder(PeterO.Numbers.ERational)">
<summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision rational number.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
</doc>
<doc name="P:PeterO.Numbers.ERational.Sign">
<summary>Gets the sign of this rational number.
    </summary>
    <value>Zero if this value is zero or negative zero; -1 if this value is less than
      0; and 1 if this value is greater than 0.
    </value>
</doc>
<doc name="F:PeterO.Numbers.ERational.SignalingNaN">
<summary>A signaling not-a-number value.
    </summary>
</doc>
<doc name="M:PeterO.Numbers.ERational.Subtract(PeterO.Numbers.ERational)">
<summary>Subtracts an arbitrary-precision rational number from this instance.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The difference of the two objects.
    </returns>
</doc>
<doc name="F:PeterO.Numbers.ERational.Ten">
<summary>The rational number ten.
    </summary>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToByteChecked">
<summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a byte (from 0 to 255).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToByteIfExact">
<summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a byte (from 0 to 255).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToByteUnchecked">
<summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a byte (from 0 to
      255).
    </summary>
    <returns>This number, converted to a byte (from 0 to 255). Returns 0 if this value
      is infinity or not-a-number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToDecimal">
<summary>Converts this value to a
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal). Currently, converts this value to the precision and range of a
      .NET Framework decimal.
    </summary>
    <returns>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToDouble">
<summary>Converts this value to a 64-bit floating-point number. The half-even
      rounding mode is used.
    </summary>
    <returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEDecimal">
<summary>Converts this rational number to a decimal number.
    </summary>
    <returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating decimal expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEDecimal(PeterO.Numbers.EContext)">
<summary>Converts this rational number to a decimal number and rounds the result to
      the given precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param>
    <returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating decimal expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEDecimalExactIfPossible(PeterO.Numbers.EContext)">
<summary>Converts this rational number to a decimal number, but if the result would
      have a nonterminating decimal expansion, rounds that result to the given
      precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating decimal expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The exact value of the rational number if possible; otherwise,the rounded
      version of the result if a context is given. Returns not-a-number (NaN) if
      the context is null and the result can't be exact because it has a
      nonterminating decimal expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEFloat">
<summary>Converts this rational number to a binary float.
    </summary>
    <returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating binary expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEFloat(PeterO.Numbers.EContext)">
<summary>Converts this rational number to a binary float and rounds that result to
      the given precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param>
    <returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating binary expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEFloatExactIfPossible(PeterO.Numbers.EContext)">
<summary>Converts this rational number to a binary float, but if the result would
      have a nonterminating binary expansion, rounds that result to the given
      precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating binary expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The exact value of the rational number if possible; otherwise,the rounded
      version of the result if a context is given. Returns not-a-number (NaN) if
      the context is null and the result can't be exact because it has a
      nonterminating binary expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEInteger">
<summary>Converts this value to an arbitrary-precision integer. Any fractional part
      in this value will be discarded when converting to an arbitrary-precision
      integer.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEIntegerExact">
<summary>Converts this value to an arbitrary-precision integer, checking whether
      the value is an exact integer.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToEIntegerIfExact">
<summary>Converts this value to an arbitrary-precision integer, checking whether
      the value is an exact integer.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedDecimal">
<summary>Converts this rational number to a decimal number.
    </summary>
    <returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating decimal expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedDecimal(PeterO.Numbers.EContext)">
<summary>Converts this rational number to a decimal number and rounds the result to
      the given precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param>
    <returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating decimal expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedDecimalExactIfPossible(PeterO.Numbers.EContext)">
<summary>Converts this rational number to a decimal number, but if the result would
      have a nonterminating decimal expansion, rounds that result to the given
      precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating decimal expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The exact value of the rational number if possible; otherwise,the rounded
      version of the result if a context is given. Returns not-a-number (NaN) if
      the context is null and the result can't be exact because it has a
      nonterminating decimal expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedFloat">
<summary>Converts this rational number to a binary float.
    </summary>
    <returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating binary expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedFloat(PeterO.Numbers.EContext)">
<summary>Converts this rational number to a binary float and rounds that result to
      the given precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param>
    <returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating binary expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToExtendedFloatExactIfPossible(PeterO.Numbers.EContext)">
<summary>Converts this rational number to a binary float, but if the result would
      have a nonterminating binary expansion, rounds that result to the given
      precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating binary expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The exact value of the rational number if possible; otherwise,the rounded
      version of the result if a context is given. Returns not-a-number (NaN) if
      the context is null and the result can't be exact because it has a
      nonterminating binary expansion.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt16Checked">
<summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 16-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt16IfExact">
<summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 16-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt16Unchecked">
<summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 16-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt32Checked">
<summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt32IfExact">
<summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt32Unchecked">
<summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 32-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt64Checked">
<summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 64-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt64IfExact">
<summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 64-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToInt64Unchecked">
<summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 64-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToSByteChecked">
<summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to an 8-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToSByteIfExact">
<summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as an 8-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToSByteUnchecked">
<summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as an 8-bit signed
      integer.
    </summary>
    <returns>This number, converted to an 8-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToSingle">
<summary>Converts this value to a 32-bit binary floating-point number. The
      half-even rounding mode is used.
    </summary>
    <returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToString">
<summary>Converts this object to a text string.
    </summary>
    <returns>A string representation of this object. If this object's value is infinity
      or not-a-number, the result is the analogous return value of the
      <c>EDecimal.ToString</c> method. Otherwise, the return value has the following form:
      <c>[-]numerator/denominator</c> .
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt16Checked">
<summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 16-bit unsigned integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt16IfExact">
<summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer without rounding to a different numerical value.

    </summary>
    <returns>This number's value as a 16-bit unsigned integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt16Unchecked">
<summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit unsigned
      integer.
    </summary>
    <returns>This number, converted to a 16-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt32Checked">
<summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt32IfExact">
<summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt32Unchecked">
<summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 32-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt64Checked">
<summary>Converts this number's value to a 64-bit unsigned integer if it can fit in
      a 64-bit unsigned integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 64-bit unsigned integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt64IfExact">
<summary>Converts this number's value to a 64-bit unsigned integer if it can fit in
      a 64-bit unsigned integer without rounding to a different numerical value.

    </summary>
    <returns>This number's value as a 64-bit unsigned integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.ToUInt64Unchecked">
<summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit unsigned
      integer.
    </summary>
    <returns>This number, converted to a 64-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>
</doc>
<doc name="P:PeterO.Numbers.ERational.UnsignedNumerator">
<summary>Gets this object's numerator with the sign removed.
    </summary>
    <value>This object's numerator. If this object is a not-a-number value, returns
      the diagnostic information.
    </value>
</doc>
<doc name="F:PeterO.Numbers.ERational.Zero">
<summary>A rational number for zero.
    </summary>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Addition(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
<summary>Adds two rational numbers.
    </summary>
    <param name='bthis'>The first operand.
    </param>
    <param name='augend'>The second operand.
    </param>
    <returns>The sum of the two numbers. Returns not-a-number (NaN) if either operand
      is NaN.
    </returns>
    <exception cref='ArgumentNullException'>The parameter "otherValue" is null.
    </exception>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Division(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
<summary>Divides an arbitrary-precision rational number by the value of another
      arbitrary-precision rational number object.
    </summary>
    <param name='dividend'>An arbitrary-precision rational number serving as the dividend.
    </param>
    <param name='divisor'>An arbitrary-precision rational number serving as the divisor.
    </param>
    <returns>The quotient of the two objects.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~PeterO.Numbers.EInteger">
<summary>Converts an arbitrary-precision rational number to an arbitrary-precision
      integer. Any fractional part in the value will be discarded when
      converting to an arbitrary-precision integer.
    </summary>
    <param name='bigValue'>An arbitrary-precision rational number.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Byte">
<summary>Converts an arbitrary-precision rational number to a byte (from 0 to 255)
      if it can fit in a byte (from 0 to 255) after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a byte (from 0 to 255).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Decimal">
<summary>Converts an arbitrary-precision rational number to a
      <c>decimal</c> under the Common Language Infrastructure (see
      <see cref='PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ).
    </summary>
    <param name='extendedNumber'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Double">
<summary>Converts an arbitrary-precision rational number to a 64-bit floating-point
      number. The half-even rounding mode is used.
    </summary>
    <param name='bigValue'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int16">
<summary>Converts an arbitrary-precision rational number to a 16-bit signed integer
      if it can fit in a 16-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int32">
<summary>Converts an arbitrary-precision rational number to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int64">
<summary>Converts an arbitrary-precision rational number to a 64-bit signed integer
      if it can fit in a 64-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.SByte">
<summary>Converts an arbitrary-precision rational number to an 8-bit signed integer
      if it can fit in an 8-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to an 8-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Single">
<summary>Converts an arbitrary-precision rational number to a 32-bit binary
      floating-point number. The half-even rounding mode is used.
    </summary>
    <param name='bigValue'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt16">
<summary>Converts an arbitrary-precision rational number to a 16-bit unsigned
      integer if it can fit in a 16-bit unsigned integer after truncating to an
      integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit unsigned integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt32">
<summary>Converts an arbitrary-precision rational number to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt64">
<summary>Converts an arbitrary-precision rational number to a 64-bit unsigned
      integer if it can fit in a 64-bit unsigned integer after truncating to an
      integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit unsigned integer.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.ERational">
<summary>Converts an arbitrary-precision decimal floating-point number to an
      arbitrary-precision rational number.
    </summary>
    <param name='eint'>The parameter
      <paramref name='eint'/>
       is an arbitrary-precision decimal floating-point number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EFloat)~PeterO.Numbers.ERational">
<summary>Converts an arbitrary-precision binary float to an arbitrary-precision
      rational number.
    </summary>
    <param name='eint'>An arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.ERational">
<summary>Converts an arbitrary-precision integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='eint'>An arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Byte)~PeterO.Numbers.ERational">
<summary>Converts a byte (from 0 to 255) to an arbitrary-precision rational number.

    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Decimal)~PeterO.Numbers.ERational">
<summary>Converts a
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal). to an arbitrary-precision rational number.
    </summary>
    <param name='eint'>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Double)~PeterO.Numbers.ERational">
<summary>Converts a 64-bit floating-point number to an arbitrary-precision rational
      number.
    </summary>
    <param name='eint'>The parameter
      <paramref name='eint'/>
       is a 64-bit floating-point number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Int16)~PeterO.Numbers.ERational">
<summary>Converts a 16-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Int32)~PeterO.Numbers.ERational">
<summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Int64)~PeterO.Numbers.ERational">
<summary>Converts a 64-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.SByte)~PeterO.Numbers.ERational">
<summary>Converts an 8-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.Single)~PeterO.Numbers.ERational">
<summary>Converts a 32-bit binary floating-point number to a rational number.
    </summary>
    <param name='eint'>The parameter
      <paramref name='eint'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>The value of
      <paramref name='eint'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt16)~PeterO.Numbers.ERational">
<summary>Converts a 16-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt32)~PeterO.Numbers.ERational">
<summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Implicit(System.UInt64)~PeterO.Numbers.ERational">
<summary>Converts a 64-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision rational number.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Modulus(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
<summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision rational number.
    </summary>
    <param name='dividend'>The dividend.
    </param>
    <param name='divisor'>The divisor.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Multiply(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
<summary>Multiplies this instance by the value of an arbitrary-precision rational
      number.
    </summary>
    <param name='operand1'>The first operand.
    </param>
    <param name='operand2'>The second operand.
    </param>
    <returns>The product of the two numbers.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_Subtraction(PeterO.Numbers.ERational,PeterO.Numbers.ERational)">
<summary>Subtracts an arbitrary-precision rational number from this instance.
    </summary>
    <param name='bthis'>The first operand.
    </param>
    <param name='subtrahend'>The second operand.
    </param>
    <returns>The difference of the two objects.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.ERational.op_UnaryNegation(PeterO.Numbers.ERational)">
<summary>Returns an arbitrary-precision rational number with the same value as the
      given one but with its sign reversed.
    </summary>
    <param name='bigValue'>An arbitrary-precision rational number to negate.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
</doc>
<doc name="T:PeterO.Numbers.ERounding">
<summary>Specifies the mode to use when "shortening" numbers that otherwise can't
      fit a given number of digits, so that the shortened number has about the
      same value. This "shortening" is known as rounding. (The "E" stands for
      "extended", and has this prefix to group it with the other classes common
      to this library, particularly EDecimal, EFloat, and ERational.).
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.Ceiling">
<summary>If there is a fractional part, the number is rounded to the highest
      representable number that's closest to it.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.Down">
<summary>The fractional part is discarded (the number is truncated).
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.Floor">
<summary>If there is a fractional part, the number is rounded to the lowest
      representable number that's closest to it.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.HalfDown">
<summary>Rounded to the nearest number; if the fractional part is exactly half, it
      is discarded.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.HalfEven">
<summary>Rounded to the nearest number; if the fractional part is exactly half, the
      number is rounded to the closest representable number that is even. This
      is sometimes also known as "banker's rounding".
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.HalfUp">
<summary>Rounded to the nearest number; if the fractional part is exactly half, the
      number is rounded to the closest representable number away from zero. This
      is the most familiar rounding mode for many people.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.None">
<summary>Indicates that rounding will not be used. If rounding is required, the
      rounding operation will report an error.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.Odd">
<summary>If there is a fractional part and the whole number part is even, the
      number is rounded to the closest representable odd number away from zero.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.OddOrZeroFiveUp">
<summary>For binary floating point numbers, this is the same as Odd. For other
      bases (including decimal numbers), this is the same as ZeroFiveUp. This
      rounding mode is useful for rounding intermediate results at a slightly
      higher precision (at least 2 bits more for binary) than the final
      precision.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.Up">
<summary>If there is a fractional part, the number is rounded to the closest
      representable number away from zero.
    </summary>
</doc>
<doc name="F:PeterO.Numbers.ERounding.ZeroFiveUp">
<summary>If there is a fractional part and if the last digit before rounding is 0
      or half the radix, the number is rounded to the closest representable
      number away from zero; otherwise the fractional part is discarded. In
      overflow, the fractional part is always discarded.
    </summary>
</doc>
<doc name="T:PeterO.Numbers.ETrapException">
<summary>Exception thrown for arithmetic trap errors. (The "E" stands for
      "extended", and has this prefix to group it with the other classes common
      to this library, particularly EDecimal, EFloat, and ERational.).
    </summary>
</doc>
<doc name="M:PeterO.Numbers.ETrapException.#ctor(System.Int32,PeterO.Numbers.EContext,System.Object)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Numbers.ETrapException'/>
       class.
    </summary>
    <param name='flag'>A flag that specifies the kind of error (
      <c>EContext.FlagXXYY</c> ). This will only be one flag, such as
      <c>FlagInexact</c> or FlagSubnormal.
    </param>
    <param name='ctx'>A context object for arbitrary-precision arithmetic settings.
    </param>
    <param name='result'>The parameter
      <paramref name='result'/>
       is an arbitrary object.
    </param>
</doc>
<doc name="P:PeterO.Numbers.ETrapException.Context">
<summary>Gets the arithmetic context used during the operation that triggered the
      trap. May be null.
    </summary>
    <value>The arithmetic context used during the operation that triggered the trap.
      May be null.
    </value>
</doc>
<doc name="P:PeterO.Numbers.ETrapException.Error">
<summary>Gets the flag that specifies the kind of error (EContext.FlagXXX). This
      will only be one flag, such as
      <c>FlagInexact</c> or FlagSubnormal.
    </summary>
    <value>The flag that specifies the kind of error (EContext.FlagXXX). This will
      only be one flag, such as.
      <c>FlagInexact</c> or FlagSubnormal.
    </value>
</doc>
<doc name="P:PeterO.Numbers.ETrapException.Result">
<summary>Gets the defined result of the operation that caused the trap.
    </summary>
    <value>The defined result of the operation that caused the trap.
    </value>
</doc>
<doc name="M:PeterO.Numbers.FastInteger.AddBig(PeterO.Numbers.EInteger)">
<summary>This is an internal API.
    </summary>
    <param name='bigintVal'>The parameter
      <paramref name='bigintVal'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.FastInteger.Multiply(System.Int32)">
<summary>This is an internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.FastInteger.Negate">
<summary>This is an internal API.
    </summary>
    <returns>A FastInteger object.
    </returns>
</doc>
<doc name="P:PeterO.Numbers.FastInteger.Sign">
<summary>Gets an internal value.
    </summary>
    <value>An internal value.
    </value>
</doc>
<doc name="M:PeterO.Numbers.FastInteger.Subtract(PeterO.Numbers.FastInteger)">
<summary>This is an internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.FastInteger.SubtractBig(PeterO.Numbers.EInteger)">
<summary>This is an internal API.
    </summary>
    <param name='bigintVal'>The parameter
      <paramref name='bigintVal'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.FastInteger.SubtractInt(System.Int32)">
<summary>This is an internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.FastInteger.ToString">
<summary>This is an internal API.
    </summary>
    <returns>A text string.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.FastIntegerFixed.Negate">
<summary>This is an internal API.
    </summary>
    <returns>A FastIntegerFixed object.
    </returns>
</doc>
<doc name="M:PeterO.Numbers.FastIntegerFixed.ToString">
<summary>This is an internal API.
    </summary>
    <returns>A text string.
    </returns>
</doc>
<doc name="T:PeterO.Numbers.IShiftAccumulator">
<summary>Common interface for classes that shift a number of digits and record
      information on whether a nonzero digit was discarded this way.
    </summary>
</doc>
<doc name="T:PeterO.Numbers.RadixMath`1">
<summary>Encapsulates radix-independent arithmetic.
    </summary>
    <typeparam name='T'>Data type for a numeric value in a particular radix.
    </typeparam>
</doc>
<doc name="T:PeterO.Pair`2">
<summary>Stores a pair of related objects.
    </summary>
    <typeparam name='TFirst'>Object type for the first object in the pair.
    </typeparam>
    <typeparam name='TSecond'>Object type for the second object in the pair.
    </typeparam>
</doc>
<doc name="M:PeterO.Pair`2.#ctor(`0,`1)">
<summary>Initializes a new instance of the
      <see cref='&lt;TFirst,TSecond&gt;'/>
       class.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a TFirst object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a TSecond object.
    </param>
</doc>
<doc name="M:PeterO.Pair`2.Equals(PeterO.Pair{`0,`1})">
<summary>Not documented yet.
    </summary>
    <param name='other'>The parameter
      <paramref name='other'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Pair`2.Equals(System.Object)">
<summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="P:PeterO.Pair`2.First">
<summary>Gets the first object in the pair.
    </summary>
    <value>The first object in the pair.
    </value>
</doc>
<doc name="M:PeterO.Pair`2.GetHashCode">
<summary>Returns the hash code for this instance.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="P:PeterO.Pair`2.Second">
<summary>Gets the second object in the pair.
    </summary>
    <value>The second object in the pair.
    </value>
    <returns>A TSecond object.
    </returns>
</doc>
<doc name="M:PeterO.Pair`2.ToString">
<summary>Converts this object to a text string.
    </summary>
    <returns>A text string.
    </returns>
</doc>
<doc name="T:PeterO.PartialStream">
<summary>Represents a portion of another data stream. For this to work, the
      underlying stream must be seekable and have a known length.
    </summary>
</doc>
<doc name="M:PeterO.PartialStream.#ctor(System.IO.Stream,System.Int64,System.Int64)">
<summary>Initializes a new instance of the
      <see cref='PeterO.PartialStream'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is a Stream object.
    </param>
    <param name='start'>The parameter
      <paramref name='start'/>
       is a 64-bit signed integer.
    </param>
    <param name='length'>The parameter
      <paramref name='length'/>
       is a 64-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.PartialStream.#ctor(System.IO.Stream,System.Int64,System.Int64,System.Boolean)">
<summary>Initializes a new instance of the
      <see cref='PeterO.PartialStream'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is a Stream object.
    </param>
    <param name='start'>The start of the partial stream from the underlying stream.
    </param>
    <param name='length'>The length of the partial stream in bytes.
    </param>
    <param name='closeOnDispose'>If true, closes the underlying stream when disposing the partial stream.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='stream'/>
       or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='ArgumentException'>The parameter
      <paramref name='stream'/>
       doesn't support seeking, the length or start is less than 0 or greater
      than the underlying stream's length, or the partial stream would go beyond
      the underlying stream.
    </exception>
</doc>
<doc name="P:PeterO.PartialStream.CanRead">
<summary>Gets a value indicating whether the underlying stream supports reading.
    </summary>
    <value><c>true</c> If the underlying stream supports reading; otherwise, <c>false</c> .
    </value>
</doc>
<doc name="P:PeterO.PartialStream.CanSeek">
<summary>Gets a value indicating whether the underlying stream supports seeking.
    </summary>
    <value><c>true</c> If the underlying stream supports seeking; otherwise, <c>false</c> .
    </value>
</doc>
<doc name="P:PeterO.PartialStream.CanWrite">
<summary>Gets a value indicating whether the underlying stream supports writing.
    </summary>
    <value><c>true</c> If the underlying stream supports writing; otherwise, <c>false</c> .
    </value>
</doc>
<doc name="M:PeterO.PartialStream.Dispose(System.Boolean)">
<summary>Not documented yet.
    </summary>
    <param name='disposing'>The parameter
      <paramref name='disposing'/>
       is either
      <c>true</c> or
      <c>false</c> .
    </param>
</doc>
<doc name="M:PeterO.PartialStream.Flush">
<summary>Not documented yet.
    </summary>
</doc>
<doc name="P:PeterO.PartialStream.Length">
<summary>Gets the partial stream's length in bytes.
    </summary>
    <value>The partial stream's length in bytes.
    </value>
</doc>
<doc name="P:PeterO.PartialStream.Position">
<summary>Gets the partial stream's current byte position.
    </summary>
    <value>The partial stream's current byte position.
    </value>
</doc>
<doc name="M:PeterO.PartialStream.Read(System.Byte[],System.Int32,System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='buffer'>A byte array.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='buffer'/>
       begins.
    </param>
    <param name='count'>The number of elements in the desired portion of
      <paramref name='buffer'/>
       (but not more than
      <paramref name='buffer'/>
       's length).
    </param>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='buffer'/>
       is null.
    </exception>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='count'/>
       is less than 0 or greater than
      <paramref name='buffer'/>
       's length, or
      <paramref name='buffer'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='count'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.PartialStream.Seek(System.Int64,System.IO.SeekOrigin)">
<summary>Not documented yet.
    </summary>
    <param name='offset'>The parameter
      <paramref name='offset'/>
       is a 64-bit signed integer.
    </param>
    <param name='origin'>The parameter
      <paramref name='origin'/>
       is a SeekOrigin object.
    </param>
    <returns>A 64-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.PartialStream.SetLength(System.Int64)">
<summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.PartialStream.Write(System.Byte[],System.Int32,System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='buffer'>A byte array.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='buffer'/>
       begins.
    </param>
    <param name='count'>The number of elements in the desired portion of
      <paramref name='buffer'/>
       (but not more than
      <paramref name='buffer'/>
       's length).
    </param>
</doc>
<doc name="T:PeterO.Png">
<summary>A simple class for encoding PNG image files.
    </summary>
</doc>
<doc name="M:PeterO.Png.#ctor(System.Int32,System.Int32)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Png'/>
       class.
    </summary>
    <param name='width'>The parameter
      <paramref name='width'/>
       is a 32-bit signed integer.
    </param>
    <param name='height'>The parameter
      <paramref name='height'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.Png.GetFilter(System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte (from 0 to 255).
    </returns>
</doc>
<doc name="M:PeterO.Png.GetPixel(System.Int32,System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='x'>x-coordinate within the image.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte array.
    </returns>
</doc>
<doc name="P:PeterO.Png.Height">
<summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
</doc>
<doc name="M:PeterO.Png.Save(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='filename'>The parameter
      <paramref name='filename'/>
       is a text string.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='filename'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Png.SetFilter(System.Int32,System.Byte)">
<summary>Not documented yet.
    </summary>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='filter'>The parameter
      <paramref name='filter'/>
       is a byte (from 0 to 255).
    </param>
</doc>
<doc name="M:PeterO.Png.SetPixel(System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)">
<summary>Not documented yet.
    </summary>
    <param name='x'>x-coordinate within the image.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='r'>Red component of the pixel.
    </param>
    <param name='g'>Green component of the pixel.
    </param>
    <param name='b'>Blue component of the pixel.
    </param>
</doc>
<doc name="M:PeterO.Png.SetPixel(System.Int32,System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
<summary>Not documented yet.
    </summary>
    <param name='x'>x-coordinate within the image.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='r'>Red component of the pixel.
    </param>
    <param name='g'>Green component of the pixel.
    </param>
    <param name='b'>Blue component of the pixel.
    </param>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a byte (from 0 to 255).
    </param>
</doc>
<doc name="M:PeterO.Png.SetPixel(System.Int32,System.Int32,System.Byte[])">
<summary>Not documented yet.
    </summary>
    <param name='x'>x-coordinate within the image.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='pixel'>A byte array.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='pixel'/>
       is null.
    </exception>
</doc>
<doc name="P:PeterO.Png.Width">
<summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
</doc>
<doc name="T:PeterO.Png4BitIndexed">
<summary>A simple class for encoding PNG image files.
    </summary>
</doc>
<doc name="M:PeterO.Png4BitIndexed.#ctor(System.Int32,System.Int32)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Png4BitIndexed'/>
       class.
    </summary>
    <param name='width'>The parameter
      <paramref name='width'/>
       is a 32-bit signed integer.
    </param>
    <param name='height'>The parameter
      <paramref name='height'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.Png4BitIndexed.GetColor(System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte array.
    </returns>
</doc>
<doc name="M:PeterO.Png4BitIndexed.GetPixel(System.Int32,System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='x'>The parameter
      <paramref name='x'/>
       is a 32-bit signed integer.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="P:PeterO.Png4BitIndexed.Height">
<summary>Gets the height of the image.
    </summary>
    <value>The height of the image.
    </value>
</doc>
<doc name="M:PeterO.Png4BitIndexed.Save(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='filename'>The parameter
      <paramref name='filename'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.Png4BitIndexed.SetColor(System.Int32,System.Byte[])">
<summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='color'>A byte array.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='color'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Png4BitIndexed.SetPixel(System.Int32,System.Int32,System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='x'>x-coordinate within the image.
    </param>
    <param name='y'>y-coordinate within the image.
    </param>
    <param name='pixel'>The parameter
      <paramref name='pixel'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="P:PeterO.Png4BitIndexed.Transparent">
<summary>Gets or sets the index of the transparent color.
    </summary>
    <value>The index of the transparent color.
    </value>
</doc>
<doc name="P:PeterO.Png4BitIndexed.Width">
<summary>Gets the width of the image.
    </summary>
    <value>The width of the image.
    </value>
</doc>
<doc name="T:PeterO.Png8BitIndexed">
<summary>A simple class for encoding PNG image files.
    </summary>
</doc>
<doc name="M:PeterO.Png8BitIndexed.#ctor(System.Int32,System.Int32)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Png8BitIndexed'/>
       class.
    </summary>
    <param name='width'>The parameter
      <paramref name='width'/>
       is a 32-bit signed integer.
    </param>
    <param name='height'>The parameter
      <paramref name='height'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.Png8BitIndexed.GetColor(System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte array.
    </returns>
</doc>
<doc name="M:PeterO.Png8BitIndexed.GetFilter(System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte (from 0 to 255).
    </returns>
</doc>
<doc name="M:PeterO.Png8BitIndexed.GetPixel(System.Int32,System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='x'>The parameter
      <paramref name='x'/>
       is a 32-bit signed integer.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="P:PeterO.Png8BitIndexed.Height">
<summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
</doc>
<doc name="M:PeterO.Png8BitIndexed.Save(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='filename'>The parameter
      <paramref name='filename'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.Png8BitIndexed.SetColor(System.Int32,System.Byte[])">
<summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='color'>A byte array.
    </param>
</doc>
<doc name="M:PeterO.Png8BitIndexed.SetFilter(System.Int32,System.Byte)">
<summary>Not documented yet.
    </summary>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='filter'>The parameter
      <paramref name='filter'/>
       is a byte (from 0 to 255).
    </param>
</doc>
<doc name="M:PeterO.Png8BitIndexed.SetPixel(System.Int32,System.Int32,System.Int32)">
<summary>Not documented yet.
    </summary>
    <param name='x'>x-coordinate within the image.
    </param>
    <param name='y'>y-coordinate within the image.
    </param>
    <param name='pixel'>The parameter
      <paramref name='pixel'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="P:PeterO.Png8BitIndexed.Transparent">
<summary>Gets or sets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
</doc>
<doc name="P:PeterO.Png8BitIndexed.Width">
<summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
</doc>
<doc name="T:PeterO.PrecisionContext">
<summary>A precision context.
    </summary>
</doc>
<doc name="M:PeterO.PrecisionContext.#ctor(System.Int32,PeterO.Rounding,System.Int32,System.Int32,System.Boolean)">
<summary>Initializes a new instance of the
      <see cref='PeterO.PrecisionContext'/>
       class. HasFlags will be set to false.
    </summary>
    <param name='precision'>The maximum number of digits a number can have, or 0 for an unlimited
      number of digits.
    </param>
    <param name='rounding'>The rounding mode to use when a number can't fit the given precision.
    </param>
    <param name='exponentMinSmall'>The minimum exponent.
    </param>
    <param name='exponentMaxSmall'>The maximum exponent.
    </param>
    <param name='clampNormalExponents'>Whether to clamp a number's significand to the given maximum precision (if
      it isn't zero) while remaining within the exponent range.
    </param>
</doc>
<doc name="M:PeterO.PrecisionContext.ToString">
<summary>Gets a string representation of this object. Note that the format is not
      intended to be parsed and may change at any time.
    </summary>
    <returns>A string representation of this object.
    </returns>
</doc>
<doc name="T:PeterO.Rdf.IRDFParser">

            <summary>Not documented yet.</summary>

</doc>
<doc name="M:PeterO.Rdf.IRDFParser.Parse">

            <summary>Not documented yet.</summary>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="T:PeterO.Rdf.NTriplesParser">

            <summary>Not documented yet.</summary>

</doc>
<doc name="M:PeterO.Rdf.NTriplesParser.#ctor(PeterO.IByteReader)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.NTriplesParser'/> class.</summary>
            <param name='stream'>A PeterO.IByteReader object.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> is null.</exception>

</doc>
<doc name="M:PeterO.Rdf.NTriplesParser.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.NTriplesParser'/> class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.Rdf.NTriplesParser.IsAsciiChar(System.Int32,System.String)">

            <summary>Not documented yet.</summary>
            <param name='c'>The parameter <paramref name='c'/> is a 32-bit
            signed integer.</param>
            <param name='asciiChars'>The parameter <paramref name='asciiChars'/> is a text string.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='asciiChars'/> is null.</exception>

</doc>
<doc name="M:PeterO.Rdf.NTriplesParser.Parse">

            <summary>Not documented yet.</summary>
            <returns>An ISet(RDFTriple) object.</returns>

</doc>
<doc name="M:PeterO.Rdf.NTriplesParser.isAsciiChar(System.Int32,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='c'>The parameter
      <paramref name='c'/>
       is not documented yet.
    </param>
    <param name='asciiChars'>The parameter
      <paramref name='asciiChars'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="T:PeterO.Rdf.ParserException">

            <summary>Exception thrown for errors that occur while parsing data.
            <para>This library may throw exceptions of this type in certain
            cases, notably when errors occur, and may supply messages to those
            exceptions (the message can be accessed through the <c>Message</c> property in.NET or the <c>getMessage()</c> method in Java). These
            messages are intended to be read by humans to help diagnose the
            error (or other cause of the exception); they are not intended to
            be parsed by computer programs, and the exact text of the messages
            may change at any time between versions of this
            library.</para></summary>

</doc>
<doc name="M:PeterO.Rdf.ParserException.#ctor">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.ParserException'/> class.</summary>

</doc>
<doc name="M:PeterO.Rdf.ParserException.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.ParserException'/> class.</summary>
            <param name='message'>The parameter <paramref name='message'/> is a
            text string.</param>

</doc>
<doc name="M:PeterO.Rdf.ParserException.#ctor(System.String,System.Exception)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.ParserException'/> class. Uses the given
            message and inner exception.</summary>
            <param name='message'>The parameter <paramref name='message'/> is a
            text string.</param>
            <param name='innerException'>The parameter <paramref name='innerException'/> is an Exception object.</param>

</doc>
<doc name="M:PeterO.Rdf.RDFInternal.ReplaceBlankNodes(System.Collections.Generic.ISet{PeterO.Rdf.RDFTriple},System.Collections.Generic.IDictionary{System.String,PeterO.Rdf.RDFTerm})">

            <summary>Not documented yet.</summary>
            <param name='triples'>The parameter <paramref name='triples'/> is
            a.Collections.Generic.ISet{PeterO.Rdf.RDFTriple} object.</param>
            <param name='bnodeLabels'>The parameter <paramref name='bnodeLabels'/> is a.Collections.Generic.IDictionary
            {System.String object.</param>

</doc>
<doc name="M:PeterO.Rdf.RDFInternal.replaceBlankNodes(System.Collections.Generic.ISet{PeterO.Rdf.RDFTriple},System.Collections.Generic.IDictionary{System.String,PeterO.Rdf.RDFTerm})">
<summary>Not documented yet.
    </summary>
    <param name='triples'>The parameter
      <paramref name='triples'/>
       is not documented yet.
    </param>
    <param name='bnodeLabels'>The parameter
      <paramref name='bnodeLabels'/>
       is not documented yet.
    </param>
</doc>
<doc name="T:PeterO.Rdf.RDFTerm">

            <summary>Not documented yet.</summary>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.A">

            <summary>Predicate for RDF types.</summary>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.BLANK">

            <summary>Type value for a blank node.</summary>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.Equals(System.Object)">

            <summary>Not documented yet.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is a Object
            object.</param>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.FALSE">

            <summary>Object for false.</summary>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.FIRST">

            <summary>Predicate for the first object in a list.</summary>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.FromBlankNode(System.String)">

            <summary>Not documented yet.</summary>
            <param name='name'>The parameter <paramref name='name'/> is a text
            string.</param>
            <returns>A RDFTerm object.</returns>
            <exception cref='ArgumentException'>Name is empty.</exception>
            <exception cref='ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.FromIRI(System.String)">

            <summary>Not documented yet.</summary>
            <param name='iri'>The parameter <paramref name='iri'/> is a text
            string.</param>
            <returns>A RDFTerm object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='iri'/> is null.</exception>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.FromLangString(System.String,System.String)">

            <summary>Not documented yet.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='languageTag'>The parameter <paramref name='languageTag'/> is a text string.</param>
            <returns>A RDFTerm object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> or <paramref name='languageTag'/> is null.</exception>
            <exception cref='ArgumentException'>LanguageTag is
            empty.</exception>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.FromTypedString(System.String)">

            <summary>Not documented yet.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>A RDFTerm object.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.FromTypedString(System.String,System.String)">

            <summary>Not documented yet.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='iri'>The parameter <paramref name='iri'/> is a text
            string.</param>
            <returns>A RDFTerm object.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> or <paramref name='iri'/> is null.</exception>
            <exception cref='ArgumentException'>Iri is empty.</exception>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.GetHashCode">

            <summary>Not documented yet.</summary>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.GetKind">

            <summary>Not documented yet.</summary>
            <returns>A 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.GetTypeOrLanguage">

            <summary>Gets the language tag or data type for this RDF
            literal.</summary>
            <returns>A text string.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.GetValue">

            <summary>Gets the IRI, blank node identifier, or lexical form of an
            RDF literal.</summary>
            <returns>A text string.</returns>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.IRI">

            <summary>Type value for an IRI (Internationalized Resource
            Identifier.).</summary>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.IsBlank">

            <summary>Gets a value indicating whether this term is a blank
            node.</summary>
            <returns>Either <c>true</c> or <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.IsIRI(System.String)">

            <summary>Not documented yet.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <returns>Either <c>true</c> or <c>false</c>.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.IsOrdinaryString">

            <summary>Not documented yet.</summary>
            <returns>Either <c>true</c> or <c>false</c>.</returns>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.LANGSTRING">

            <summary>Type value for a string with a language tag.</summary>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.NIL">

            <summary>Object for nil, the end of a list, or an empty
            list.</summary>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.REST">

            <summary>Predicate for the remaining objects in a list.</summary>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.TRUE">

            <summary>Object for true.</summary>

</doc>
<doc name="F:PeterO.Rdf.RDFTerm.TYPEDSTRING">

            <summary>Type value for a piece of data serialized to a
            string.</summary>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.ToString">

            <summary>Gets a string representation of this RDF term in N-Triples
            format. The string will not end in a line break.</summary>
            <returns>A string representation of this object.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTerm.getKind">
<summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.RDFTerm.getTypeOrLanguage">
<summary>Gets the language tag or data type for this RDF literal.
    </summary>
    <returns>A text string.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.RDFTerm.getValue">
<summary>Gets the IRI, blank node identifier, or lexical form of an RDF literal.
    </summary>
    <returns>A text string.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.RDFTerm.isBlank">
<summary>Gets whether this term is a blank node.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.RDFTerm.isIRI(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.RDFTerm.isOrdinaryString">
<summary>Not documented yet.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="T:PeterO.Rdf.RDFTriple">

            <summary>Not documented yet.</summary>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.#ctor(PeterO.Rdf.RDFTerm,PeterO.Rdf.RDFTerm,PeterO.Rdf.RDFTerm)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.RDFTriple'/> class.</summary>
            <param name='subject'>The subject term.</param>
            <param name='predicate'>The predicate term.</param>
            <param name='objectRdf'>The object term.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='objectRdf'/> or <paramref name='predicate'/> or <paramref name='subject'/> is null.</exception>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.#ctor(PeterO.Rdf.RDFTriple)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.RDFTriple'/> class.</summary>
            <param name='triple'>The parameter <paramref name='triple'/> is a
            RDFTriple object.</param>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.Equals(System.Object)">

            <summary>Not documented yet.</summary>
            <param name='obj'>The parameter <paramref name='obj'/> is a Object
            object.</param>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.GetHashCode">

            <summary>Not documented yet.</summary>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.GetObject">

            <summary>Not documented yet.</summary>
            <returns>A RDFTerm object.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.GetPredicate">

            <summary>Not documented yet.</summary>
            <returns>A RDFTerm object.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.GetSubject">

            <summary>Not documented yet.</summary>
            <returns>A RDFTerm object.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.ToString">

            <summary>Not documented yet.</summary>
            <returns>The return value is not documented yet.</returns>

</doc>
<doc name="M:PeterO.Rdf.RDFTriple.getObject">
<summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.RDFTriple.getPredicate">
<summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.RDFTriple.getSubject">
<summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
</doc>
<doc name="T:PeterO.Rdf.TurtleParser">

            <summary>Not documented yet.</summary>

</doc>
<doc name="M:PeterO.Rdf.TurtleParser.#ctor(PeterO.IByteReader)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.TurtleParser'/> class.</summary>
            <param name='stream'>A PeterO.IByteReader object.</param>

</doc>
<doc name="M:PeterO.Rdf.TurtleParser.#ctor(PeterO.IByteReader,System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.TurtleParser'/> class.</summary>
            <param name='stream'>A PeterO.IByteReader object.</param>
            <param name='baseURI'>The parameter <paramref name='baseURI'/> is a
            text string.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='stream'/> or <paramref name='baseURI'/> is null.</exception>
            <exception cref='ArgumentException'>BaseURI has no
            scheme.</exception>

</doc>
<doc name="M:PeterO.Rdf.TurtleParser.#ctor(PeterO.IByteReader,System.Uri)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.TurtleParser'/> class.</summary>
            <param name='stream'>The parameter <paramref name='stream'/> is an
            IByteReader object.</param>
            <param name='baseURI'>The parameter <paramref name='baseURI'/> is
            an Uri object.</param>

</doc>
<doc name="M:PeterO.Rdf.TurtleParser.#ctor(System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.TurtleParser'/> class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>

</doc>
<doc name="M:PeterO.Rdf.TurtleParser.#ctor(System.String,System.String)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.TurtleParser'/> class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='baseURI'>The parameter <paramref name='baseURI'/> is a
            text string.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='str'/> or <paramref name='baseURI'/> is null.</exception>
            <exception cref='ArgumentException'>BaseURI.</exception>

</doc>
<doc name="M:PeterO.Rdf.TurtleParser.#ctor(System.String,System.Uri)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.Rdf.TurtleParser'/> class.</summary>
            <param name='str'>The parameter <paramref name='str'/> is a text
            string.</param>
            <param name='baseURI'>The parameter <paramref name='baseURI'/> is
            an Uri object.</param>

</doc>
<doc name="M:PeterO.Rdf.TurtleParser.Parse">

            <summary>Not documented yet.</summary>
            <returns>An ISet(RDFTriple) object.</returns>

</doc>
<doc name="T:PeterO.Rdf.URIUtility">
<summary>Contains auxiliary methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
</doc>
<doc name="T:PeterO.Rdf.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.escapeURI(System.String,System.Int32)">
<returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
    <summary>Escapes characters that cannot appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.hasScheme(System.String)">
<summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.hasSchemeForURI(System.String)">
<summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise, <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue. Example: http://example.com/my/path/dir/file.txt.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
      <returns>If the string is a valid IRI reference, returns an array of 10 integers.
        Each of the five pairs corresponds to the start and end index of the
        IRI's scheme, authority, path, query, or fragment component,
        respectively. If a component is absent, both indices in that pair will
        be -1. If the string is null or is not a valid IRI, returns null.
      </returns>
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1. If the string
      is null or is not a valid IRI, returns null.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1 (an index won't
      be less than 0 in any other case). If the string is null or is not a valid
      IRI, returns null.
    </returns>
</doc>
<doc name="T:PeterO.Rounding">
<summary><para><b>This class is obsolete. It will be replaced by a new version of this
          class in a different namespace/package and library, called
          <c>PeterO.Numbers.ERounding</c> in the
          <c>PeterO.ERounding</c> library (in .NET), or
          <c>com.upokecenter.numbers.EFloat</c> in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java).</b> </para>
       Specifies the mode to use when "shortening" numbers that otherwise can't
      fit a given number of digits, so that the shortened number has about the
      same value. This "shortening" is known as rounding.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.Ceiling">
<summary>If there is a fractional part, the number is rounded to the highest
      representable number that's closest to it.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.Down">
<summary>The fractional part is discarded (the number is truncated).
    </summary>
</doc>
<doc name="F:PeterO.Rounding.Floor">
<summary>If there is a fractional part, the number is rounded to the lowest
      representable number that's closest to it.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.HalfDown">
<summary>Rounded to the nearest number; if the fractional part is exactly half, it
      is discarded.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.HalfEven">
<summary>Rounded to the nearest number; if the fractional part is exactly half, the
      number is rounded to the closest representable number that is even. This
      is sometimes also known as "banker's rounding".
    </summary>
</doc>
<doc name="F:PeterO.Rounding.HalfUp">
<summary>Rounded to the nearest number; if the fractional part is exactly half, the
      number is rounded to the closest representable number away from zero. This
      is the most familiar rounding mode for many people.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.Odd">
<summary>If there is a fractional part and the whole number part is even, the
      number is rounded to the closest representable odd number away from zero.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.OddOrZeroFiveUp">
<summary>For binary floating point numbers, this is the same as Odd. For other
      bases (including decimal numbers), this is the same as ZeroFiveUp. This
      rounding mode is useful for rounding intermediate results at a slightly
      higher precision (at least 2 bits more for binary) than the final
      precision.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.Unnecessary">
<summary>Indicates that rounding will not be used. If rounding is required, the
      rounding operation will report an error.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.Up">
<summary>If there is a fractional part, the number is rounded to the closest
      representable number away from zero.
    </summary>
</doc>
<doc name="F:PeterO.Rounding.ZeroFiveUp">
<summary>If there is a fractional part and if the last digit before rounding is 0
      or half the radix, the number is rounded to the closest representable
      number away from zero; otherwise the fractional part is discarded. In
      overflow, the fractional part is always discarded.
    </summary>
</doc>
<doc name="M:PeterO.SingleComparer.GetHashCode(System.Single)">
<summary>Returns the hash code for this instance.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is not documented yet.
    </param>
    <returns>A 32-bit hash code.
    </returns>
</doc>
<doc name="T:PeterO.StackableCharacterInput">

            <summary>A character input stream where additional inputs can be
            stacked on.</summary>

</doc>
<doc name="M:PeterO.StackableCharacterInput.#ctor(PeterO.Text.ICharacterInput)">

            <summary>Initializes a new instance of the
            <see cref='PeterO.StackableCharacterInput'/> class.</summary>
            <param name='source'>The parameter <paramref name='source'/> is an
            ICharacterInput object.</param>

</doc>
<doc name="M:PeterO.StackableCharacterInput.GetMarkPosition">

            <summary>Not documented yet.</summary>
            <returns>A 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.StackableCharacterInput.MoveBack(System.Int32)">

            <summary>Not documented yet.</summary>
            <param name='count'>The parameter <paramref name='count'/> is a
            32-bit signed integer.</param>

</doc>
<doc name="M:PeterO.StackableCharacterInput.PushInput(PeterO.Text.ICharacterInput)">

            <summary>Not documented yet.</summary>
            <param name='input'>The parameter <paramref name='input'/> is
            a.Text.ICharacterInput object.</param>
            <exception cref='ArgumentNullException'>The parameter <paramref name='input'/> is null.</exception>

</doc>
<doc name="M:PeterO.StackableCharacterInput.Read(System.Int32[],System.Int32,System.Int32)">

            <summary>Not documented yet.</summary>
            <param name='buf'>The parameter <paramref name='buf'/> is a.Int32[]
            object.</param>
            <param name='offset'>The parameter <paramref name='offset'/> is a
            32-bit signed integer.</param>
            <param name='unitCount'>The parameter <paramref name='unitCount'/>
            is a 32-bit signed integer.</param>
            <returns>A 32-bit signed integer.</returns>
            <exception cref='ArgumentNullException'>The parameter <paramref name='buf'/> is null.</exception>

</doc>
<doc name="M:PeterO.StackableCharacterInput.ReadChar">

            <summary>Not documented yet.</summary>
            <returns>A 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.StackableCharacterInput.SetHardMark">

            <summary>Not documented yet.</summary>
            <returns>A 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.StackableCharacterInput.SetMarkPosition(System.Int32)">

            <summary>Not documented yet.</summary>
            <param name='pos'>The parameter <paramref name='pos'/> is a 32-bit
            signed integer.</param>

</doc>
<doc name="M:PeterO.StackableCharacterInput.SetSoftMark">

            <summary>Not documented yet.</summary>
            <returns>A 32-bit signed integer.</returns>

</doc>
<doc name="M:PeterO.StackableCharacterInput.getMarkPosition">
<returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.StackableCharacterInput.moveBack(System.Int32)">
<param name='count'>The parameter
      <paramref name='count'/>
       is not documented yet.
    </param>
</doc>
<doc name="M:PeterO.StackableCharacterInput.pushInput(PeterO.Text.ICharacterInput)">
<summary>Not documented yet.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is not documented yet.
    </param>
</doc>
<doc name="M:PeterO.StackableCharacterInput.setHardMark">
<summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.StackableCharacterInput.setMarkPosition(System.Int32)">
<param name='pos'>The parameter
      <paramref name='pos'/>
       is not documented yet.
    </param>
</doc>
<doc name="M:PeterO.StackableCharacterInput.setSoftMark">
<returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Text.ByteData.DecompressLz4(System.Byte[])">
<summary>Decompresses a byte array compressed using the LZ4 format (see "LZ4 Format
      Description" by Y Collet for more information).
    </summary>
    <param name='input'>Input byte array.
    </param>
    <returns>Decompressed output byte array.
    </returns>
    <exception cref='ArgumentNullException'>The parameter "output" is null.
    </exception>
</doc>
<doc name="T:PeterO.Text.CharacterReader">
<summary>A general-purpose character input for reading text from byte streams and
      text strings. When reading byte streams, this class supports the UTF-8
      character encoding by default, but can be configured to support UTF-16 and
      UTF-32 as well.
    </summary>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.IO.Stream)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class; will read the stream as UTF-8, skip the byte-order mark (U+FEFF)
      if it appears first in the stream, and replace invalid byte sequences with
      replacement characters (U+FFFD).
    </summary>
    <param name='stream'>A readable data stream.
    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.IO.Stream,System.Int32)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class; will skip the byte-order mark (U+FEFF) if it appears first in the
      stream and replace invalid byte sequences with replacement characters
      (U+FFFD).
    </summary>
    <param name='stream'>A readable byte stream.
    </param>
    <param name='mode'>The method to use when detecting encodings other than UTF-8 in the byte
      stream. This usually involves checking whether the stream begins with a
      byte-order mark (BOM, U+FEFF) or a nonzero basic code point (NZB, U+0001
      to U+007F) before reading the rest of the stream. This value can be one of
      the following:
      <list>
        <item>0: UTF-8 only.
        </item>
        <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.
        </item>
        <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8. (Tries to
          detect UTF-32 first.)
        </item>
        <item>3: Detect UTF-16 using BOM, otherwise UTF-8.
        </item>
        <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to detect
          UTF-32 first.)
        </item>
      </list>
       .
    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class; will skip the byte-order mark (U+FEFF) if it appears first in the
      stream.
    </summary>
    <param name='stream'>A readable byte stream.
    </param>
    <param name='mode'>The method to use when detecting encodings other than UTF-8 in the byte
      stream. This usually involves checking whether the stream begins with a
      byte-order mark (BOM, U+FEFF) or a nonzero basic code point (NZB, U+0001
      to U+007F) before reading the rest of the stream. This value can be one of
      the following:
      <list>
        <item>0: UTF-8 only.
        </item>
        <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.
        </item>
        <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8. (Tries to
          detect UTF-32 first.)
        </item>
        <item>3: Detect UTF-16 using BOM, otherwise UTF-8.
        </item>
        <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to detect
          UTF-32 first.)
        </item>
      </list>
       .
    </param>
    <param name='errorThrow'>If true, will throw an exception if invalid byte sequences (in the
      detected encoding) are found in the byte stream. If false, replaces those
      byte sequences with replacement characters (U+FFFD) as the stream is read.

    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.IO.Stream,System.Int32,System.Boolean,System.Boolean)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class.
    </summary>
    <param name='stream'>A readable byte stream.
    </param>
    <param name='mode'>The method to use when detecting encodings other than UTF-8 in the byte
      stream. This usually involves checking whether the stream begins with a
      byte-order mark (BOM, U+FEFF) or a nonzero basic code point (NZB, U+0001
      to U+007F) before reading the rest of the stream. This value can be one of
      the following:
      <list>
        <item>0: UTF-8 only.
        </item>
        <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.
        </item>
        <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8. (Tries to
          detect UTF-32 first.)
        </item>
        <item>3: Detect UTF-16 using BOM, otherwise UTF-8.
        </item>
        <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to detect
          UTF-32 first.)
        </item>
      </list>
       .
    </param>
    <param name='errorThrow'>If true, will throw an exception if invalid byte sequences (in the
      detected encoding) are found in the byte stream. If false, replaces those
      byte sequences with replacement characters (U+FFFD) as the stream is read.

    </param>
    <param name='dontSkipUtf8Bom'>If the stream is detected as UTF-8 and this parameter is
      <c>true</c> , won't skip the BOM character if it occurs at the start of the stream.
    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.String)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class using a Unicode 16-bit string; if the string begins with a
      byte-order mark (U+FEFF), it won't be skipped, and any unpaired surrogate
      code points (U+D800 to U+DFFF) in the string are replaced with replacement
      characters (U+FFFD).
    </summary>
    <param name='str'>The string to read.
    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.String,System.Boolean)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class using a Unicode 16-bit string; any unpaired surrogate code points
      (U+D800 to U+DFFF) in the string are replaced with replacement characters
      (U+FFFD).
    </summary>
    <param name='str'>The string to read.
    </param>
    <param name='skipByteOrderMark'>If true and the string begins with a byte-order mark (U+FEFF), will skip
      that code point as it reads the string.
    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.String,System.Boolean,System.Boolean)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class using a Unicode 16-bit string.
    </summary>
    <param name='str'>The string to read.
    </param>
    <param name='skipByteOrderMark'>If true and the string begins with a byte-order mark (U+FEFF), will skip
      that code point as it reads the string.
    </param>
    <param name='errorThrow'>If true, will throw an exception if unpaired surrogate code points (U+D800
      to U+DFFF) are found in the string. If false, replaces those byte
      sequences with replacement characters (U+FFFD) as the stream is read.
    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.String,System.Int32,System.Int32)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.#ctor(System.String,System.Int32,System.Int32,System.Boolean,System.Boolean)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.CharacterReader'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <param name='skipByteOrderMark'>If true and the string begins with a byte-order mark (U+FEFF), will skip
      that code point as it reads the string.
    </param>
    <param name='errorThrow'>If true, will throw an exception if unpaired surrogate code points (U+D800
      to U+DFFF) are found in the string. If false, replaces those byte
      sequences with replacement characters (U+FFFD) as the stream is read.
    </param>
</doc>
<doc name="M:PeterO.Text.CharacterReader.Read(System.Int32[],System.Int32,System.Int32)">
<summary>Reads a series of code points from a Unicode stream or a string.
    </summary>
    <param name='chars'>An array where the code points that were read will be stored.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>The number of code points read from the stream. This can be less than the
      <paramref name='length'/>
       parameter if the end of the stream is reached.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='chars'/>
       is null.
    </exception>
    <exception cref='ArgumentException'>Either
      <paramref name='index'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='chars'/>
       's length, or
      <paramref name='chars'/>
       's length minus
      <paramref name='index'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Text.CharacterReader.ReadChar">
<summary>Reads the next character from a Unicode stream or a string.
    </summary>
    <returns>The next character, or -1 if the end of the string or stream was reached.
    </returns>
</doc>
<doc name="T:PeterO.Text.DomainUtility">
<summary>Utility methods for domain names.
    </summary>
</doc>
<doc name="M:PeterO.Text.DomainUtility.PunycodeLength(System.String,System.Int32,System.Int32)">
<summary>Gets the Punycode length of a string (Punycode is defined in RFC 3492).
    </summary>
    <param name='str'>A string containing the desired portion to get the length for.
    </param>
    <param name='index'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The Punycode length of the encoded string. If the string contains code
      points outside the Basic Latin range (U+0000 to U+007F), returns the
      Punycode length plus 4 (the length of the prefix "xn--", which indicates
      an internationalized domain name). If there are only Basic Latin code
      points, returns the length of the string. Returns -1 if an overflow error
      occurs.
    </returns>
    <exception cref='ArgumentNullException'>Either
      <paramref name='index'/>
       or
      <paramref name='endIndex'/>
       is less than 0 or greater than
      <paramref name='str'/>
       's length, or
      <paramref name='index'/>
       is greater than
      <paramref name='endIndex'/>
       .
    </exception>
</doc>
<doc name="T:PeterO.Text.Encodings">
<summary>Contains methods for converting text from one character encoding to
      another. This class also contains convenience methods for converting
      strings and other character inputs to sequences of bytes and vice versa.
      <para>The Encoding Standard, which is a Candidate Recommendation as of early
        November 2015, defines algorithms for the most common character
        encodings used on Web pages and recommends the UTF-8 encoding for new
        specifications and Web pages. Calling the
        <c>GetEncoding(name)</c> method returns one of the character encodings with the given name under
        the Encoding Standard.
      </para>
      <para>Now let's define some terms.
      </para>
      <para><b>Encoding Terms</b> </para>
      <list>
        <item>A
          <b>code point</b> is a number that identifies a single text character, such as a
          letter, digit, or symbol. (A collection of such characters is also
          called an
          <i>
             abstract character repertoire
          </i>
           .)
        </item>
        <item>A
          <b>coded character set</b> is a set of code points which are each assigned to a single text
          character. As used here, coded character sets don't define how code
          points are laid out in memory.
        </item>
        <item>A
          <b>character encoding</b> is a mapping from a sequence of code points, in one or more specific
          coded character sets, to a sequence of bytes and vice versa. (For
          brevity, the rest of this documentation may use the term
          <i>
             encoding
          </i>
           instead. RFC 6365 uses the analogous term
          <i>
             charset
          </i>
           instead; in this documentation, however,
          <i>
             charset
          </i>
           is used only to refer to the names that identify a character
          encoding.)
        </item>
        <item><b>ASCII</b> is a 128-code-point coded character set that includes the English
          letters and digits, common punctuation and symbols, and control
          characters. As used here, its code points match the code points within
          the Basic Latin block (0-127 or U+0000 to U+007F) of the Unicode
          Standard.
        </item>
      </list>
      <para>There are several kinds of character encodings:
      </para>
      <list>
        <item><b>Single-byte encodings</b> define a coded character set that assigns one code point to one byte.
          Thus, they can have a maximum of 256 code points. For example:
        </item>
        <item>(a) ISO 8859 encodings and
          <c>windows-1252</c> .
        </item>
        <item>(b) ASCII is usually used as a single-byte encoding where each code
          point fits in the lower 7 bits of an eight-bit byte (in that case, the
          encoding is often called
          <c>US-ASCII</c> ). In the Encoding Standard, all single-byte encodings use the ASCII
          characters as the first 128 code points of their coded character sets.

        </item>
        <item><b>Multi-byte encodings</b> include code points from one or more coded character sets and assign
          some or all code points to several bytes. For example:
        </item>
        <item>(a)
          <c>UTF-16LE</c> and
          <c>UTF-16BE</c> are two encodings defined in the Unicode Standard. They use 2 bytes
          for the most common code points, and 4 bytes for supplementary code
          points.
        </item>
        <item>(b)
          <c>UTF-8</c> is another encoding defined in the Unicode Standard. It uses 1 byte
          for ASCII and 2 to 4 bytes for the other Unicode code points.
        </item>
        <item>(c) Most legacy East Asian encodings, such as
          <c>Shift_JIS</c> ,
          <c>GBK</c> , and
          <c>Big5</c> use 1 byte for ASCII (or a slightly modified version) and, usually, 2
          or more bytes for national standard coded character sets. In many of
          these encodings, notably
          <c>Shift_JIS</c> , characters whose code points use one byte traditionally take half
          the space of characters whose code points use two bytes.
        </item>
        <item><b>Escape-based encodings</b> are combinations of single- and/or multi-byte encodings, and use
          escape sequences and/or shift codes to change which encoding to use
          for the bytes that follow. For example:
        </item>
        <item>(a)
          <c>ISO-2022-JP</c> supports several escape sequences that shift into different
          encodings, including a Katakana, a Kanji, and an ASCII encoding (with
          ASCII as the default).
        </item>
        <item>(b) UTF-7 (not included in the Encoding Standard) is an encoding that
          uses the Unicode Standard's coded character set, which is encoded
          using a limited subset of ASCII. The plus symbol (U+002B) is used to
          shift into a UTF-16BE multi-byte encoding (converted to a modified
          version of base-64) to encode other Unicode code points.
        </item>
        <item>The Encoding Standard also defines a
          <b>replacement encoding</b> , which causes a decoding error and is used to alias a few
          problematic or unsupported encoding names, such as
          <c>hz-gb-2312</c> .
        </item>
      </list>
      <para><b>Getting an Encoding</b> </para>
      <para>The Encoding Standard includes UTF-8, UTF-16, and many legacy encodings,
        and gives each one of them a name. The
        <c>GetEncoding(name)</c> method takes a name string and returns an ICharacterEncoding object
        that implements that encoding, or
        <c>null</c> if the name is unrecognized.
      </para>
      <para>However, the Encoding Standard is designed to include only encodings
        commonly used on Web pages, not in other protocols such as email. For
        email, the Encoding class includes an alternate function
        <c>GetEncoding(name, forEmail)</c> . Setting
        <c>forEmail</c> to
        <c>true</c> will use rules modified from the Encoding Standard to better suit
        encoding and decoding text from email messages.
      </para>
      <para><b>Classes for Character Encodings</b> </para>
      <para>This Encodings class provides access to common character encodings
        through classes as described below:
      </para>
      <list type=''>
        <item>An
          <b>encoder class</b> is a class that converts a sequence of bytes to a sequence of code
          points in the universal character set (otherwise known under the name
          Unicode). An encoder class implements the
          <c>ICharacterEncoder</c> interface.
        </item>
        <item>A
          <b>decoder class</b> is a class that converts a sequence of Unicode code points to a
          sequence of bytes. A decoder class implements the
          <c>ICharacterDecoder</c> interface.
        </item>
        <item>An
          <b>encoding class</b> allows access to both an encoder class and a decoder class and
          implements the
          <c>ICharacterEncoding</c> interface. The encoder and decoder classes should implement the same
          character encoding.
        </item>
      </list>
      <para><b>Custom Encodings</b> </para>
      <para>Classes that implement the ICharacterEncoding interface can provide
        additional character encodings not included in the Encoding Standard.
        Some examples of these include the following:
      </para>
      <list>
        <item>A modified version of UTF-8 used in Java's serialization formats.
        </item>
        <item>A modified version of UTF-7 used in the IMAP email protocol.
        </item>
      </list>
      <para>(Note that this library doesn't implement either encoding.)
      </para>
    </summary>
</doc>
<doc name="M:PeterO.Text.Encodings.DecodeToString(PeterO.Text.ICharacterEncoding,PeterO.IByteReader)">
<summary>Reads bytes from a data source and converts the bytes from a given
      encoding to a text string.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows: "encoding.DecodeString(input)". If the object's class
        already has a DecodeToString method with the same parameters, that
        method takes precedence over this extension method.
      </para>
    </summary>
    <param name='encoding'>An object that implements a given character encoding. Any bytes that can't
      be decoded are converted to the replacement character (U+FFFD).
    </param>
    <param name='input'>An object that implements a byte stream.
    </param>
    <returns>The converted string.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='encoding'/>
       or
      <paramref name='input'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Encodings.DecodeToString(PeterO.Text.ICharacterEncoding,System.Byte[])">
<summary>Reads a byte array from a data source and converts the bytes from a given
      encoding to a text string. Errors in decoding are handled by replacing
      erroneous bytes with the replacement character (U+FFFD).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>enc.DecodeToString(bytes)</c> . If the object's class already has a DecodeToString method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='bytes'>A byte array.
    </param>
    <returns>A string consisting of the decoded text.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='enc'/>
       or
      <paramref name='bytes'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Encodings.DecodeToString(PeterO.Text.ICharacterEncoding,System.Byte[],System.Int32,System.Int32)">
<summary>Reads a portion of a byte array from a data source and converts the bytes
      from a given encoding to a text string. Errors in decoding are handled by
      replacing erroneous bytes with the replacement character (U+FFFD).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>enc.DecodeToString(bytes, offset, length)</c> . If the object's class already has a DecodeToString method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='bytes'>A byte array containing the desired portion to read.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='bytes'/>
       begins.
    </param>
    <param name='length'>The length, in bytes, of the desired portion of
      <paramref name='bytes'/>
       (but not more than
      <paramref name='bytes'/>
       's length).
    </param>
    <returns>A string consisting of the decoded text.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.DecodeToString(PeterO.Text.ICharacterEncoding,System.IO.Stream)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.DecodeToString(input)</c> . If the object's class already has a DecodeToString method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='input'>A readable byte stream.
    </param>
    <returns>A string consisting of the decoded text.
    </returns>
    <exception cref='ArgumentNullException'>The parameter "encoding" or
      <paramref name='input'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Encodings.DecoderToInputClass.Read(System.Int32[],System.Int32,System.Int32)">
<summary>This is an internal method.
    </summary>
    <param name='buffer'>An array of 32-bit unsigned integers.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='buffer'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='buffer'/>
       (but not more than
      <paramref name='buffer'/>
       's length).
    </param>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='buffer'/>
       's length, or
      <paramref name='buffer'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Text.Encodings.DecoderToInputClass.ReadChar">
<summary>This is an internal method.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToBytes(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoder)">
<summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded using a given character encoding. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoder)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoder'>An object that implements a character encoder.
    </param>
    <returns>A byte array.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='encoder'/>
       or
      <paramref name='input'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToBytes(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoding)">
<summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded using the given character encoder. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoding)</c> . If the object's class already has an EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoding'>An object that implements a given character encoding.
    </param>
    <returns>A byte array containing the encoded text.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='encoding'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToBytes(System.String,PeterO.Text.ICharacterEncoding)">
<summary>Reads Unicode characters from a text string and writes them to a byte
      array encoded in a given character encoding. When reading the string, any
      unpaired surrogate characters are replaced with the replacement character
      (U+FFFD), and when writing to the byte array, any characters that can't be
      encoded are replaced with the byte 0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.EncodeToBytes(enc)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <returns>A byte array.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='str'/>
       or
      <paramref name='enc'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToWriter(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoder,PeterO.IWriter)">
<summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded in a given character encoding. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoder)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoder'>An object that implements a character encoder.
    </param>
    <param name='writer'>A byte writer to write the encoded bytes to.
    </param>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToWriter(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoder,System.IO.Stream)">
<summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded in a given character encoding. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoder)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoder'>An object that implements a character encoder.
    </param>
    <param name='output'>A writable data stream.
    </param>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToWriter(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoding,PeterO.IWriter)">
<summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded using the given character encoder. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoding)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoding'>An object that implements a character encoding.
    </param>
    <param name='writer'>A byte writer to write the encoded bytes to.
    </param>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToWriter(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoding,System.IO.Stream)">
<summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded using the given character encoder. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoding)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoding'>An object that implements a character encoding.
    </param>
    <param name='output'>A writable data stream.
    </param>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToWriter(System.String,PeterO.Text.ICharacterEncoding,PeterO.IWriter)">
<summary>Converts a text string to bytes and writes the bytes to an output byte
      writer. When reading the string, any unpaired surrogate characters are
      replaced with the replacement character (U+FFFD), and when writing to the
      byte stream, any characters that can't be encoded are replaced with the
      byte 0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.EncodeToBytes(enc, writer)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>A text string to encode.
    </param>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='writer'>A byte writer where the encoded bytes will be written to.
    </param>
</doc>
<doc name="M:PeterO.Text.Encodings.EncodeToWriter(System.String,PeterO.Text.ICharacterEncoding,System.IO.Stream)">
<summary>Converts a text string to bytes and writes the bytes to an output data
      stream. When reading the string, any unpaired surrogate characters are
      replaced with the replacement character (U+FFFD), and when writing to the
      byte stream, any characters that can't be encoded are replaced with the
      byte 0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.EncodeToBytes(enc, writer)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>A text string to encode.
    </param>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='output'>A writable data stream.
    </param>
</doc>
<doc name="M:PeterO.Text.Encodings.GetDecoderInput(PeterO.Text.ICharacterEncoding,PeterO.IByteReader)">
<summary>Converts a character encoding into a character input stream, given a
      streamable source of bytes. The input stream doesn't check the first few
      bytes for a byte-order mark indicating a Unicode encoding such as UTF-8
      before using the character encoding's decoder.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows: "encoding.GetDecoderInput(input)". If the object's class
        already has a GetDecoderInput method with the same parameters, that
        method takes precedence over this extension method.
      </para>
    </summary>
    <param name='encoding'>Encoding that exposes a decoder to be converted into a character input
      stream. If the decoder returns -2 (indicating a decode error), the
      character input stream handles the error by returning a replacement
      character in its place.
    </param>
    <param name='stream'>Byte stream to convert into Unicode characters.
    </param>
    <returns>An ICharacterInput object.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.GetDecoderInput(PeterO.Text.ICharacterEncoding,System.IO.Stream)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.GetDecoderInput(input)</c> . If the object's class already has a GetDecoderInput method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='encoding'>Encoding object that exposes a decoder to be converted into a character
      input stream. If the decoder returns -2 (indicating a decode error), the
      character input stream handles the error by returning a replacement
      character in its place.
    </param>
    <param name='input'>Byte stream to convert into Unicode characters.
    </param>
    <returns>An ICharacterInput object.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.GetDecoderInputSkipBom(PeterO.Text.ICharacterEncoding,PeterO.IByteReader)">
<summary>Converts a character encoding into a character input stream, given a
      streamable source of bytes. But if the input stream starts with a UTF-8 or
      UTF-16 byte order mark, the input is decoded as UTF-8 or UTF-16, as the
      case may be, rather than the given character encoding.
      <para>This method implements the "decode" algorithm specified in the Encoding
        standard.
      </para>
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.GetDecoderInputSkipBom(input)</c> . If the object's class already has a
        <c>GetDecoderInputSkipBom</c> method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='encoding'>Encoding object that exposes a decoder to be converted into a character
      input stream. If the decoder returns -2 (indicating a decode error), the
      character input stream handles the error by returning a replacement
      character in its place.
    </param>
    <param name='stream'>Byte stream to convert into Unicode characters.
    </param>
    <returns>An ICharacterInput object.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.GetDecoderInputSkipBom(PeterO.Text.ICharacterEncoding,System.IO.Stream)">
<summary>Converts a character encoding into a character input stream, given a
      readable data stream. But if the input stream starts with a UTF-8 or
      UTF-16 byte order mark, the input is decoded as UTF-8 or UTF-16, as the
      case may be, rather than the given character encoding.This method
      implements the "decode" algorithm specified in the Encoding standard.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.GetDecoderInputSkipBom(input)</c> . If the object's class already has a
        <c>GetDecoderInputSkipBom</c> method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='encoding'>Encoding object that exposes a decoder to be converted into a character
      input stream. If the decoder returns -2 (indicating a decode error), the
      character input stream handles the error by returning a replacement
      character in its place.
    </param>
    <param name='input'>Byte stream to convert into Unicode characters.
    </param>
    <returns>An ICharacterInput object.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.GetEncoding(System.String)">
<summary>Returns a character encoding from the given name.
    </summary>
    <param name='name'>A string naming a character encoding. See the ResolveAlias method. Can be
      null.
    </param>
    <returns>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.GetEncoding(System.String,System.Boolean)">
<summary>Returns a character encoding from the given name.
    </summary>
    <param name='name'>A string naming a character encoding. See the ResolveAlias method. Can be
      null.
    </param>
    <param name='forEmail'>If false, uses the encoding resolution rules in the Encoding Standard. If
      true, uses modified rules as described in the ResolveAliasForEmail method.

    </param>
    <returns>An object that enables encoding and decoding text in the given character
      encoding. Returns null if the name is null or empty, or if it names an
      unrecognized or unsupported encoding.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.GetEncoding(System.String,System.Boolean,System.Boolean)">
<summary>Returns a character encoding from the given name.
    </summary>
    <param name='name'>A string naming a character encoding. See the ResolveAlias method. Can be
      null.
    </param>
    <param name='forEmail'>If false, uses the encoding resolution rules in the Encoding Standard. If
      true, uses modified rules as described in the ResolveAliasForEmail method.

    </param>
    <param name='allowReplacement'>Has no effect.
    </param>
    <returns>An object that enables encoding and decoding text in the given character
      encoding. Returns null if the name is null or empty, or if it names an
      unrecognized or unsupported encoding.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.InputToString(PeterO.Text.ICharacterInput)">
<summary>Reads Unicode characters from a character input and converts them to a
      text string.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>reader.InputToString()</c> . If the object's class already has a InputToString method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='reader'>A character input whose characters will be converted to a text string.
    </param>
    <returns>A text string containing the characters read.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.ResolveAlias(System.String)">
<summary>Resolves a character encoding's name to a standard form. This involves
      changing aliases of a character encoding to a standardized name.
      <para>In several Internet specifications, this name is known as a "charset"
        parameter. In HTML and HTTP, for example, the "charset" parameter
        indicates the encoding used to represent text in the HTML page, text
        file, etc.
      </para>
    </summary>
    <param name='name'>A string that names a given character encoding. Can be null. Any leading
      and trailing whitespace is removed and the name converted to lowercase
      before resolving the encoding's name. The Encoding Standard supports only
      the following encodings (and defines aliases for most of them).
      <list type='bullet'>
        <item><c>UTF-8</c> - UTF-8 (8-bit encoding of the universal coded character set, the
          encoding recommended by the Encoding Standard for new data formats)
        </item>
        <item><c>UTF-16LE</c> - UTF-16 little-endian (16-bit UCS)
        </item>
        <item><c>UTF-16BE</c> - UTF-16 big-endian (16-bit UCS)
        </item>
        <item>The special-purpose encoding
          <c>x-user-defined</c> </item>
        <item>The special-purpose encoding
          <c>replacement</c> .
        </item>
        <item>28 legacy single-byte encodings:
          <list type='bullet'>
            <item><c>windows-1252</c> : Western Europe (Note: The Encoding Standard aliases the names
              <c>US-ASCII</c> and
              <c>ISO-8859-1</c> to
              <c>windows-1252</c> , which uses a different coded character set from either; it
              differs from
              <c>ISO-8859-1</c> by assigning different characters to some bytes from 0x80 to
              0x9F. The Encoding Standard does this for compatibility with
              existing Web pages.)
            </item>
            <item><c>ISO-8859-2</c> ,
              <c>windows-1250</c> : Central Europe
            </item>
            <item><c>ISO-8859-10</c> : Northern Europe
            </item>
            <item><c>ISO-8859-4</c> ,
              <c>windows-1257</c> : Baltic
            </item>
            <item><c>ISO-8859-13</c> : Estonian
            </item>
            <item><c>ISO-8859-14</c> : Celtic
            </item>
            <item><c>ISO-8859-16</c> : Romanian
            </item>
            <item><c>ISO-8859-5</c> ,
              <c>IBM-866</c> ,
              <c>KOI8-R</c> ,
              <c>windows-1251</c> ,
              <c>x-mac-cyrillic</c> : Cyrillic
            </item>
            <item><c>KOI8-U</c> : Ukrainian
            </item>
            <item><c>ISO-8859-7</c> ,
              <c>windows-1253</c> : Greek
            </item>
            <item><c>ISO-8859-6</c> ,
              <c>windows-1256</c> : Arabic
            </item>
            <item><c>ISO-8859-8</c> ,
              <c>ISO-8859-8-I</c> ,
              <c>windows-1255</c> : Hebrew
            </item>
            <item><c>ISO-8859-3</c> : Latin 3
            </item>
            <item><c>ISO-8859-15</c> ,
              <c>windows-1254</c> : Turkish
            </item>
            <item><c>windows-874</c> : Thai
            </item>
            <item><c>windows-1258</c> : Vietnamese
            </item>
            <item><c>macintosh</c> : Mac Roman
            </item>
          </list>
        </item>
        <item>Three legacy Japanese encodings:
          <c>Shift_JIS</c> ,
          <c>EUC-JP</c> ,
          <c>ISO-2022-JP</c> </item>
        <item>Two legacy simplified Chinese encodings:
          <c>GBK</c> and
          <c>gb18030</c> </item>
        <item><c>Big5</c> : legacy traditional Chinese encoding
        </item>
        <item><c>EUC-KR</c> : legacy Korean encoding
        </item>
      </list>
      <para>The
        <c>UTF-8</c> ,
        <c>UTF-16LE</c> , and
        <c>UTF-16BE</c> encodings don't encode a byte-order mark at the start of the text
        (doing so is not recommended for
        <c>UTF-8</c> , while in
        <c>UTF-16LE</c> and
        <c>UTF-16BE</c> , the byte-order mark character U+FEFF is treated as an ordinary
        character, unlike in the UTF-16 encoding form). The Encoding Standard
        aliases
        <c>UTF-16</c> to
        <c>UTF-16LE</c> "to deal with deployed content".
      </para>
       .
    </param>
    <returns>A standardized name for the encoding. Returns the empty string if
      <paramref name='name'/>
       is null or empty, or if the encoding name is unsupported.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.ResolveAliasForEmail(System.String)">
<summary>Resolves a character encoding's name to a canonical form, using rules more
      suitable for email.
    </summary>
    <param name='name'>A string naming a character encoding. Can be null. Uses a modified version
      of the rules in the Encoding Standard to better conform, in some cases, to
      email standards like MIME. Encoding names and aliases not registered with
      the Internet Assigned Numbers Authority (IANA) are not supported, with the
      exception of
      <c>ascii</c> ,
      <c>utf8</c> ,
      <c>cp1252</c> , and names 10 characters or longer starting with
      <c>iso-8859-</c> . Also, the following additional encodings are supported.
      <list type='bullet'>
        <item><c>US-ASCII</c> - ASCII single-byte encoding, rather than an alias to
          <c>windows-1252</c> as specified in the Encoding Standard. The coded character set's code
          points match those in the Unicode Standard's Basic Latin block (0-127
          or U+0000 to U+007F). The name
          <c>ascii</c> is an alias.
        </item>
        <item><c>ISO-8859-1</c> - Latin-1 single-byte encoding, rather than an alias to
          <c>windows-1252</c> as specified in the Encoding Standard. The coded character set's code
          points match those in the Unicode Standard's Basic Latin and Latin-1
          Supplement blocks (0-255 or U+0000 to U+00FF).
        </item>
        <item><c>UTF-7</c> - UTF-7 (7-bit universal coded character set). The name
          <c>unicode-1-1-utf-7</c> is an alias to
          <c>UTF-7</c> , even though both encodings are defined in different RFCs (1642 and
          2152, respectively), and even though they are linked to Unicode
          versions with nonoverlapping character repertoires (1.1 and 2.0,
          respectively).
        </item>
      </list>
       . In previous versions of this method, the name
      <c>iso-2022-jp-2</c> was also aliased to
      <c>ISO-2022-JP</c> , which is no longer the case.
    </param>
    <returns>A standardized name for the encoding. Returns the empty string if
      <paramref name='name'/>
       is null or empty, or if the encoding name is unsupported.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.StringToBytes(PeterO.Text.ICharacterEncoder,System.String)">
<summary>Converts a text string to a byte array using the given character encoder.
      When reading the string, any unpaired surrogate characters are replaced
      with the replacement character (U+FFFD), and when writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoder and can be called as
        follows:
        <c>encoder.StringToBytes(str)</c> . If the object's class already has a StringToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='encoder'>An object that implements a character encoder.
    </param>
    <param name='str'>A text string to encode into a byte array.
    </param>
    <returns>A byte array.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='encoder'/>
       or
      <paramref name='str'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Encodings.StringToBytes(PeterO.Text.ICharacterEncoding,System.String)">
<summary>Converts a text string to a byte array encoded in a given character
      encoding. When reading the string, any unpaired surrogate characters are
      replaced with the replacement character (U+FFFD), and when writing to the
      byte array, any characters that can't be encoded are replaced with the
      byte 0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.StringToBytes(str)</c> . If the object's class already has a StringToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='encoding'>An object that implements a character encoding.
    </param>
    <param name='str'>A string to be encoded into a byte array.
    </param>
    <returns>A byte array containing the string encoded in the given text encoding.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.StringToInput(System.String)">
<summary>Converts a text string to a character input. The resulting input can then
      be used to encode the text to bytes, or to read the string code point by
      code point, among other things. When reading the string, any unpaired
      surrogate characters are replaced with the replacement character (U+FFFD).

      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.StringToInput(offset, length)</c> . If the object's class already has a StringToInput method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>An ICharacterInput object.
    </returns>
</doc>
<doc name="M:PeterO.Text.Encodings.StringToInput(System.String,System.Int32,System.Int32)">
<summary>Converts a portion of a text string to a character input. The resulting
      input can then be used to encode the text to bytes, or to read the string
      code point by code point, among other things. When reading the string, any
      unpaired surrogate characters are replaced with the replacement character
      (U+FFFD).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.StringToInput(offset, length)</c> . If the object's class already has a StringToInput method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <returns>An ICharacterInput object.
    </returns>
</doc>
<doc name="F:PeterO.Text.Encodings.UTF8">
<summary>Character encoding object for the UTF-8 character encoding, which
      represents each code point in the universal coded character set using 1 to
      4 bytes.
    </summary>
</doc>
<doc name="T:PeterO.Text.ICharacterDecoder">
<summary>Defines a method that can be implemented by classes that convert a stream
      of bytes to Unicode code points.
    </summary>
</doc>
<doc name="M:PeterO.Text.ICharacterDecoder.ReadChar(PeterO.IByteReader)">
<summary>Reads bytes from an input transform until a Unicode code point is decoded
      or until the end of the stream is reached.
      <para>If this method returns -2, indicating an error, the caller of this
        method can take one of a variety of actions to handle the error. For
        example, it can output one or more replacement code points instead (such
        as the Replacement Character 0xfffd), or it can throw an exception. In
        some cases, where the error won't cause data loss or a security problem,
        the caller can also ignore the decoder error.
      </para>
    </summary>
    <param name='input'>Source of bytes to decode into code points. The decoder can maintain
      internal state, including data on bytes already read, so this parameter
      should not change when using the same character decoder object. It's also
      possible for the decoder to read no bytes but still return a code point,
      depending on the encoding it supports and its internal state.
    </param>
    <returns>The Unicode code point decoded, from 0-0xd7ff or from 0xe000 to 0x10ffff.
      Returns -1 if the end of the source is reached or -2 if a decoder error
      occurs.
    </returns>
</doc>
<doc name="T:PeterO.Text.ICharacterEncoder">
<summary>Defines a method that can be implemented by classes that convert Unicode
      code points to bytes.
    </summary>
</doc>
<doc name="M:PeterO.Text.ICharacterEncoder.Encode(System.Int32,PeterO.IWriter)">
<summary>Converts a Unicode code point to bytes and writes the bytes to an output
      stream.
      <para>If this method returns -2, indicating an error, the caller of this
        method can take one of a variety of actions to handle the error. For
        example, it can write an escape sequence using the code point (such as
        the HTML error mode in the Encoding Standard), it can replace the code
        point with a "best fit" to that code point (which can consist of one or
        more bytes) and write the "best fit" instead, it can replace the code
        point with an arbitrary byte or sequence of bytes, or it can throw an
        exception. In some cases, where the error won't cause data loss or a
        security problem, the caller can also ignore the encoding error.
      </para>
    </summary>
    <param name='c'>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the stream.
    </param>
    <param name='output'>Output stream where the converted bytes will be written. The decoder can
      maintain internal state, including data on code points already passed as
      input, so this parameter should not change when using the same character
      encoder object.
    </param>
    <returns>The number of bytes written to the stream; -1 if no further code points
      remain (for example, if _c_ is -1 indicating the end of the stream), or -2
      if an encoding error occurs. (Note that it's possible for this method to
      return 0 if, for example, it can't generate new bytes yet based on the
      current input.). If this method returns -2, it should not write any bytes
      to the output stream.
    </returns>
</doc>
<doc name="T:PeterO.Text.ICharacterEncoding">
<summary>Defines methods that can be implemented by classes that convert to and
      from bytes and character code points.
    </summary>
</doc>
<doc name="M:PeterO.Text.ICharacterEncoding.GetDecoder">
<summary>Creates a decoder for this character encoding with initial state. If the
      decoder is stateless, multiple calls of this method can return the same
      decoder.
    </summary>
    <returns>A character decoder object.
    </returns>
</doc>
<doc name="M:PeterO.Text.ICharacterEncoding.GetEncoder">
<summary>Creates an encoder for this character encoding with initial state. If the
      encoder is stateless, multiple calls of this method can return the same
      encoder.
    </summary>
    <returns>A character encoder object.
    </returns>
</doc>
<doc name="T:PeterO.Text.ICharacterInput">
<summary>An interface for reading Unicode code points from a data source.
    </summary>
</doc>
<doc name="M:PeterO.Text.ICharacterInput.Read(System.Int32[],System.Int32,System.Int32)">
<summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
    <exception cref='ArgumentNullException'>Should be thrown if "chars" is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.ICharacterInput.ReadChar">
<summary>Reads a Unicode code point from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
</doc>
<doc name="T:PeterO.Text.Idna">
<summary><para>Contains methods that implement Internationalized Domain Names in
        Applications (IDNA). IDNA enables using a wider range of letters,
        numbers, and certain other characters in domain names. This class
        implements the 2008 revision of IDNA, also known as IDNA2008.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses two internal classes, called
        <c>NormalizationData</c> and
        <c>IdnaData</c> , that include data derived from the Unicode Character Database. See
        the documentation for the NormalizerInput class for the permission
        notice for the Unicode Character Database.
      </para>
    </summary>
</doc>
<doc name="M:PeterO.Text.Idna.EncodeDomainName(System.String)">
<summary>Tries to encode each label of a domain name into Punycode.
    </summary>
    <param name='value'>A domain name.
    </param>
    <returns>The domain name where each label with code points outside the Basic Latin
      range (U+0000 to U+007F) is encoded into Punycode. Labels where this is
      not possible remain unchanged.
    </returns>
    <exception cref='ArgumentNullException'>Value is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.Idna.IsValidDomainName(System.String,System.Boolean)">
<summary>Determines whether the given string is a syntactically valid domain name.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='lookupRules'>If true, uses rules to apply when looking up the string as a domain name.
      If false, uses rules to apply when registering the string as a domain
      name.
    </param>
    <returns><c>true</c> if the given string is a syntactically valid domain name; otherwise;
      false.
    </returns>
</doc>
<doc name="T:PeterO.Text.Normalization">
<summary>Represents a Unicode normalization form.
    </summary>
</doc>
<doc name="F:PeterO.Text.Normalization.NFC">
<summary>Normalization form C: canonical decomposition followed by canonical
      composition.
    </summary>
</doc>
<doc name="F:PeterO.Text.Normalization.NFD">
<summary>Normalization form D: canonical decomposition.
    </summary>
</doc>
<doc name="F:PeterO.Text.Normalization.NFKC">
<summary>Normalization form KC: compatibility decomposition followed by canonical
      composition.
    </summary>
</doc>
<doc name="F:PeterO.Text.Normalization.NFKD">
<summary>Normalization form KD: compatibility decomposition.
    </summary>
</doc>
<doc name="T:PeterO.Text.Normalizer">
<summary><para>Implements the Unicode normalization algorithm and contains methods and
        functionality to test and convert Unicode strings for Unicode
        normalization.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. See the documentation
        for the NormalizerInput class for the permission notice for the Unicode
        Character Database.
      </para>
    </summary>
</doc>
<doc name="M:PeterO.Text.Normalizer.#ctor(System.String,PeterO.Text.Normalization)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.Normalizer'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
</doc>
<doc name="M:PeterO.Text.Normalizer.IsNormalized(System.String,PeterO.Text.Normalization)">
<summary>Returns whether this string is normalized.
    </summary>
    <param name='str'>The string to check.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
    <returns><c>true</c> if this string is normalized; otherwise, <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
</doc>
<doc name="M:PeterO.Text.Normalizer.Normalize(System.String,PeterO.Text.Normalization)">
<summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
</doc>
<doc name="M:PeterO.Text.Normalizer.Read(System.Int32[],System.Int32,System.Int32)">
<summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>Index in the output buffer to start writing to.
    </param>
    <param name='length'>Maximum number of code points to write.
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
    <exception cref='ArgumentException'>Either
      <paramref name='index'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='chars'/>
       's length, or
      <paramref name='chars'/>
       ' s length minus
      <paramref name='index'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Text.Normalizer.ReadChar">
<summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
</doc>
<doc name="T:PeterO.Text.NormalizerInput">
<summary><para>A character input class that implements the Unicode normalization
        algorithm and contains methods and functionality to test and convert
        text strings for normalization. This is similar to the deprecated
        Normalizer class, except it implements the ICharacterInput interface.
      </para>
      <para>The Unicode Standard includes characters, such as an acute accent, that
        can be combined with other characters to make new characters. For
        example, the letter E combines with an acute accent to make E-acute (É).
        In some cases, the combined form (E-acute) should be treated as
        equivalent to the uncombined form (E plus acute). Therefore, the
        standard defines four
        <i>
           normalization forms
        </i>
         that convert strings to a single equivalent form:
      </para>
      <list>
        <item><b>NFD</b> (Normalization Form D) decomposes combined forms to their constituent
          characters (E plus acute, for example). This is called canonical
          decomposition.
        </item>
        <item><b>NFC</b> does canonical decomposition, then combines certain constituent
          characters to their composites (E-acute, for example). This is called
          canonical composition.
        </item>
        <item>Two normalization forms,
          <b>NFKC</b> and
          <b>NFKD</b> , are similar to NFC and NFD, except they also "decompose" certain
          characters, such as ligatures, font or positional variants, and
          subscripts, whose visual distinction can matter in some contexts. This
          is called compatibility decomposition.
        </item>
        <item>The four normalization forms also enforce a standardized order for
          combining marks, since they can otherwise appear in an arbitrary
          order.
        </item>
      </list>
      <para>For more information, see Standard Annex 15 at
        <c>http://www.unicode.org/reports/tr15/</c> .
      </para>
      <para><b>Thread safety:</b> This class is mutable; its properties can be changed. None of its
        instance methods are designed to be thread safe. Therefore, access to
        objects from this class must be synchronized if multiple threads can
        access them at the same time.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. In case doing so is
        required, the permission notice for the Unicode Character Database is
        given here:
      </para>
      <para>COPYRIGHT AND PERMISSION NOTICE
      </para>
      <para>Copyright (c) 1991-2014 Unicode, Inc. All rights reserved. Distributed
        under the Terms of Use in http://www.unicode.org/copyright.html.
      </para>
      <para>Permission is hereby granted, free of charge, to any person obtaining a
        copy of the Unicode data files and any associated documentation (the
        "Data Files") or Unicode software and any associated documentation (the
        "Software") to deal in the Data Files or Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, and/or sell copies of the Data Files or Software,
        and to permit persons to whom the Data Files or Software are furnished
        to do so, provided that (a) this copyright and permission notice appear
        with all copies of the Data Files or Software, (b) this copyright and
        permission notice appear in associated documentation, and (c) there is
        clear notice in each modified Data File or in the Software as well as in
        the documentation associated with the Data File(s) or Software that the
        data or software has been modified.
      </para>
      <para>THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
        ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT
        HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR
        ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
        RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
        CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
        CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.
      </para>
      <para>Except as contained in this notice, the name of a copyright holder shall
        not be used in advertising or otherwise to promote the sale, use or
        other dealings in these Data Files or Software without prior written
        authorization of the copyright holder.
      </para>
    </summary>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(PeterO.Text.ICharacterInput)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class using Normalization Form C.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is an ICharacterInput object.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is an ICharacterInput object.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(System.String)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class using Normalization Form C.
    </summary>
    <param name='str'>A string specifying the text to normalize.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(System.String,PeterO.Text.Normalization)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.#ctor(System.String,System.Int32,System.Int32,PeterO.Text.Normalization)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizerInput'/>
       class. Uses a portion of a string as the input.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.IsNormalized(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">
<summary>Determines whether the text provided by a character input is normalized.
    </summary>
    <param name='chars'>A object that implements a streamable character input.
    </param>
    <param name='form'>Specifies the normalization form to check.
    </param>
    <returns><c>true</c> if the text is normalized; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.IsNormalized(System.String,PeterO.Text.Normalization)">
<summary>Determines whether the given string is in the given Unicode normalization
      form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given string is in the given Unicode normalization form; otherwise, <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.Normalize(System.String,PeterO.Text.Normalization)">
<summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
    <exception cref='ArgumentException'>The parameter
      <paramref name='str'/>
       contains an unpaired surrogate code point.
    </exception>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.Read(System.Int32[],System.Int32,System.Int32)">
<summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizerInput.ReadChar">
<summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
</doc>
<doc name="T:PeterO.Text.NormalizingCharacterInput">
<summary><para>A character input class that implements the Unicode normalization
        algorithm and contains methods and functionality to test and convert
        text strings for normalization. This is similar to the deprecated
        Normalizer class, except it implements the ICharacterInput interface.
      </para>
      <para>The Unicode Standard includes characters, such as an acute accent, that
        can be combined with other characters to make new characters. For
        example, the letter E combines with an acute accent to make E-acute (É).
        In some cases, the combined form (E-acute) should be treated as
        equivalent to the uncombined form (E plus acute). Therefore, the
        standard defines four
        <i>
           normalization forms
        </i>
         that convert strings to a single equivalent form:
      </para>
      <list>
        <item><b>NFD</b> (Normalization Form D) decomposes combined forms to their constituent
          characters (E plus acute, for example). This is called canonical
          decomposition.
        </item>
        <item><b>NFC</b> does canonical decomposition, then combines certain constituent
          characters to their composites (E-acute, for example). This is called
          canonical composition.
        </item>
        <item>Two normalization forms,
          <b>NFKC</b> and
          <b>NFKD</b> , are similar to NFC and NFD, except they also "decompose" certain
          characters, such as ligatures, font or positional variants, and
          subscripts, whose visual distinction can matter in some contexts. This
          is called compatibility decomposition.
        </item>
        <item>The four normalization forms also enforce a standardized order for
          combining marks, since they can otherwise appear in an arbitrary
          order.
        </item>
      </list>
      <para>For more information, see Standard Annex 15 at
        <c>http://www.unicode.org/reports/tr15/</c> .
      </para>
      <para><b>Thread safety:</b> This class is mutable; its properties can be changed. None of its
        instance methods are designed to be thread safe. Therefore, access to
        objects from this class must be synchronized if multiple threads can
        access them at the same time.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. In case doing so is
        required, the permission notice for the Unicode Character Database is
        given here:
      </para>
      <para>COPYRIGHT AND PERMISSION NOTICE
      </para>
      <para>Copyright (c) 1991-2014 Unicode, Inc. All rights reserved. Distributed
        under the Terms of Use in http://www.unicode.org/copyright.html.
      </para>
      <para>Permission is hereby granted, free of charge, to any person obtaining a
        copy of the Unicode data files and any associated documentation (the
        "Data Files") or Unicode software and any associated documentation (the
        "Software") to deal in the Data Files or Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, and/or sell copies of the Data Files or Software,
        and to permit persons to whom the Data Files or Software are furnished
        to do so, provided that (a) this copyright and permission notice appear
        with all copies of the Data Files or Software, (b) this copyright and
        permission notice appear in associated documentation, and (c) there is
        clear notice in each modified Data File or in the Software as well as in
        the documentation associated with the Data File(s) or Software that the
        data or software has been modified.
      </para>
      <para>THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
        ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT
        HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR
        ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
        RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
        CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
        CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.
      </para>
      <para>Except as contained in this notice, the name of a copyright holder shall
        not be used in advertising or otherwise to promote the sale, use or
        other dealings in these Data Files or Software without prior written
        authorization of the copyright holder.
      </para>
    </summary>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(PeterO.Text.ICharacterInput)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is a public object.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is a public object.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.Collections.Generic.IList{System.Int32})">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='characterList'>The parameter
      <paramref name='characterList'/>
       is an IList object.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.Collections.Generic.IList{System.Int32},PeterO.Text.Normalization)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='characterList'>The parameter
      <paramref name='characterList'/>
       is a public object.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String,PeterO.Text.Normalization)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='str'/>
       or "input" or "charArray" is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String,System.Int32,System.Int32,PeterO.Text.Normalization)">
<summary>Initializes a new instance of the
      <see cref='PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a public object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='length'>The parameter
      <paramref name='length'/>
       is a 32-bit signed integer.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.GetChars(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">
<summary>Gets a list of normalized code points after reading from a character
      stream.
    </summary>
    <param name='chars'>An object that implements a stream of Unicode characters.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns>A list of the normalized Unicode characters.
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.GetChars(System.String,PeterO.Text.Normalization)">
<summary>Gets a list of normalized code points after reading from a string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns>A list of the normalized Unicode characters.
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.IsNormalized(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)">
<summary>Determines whether the text provided by a character input is normalized.
    </summary>
    <param name='chars'>A object that implements a streamable character input.
    </param>
    <param name='form'>Specifies the normalization form to check.
    </param>
    <returns><c>true</c> if the text is normalized; otherwise, <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.Collections.Generic.IList{System.Int32},PeterO.Text.Normalization)">
<summary>Determines whether the given list of characters is in the given Unicode
      normalization form.
    </summary>
    <param name='charList'>A list of Unicode code points.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given list of characters is in the given Unicode normalization
      form; otherwise, <c>false</c> .
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='charList'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.Int32[],PeterO.Text.Normalization)">
<summary>Determines whether the given array of characters is in the given Unicode
      normalization form.
    </summary>
    <param name='charArray'>An array of Unicode code points.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given list of characters is in the given Unicode normalization
      form; otherwise, <c>false</c> .
    </returns>
    <exception cref='ArgumentNullException'>The parameter "charList" is null.
    </exception>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.String,PeterO.Text.Normalization)">
<summary>Determines whether the given string is in the given Unicode normalization
      form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given string is in the given Unicode normalization form; otherwise, <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.Normalize(System.String,PeterO.Text.Normalization)">
<summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.Read(System.Int32[],System.Int32,System.Int32)">
<summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
</doc>
<doc name="M:PeterO.Text.NormalizingCharacterInput.ReadChar">
<summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
</doc>
<doc name="T:PeterO.TrapException">
<summary><para><b>This class is obsolete. It will be replaced by a new version of this
          class in a different namespace/package and library, called
          <c>PeterO.Numbers.ETrapException</c> in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c> </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.ETrapException</c> in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java).</b> </para>
       Exception thrown for arithmetic trap errors.
    </summary>
</doc>
<doc name="M:PeterO.TrapException.#ctor(System.Int32,PeterO.PrecisionContext,System.Object)">
<summary>Initializes a new instance of the
      <see cref='PeterO.TrapException'/>
       class.
    </summary>
    <param name='flag'>A flag that specifies the kind of error (PrecisionContext.FlagXXX). This
      will only be one flag, such as FlagInexact or FlagSubnormal.
    </param>
    <param name='ctx'>A context object for arbitrary-precision arithmetic settings.
    </param>
    <param name='result'>The desired result of the operation that caused the trap, such as an
      <c>ExtendedDecimal</c> or
      <c>ExtendedFloat</c> .
    </param>
</doc>
<doc name="P:PeterO.TrapException.Context">
<summary>Gets the precision context used during the operation that triggered the
      trap. May be null.
    </summary>
    <value>The precision context used during the operation that triggered the trap.
      May be null.
    </value>
</doc>
<doc name="P:PeterO.TrapException.Error">
<summary>Gets the flag that specifies the kind of error (PrecisionContext.FlagXXX).
      This will only be one flag, such as FlagInexact or FlagSubnormal.
    </summary>
    <value>The flag that specifies the kind of error (PrecisionContext.FlagXXX). This
      will only be one flag, such as FlagInexact or FlagSubnormal.
    </value>
</doc>
<doc name="P:PeterO.TrapException.Result">
<summary>Gets the defined result of the operation that caused the trap.
    </summary>
    <value>The defined result of the operation that caused the trap.
    </value>
</doc>
<doc name="T:PeterO.Util">
<summary>Not documented yet.
    </summary>
</doc>
<doc name="M:PeterO.Util.AddIfMissing``1(System.Collections.Generic.IList{``0},``0)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>dict.AddIfMissing&lt;T&gt;(value)</c> . If the object's class already has a AddIfMissing&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='dict'>The parameter
      <paramref name='dict'/>
       is an IList object.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='dict'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Util.AddIfMissing``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IDictionary and can be called as
        follows:
        <c>dict.AddIfMissing&lt;TKey, TValue&gt;(key, value)</c> . If the object's class already has a AddIfMissing&lt;TKey, TValue&gt;
        method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='dict'>The parameter
      <paramref name='dict'/>
       is an IDictionary object.
    </param>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a TKey object.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a TValue object.
    </param>
    <typeparam name='TKey'>Object type for keys.
    </typeparam>
    <typeparam name='TValue'>Object type for values.
    </typeparam>
</doc>
<doc name="M:PeterO.Util.AddOverwrite``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IDictionary and can be called as
        follows:
        <c>dict.AddOverwrite&lt;TKey, TValue&gt;(key, value)</c> . If the object's class already has a AddOverwrite&lt;TKey, TValue&gt;
        method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='dict'>The parameter
      <paramref name='dict'/>
       is an IDictionary object.
    </param>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a TKey object.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a TValue object.
    </param>
    <typeparam name='TKey'>Type parameter not documented yet.
    </typeparam>
</doc>
<doc name="M:PeterO.Util.AllSame``1(System.Collections.Generic.IEnumerable{``0})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>col.AllSame&lt;T&gt;()</c> . If the object's class already has a AllSame&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='col'>The parameter
      <paramref name='col'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='col'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Util.AllSame``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>containers.AllSame&lt;TContainer, TItem&gt;(func)</c> . If the object's class already has a AllSame&lt;TContainer, TItem&gt;
        method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='containers'>The parameter
      <paramref name='containers'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Func object.
    </param>
    <typeparam name='TContainer'>Object type representing containers of items. Can also be the same type as
      TItem.
    </typeparam>
    <typeparam name='TItem'>Object type representing items stored in each container.
    </typeparam>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='containers'/>
       or
      <paramref name='func'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Util.ArrayToString``1(System.Collections.Generic.IEnumerable{``0})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>array.ArrayToString&lt;T&gt;()</c> . If the object's class already has a ArrayToString&lt;T&gt; method
        with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A text string.
    </returns>
</doc>
<doc name="M:PeterO.Util.CopyStream(System.IO.Stream,System.IO.Stream)">
<summary>Copies all bytes from one stream to another.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Stream and can be called as follows:
        <c>input.CopyStream(output)</c> . If the object's class already has a CopyStream method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is a Stream object.
    </param>
    <param name='output'>The parameter
      <paramref name='output'/>
       is a Stream object.
    </param>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='input'/>
       or
      <paramref name='output'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Util.CopyStream(System.IO.Stream,System.Int32,System.IO.Stream)">
<summary>Copies a certain number of bytes from one stream to another.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Stream and can be called as follows:
        <c>input.CopyStream(length, output)</c> . If the object's class already has a CopyStream method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is a Stream object.
    </param>
    <param name='length'>The parameter
      <paramref name='length'/>
       is a 32-bit signed integer.
    </param>
    <param name='output'>The parameter
      <paramref name='output'/>
       is a Stream object.
    </param>
</doc>
<doc name="M:PeterO.Util.CopyStructure``1(``0)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing T and can be called as follows:
        <c>structure.CopyStructure&lt;T&gt;()</c> . If the object's class already has a CopyStructure&lt;T&gt; method
        with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='structure'>The parameter
      <paramref name='structure'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='structure'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Util.EachWithIndex``1(System.Collections.Generic.IEnumerable{``0})">
<summary>Not documented yet.
    </summary>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>The return value'/&gt; is not documented yet.
    </returns>
    <remarks>
       Useful in queries where the index must be manipulated or returned by the
      query. For example:
      <code>from o in Util.EachWithIndex(objects) where IndexMeetsCriteria(o.Second)
        select o.First</code> .
    </remarks>
</doc>
<doc name="M:PeterO.Util.GetSegment``1(System.Collections.Generic.IList{``0},System.Int32)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.GetSegment&lt;T&gt;(start)</c> . If the object's class already has a GetSegment&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='start'>The parameter
      <paramref name='start'/>
       is a 32-bit signed integer.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A ListSegment(T) object.
    </returns>
</doc>
<doc name="M:PeterO.Util.GetSegment``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.GetSegment&lt;T&gt;(start, count)</c> . If the object's class already has a GetSegment&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='start'>The parameter
      <paramref name='start'/>
       is a 32-bit signed integer.
    </param>
    <param name='count'>The parameter
      <paramref name='count'/>
       is a 32-bit signed integer.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
    <returns>A ListSegment(T) object.
    </returns>
</doc>
<doc name="M:PeterO.Util.HasUnique``1(System.Collections.Generic.IEnumerable{``0})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>col.HasUnique&lt;T&gt;()</c> . If the object's class already has a HasUnique&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='col'>The parameter
      <paramref name='col'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Util.HasUnique``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>containers.HasUnique&lt;TContainer, TItem&gt;(func)</c> . If the object's class already has a HasUnique&lt;TContainer,
        TItem&gt; method with the same parameters, that method takes precedence
        over this extension method.
      </para>
    </summary>
    <param name='containers'>The parameter
      <paramref name='containers'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Func object.
    </param>
    <typeparam name='TContainer'>Object type representing containers of items. Can also be the same type as
      TItem.
    </typeparam>
    <typeparam name='TItem'>Object type representing items stored in each container.
    </typeparam>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.Util.Implode``1(System.Collections.Generic.IEnumerable{``0},System.String)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>col.Implode&lt;T&gt;(separator)</c> . If the object's class already has a Implode&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='col'>The parameter
      <paramref name='col'/>
       is an IEnumerable object.
    </param>
    <param name='separator'>The parameter
      <paramref name='separator'/>
       is a text string.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A text string.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='col'/>
       or
      <paramref name='separator'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Util.IndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.IndexOf&lt;T&gt;(match)</c> . If the object's class already has a IndexOf&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='match'>The parameter
      <paramref name='match'/>
       is a Predicate object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='list'/>
       or
      <paramref name='match'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Util.IndexOf``1(System.Collections.Generic.IList{``0},``0)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.IndexOf&lt;T&gt;(obj)</c> . If the object's class already has a IndexOf&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Util.MakeList``1(``0[])">
<summary>Not documented yet.
    </summary>
    <param name='items'>The parameter
      <paramref name='items'/>
       is a params object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>An IList(T) object.
    </returns>
</doc>
<doc name="M:PeterO.Util.MakePair``2(``0,``1)">
<summary>Not documented yet.
    </summary>
    <param name='f'>The parameter
      <paramref name='f'/>
       is a TFirst object.
    </param>
    <param name='s'>The parameter
      <paramref name='s'/>
       is a TSecond object.
    </param>
    <typeparam name='TFirst'>Any object type.
    </typeparam>
    <typeparam name='TSecond'>Any object type.
    </typeparam>
    <returns>A Pair(TFirst, TSecond) object.
    </returns>
</doc>
<doc name="M:PeterO.Util.MaxOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>coll.MaxOrDefault&lt;T&gt;()</c> . If the object's class already has a MaxOrDefault&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='coll'>The parameter
      <paramref name='coll'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Any object type that implements IComparable&lt;T&gt;.
    </typeparam>
    <returns>A T object.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='coll'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.Util.MinOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>coll.MinOrDefault&lt;T&gt;()</c> . If the object's class already has a MinOrDefault&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='coll'>The parameter
      <paramref name='coll'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
</doc>
<doc name="F:PeterO.Util.NullDisposable">
<summary>An IDisposable object that does nothing when disposed.
    </summary>
</doc>
<doc name="M:PeterO.Util.NullDisposableClass.Dispose">
<summary>Not documented yet.
    </summary>
</doc>
<doc name="M:PeterO.Util.RemoveAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.RemoveAll&lt;T&gt;(match)</c> . If the object's class already has a RemoveAll&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='match'>The parameter
      <paramref name='match'/>
       is a Predicate object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Util.SetIfMissing``1(System.Collections.Generic.IList{``0},System.Int32,System.Func{``0})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.SetIfMissing&lt;T&gt;(index, valuefunc)</c> . If the object's class already has a SetIfMissing&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='valuefunc'>The parameter
      <paramref name='valuefunc'/>
       is a Func object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
</doc>
<doc name="M:PeterO.Util.SetIfMissing``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.SetIfMissing&lt;T&gt;(index, value)</c> . If the object's class already has a SetIfMissing&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
</doc>
<doc name="M:PeterO.Util.SetNewIfMissing``1(System.Collections.Generic.IList{``0},System.Int32)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.SetNewIfMissing&lt;T&gt;(index)</c> . If the object's class already has a SetNewIfMissing&lt;T&gt; method
        with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
</doc>
<doc name="M:PeterO.Util.SetValue``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.SetValue&lt;T&gt;(index, value)</c> . If the object's class already has a SetValue&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
</doc>
<doc name="M:PeterO.Util.StructureSize(PeterO.IStructure)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IStructure and can be called as
        follows:
        <c>s.StructureSize()</c> . If the object's class already has a StructureSize method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='s'>The parameter
      <paramref name='s'/>
       is an IStructure object.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Util.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>containers.Sum&lt;T&gt;(func)</c> . If the object's class already has a Sum&lt;T&gt; method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='containers'>The parameter
      <paramref name='containers'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Func object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
</doc>
<doc name="M:PeterO.Util.Transform``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>containers.Transform&lt;TInput, TOutput&gt;(func)</c> . If the object's class already has a Transform&lt;TInput, TOutput&gt;
        method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='containers'>The parameter
      <paramref name='containers'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Func object.
    </param>
    <typeparam name='TOutput'>Output type.
    </typeparam>
    <returns>An IEnumerable(TOutput) object.
    </returns>
</doc>
<doc name="M:PeterO.Util.UpToExcluding(System.Int32,System.Int32)">
<summary>Creates an iterator of integers starting at a minimum value and ending at
      one less than the maximum.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Int32 and can be called as follows:
        <c>minValue.UpToExcluding(maxValue)</c> . If the object's class already has a UpToExcluding method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='minValue'>The parameter
      <paramref name='minValue'/>
       is a 32-bit signed integer.
    </param>
    <param name='maxValue'>The parameter
      <paramref name='maxValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>An IEnumerable(int) object.
    </returns>
    <exception cref='ArgumentException'>The parameter _minValue_ is greater than _maxValue_.
    </exception>
</doc>
<doc name="M:PeterO.Util.UpToIncluding(System.Int32,System.Int32)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Int32 and can be called as follows:
        <c>minValue.UpToIncluding(maxValue)</c> . If the object's class already has a UpToIncluding method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='minValue'>The parameter
      <paramref name='minValue'/>
       is a 32-bit signed integer.
    </param>
    <param name='maxValue'>The parameter
      <paramref name='maxValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>An IEnumerable(int) object.
    </returns>
</doc>
<doc name="M:PeterO.Util.ValueOrDefault``1(System.Collections.Generic.IList{``0},System.Int32)">
<summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.ValueOrDefault&lt;T&gt;(index)</c> . If the object's class already has a ValueOrDefault&lt;T&gt; method
        with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
</doc>
<doc name="T:PeterO.XEReader">
<summary>Not documented yet.
    </summary>
</doc>
<doc name="M:PeterO.XEReader.Create(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <returns>A XEReader object.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='file'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.XEReader.Create(System.Xml.XmlReader)">
<summary>Not documented yet.
    </summary>
    <param name='reader'>The parameter
      <paramref name='reader'/>
       is a XmlReader object.
    </param>
    <returns>A XEReader object.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='reader'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.XEReader.Current">
<summary>Not documented yet.
    </summary>
    <returns>A XEReader object.
    </returns>
</doc>
<doc name="M:PeterO.XEReader.Dispose">
<summary>Not documented yet.
    </summary>
</doc>
<doc name="M:PeterO.XEReader.IsElement(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.XEReader.IsElement(System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='namespaceName'>The parameter
      <paramref name='namespaceName'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
    <exception cref='InvalidOperationException'>This element's content was already read or being read.
    </exception>
</doc>
<doc name="P:PeterO.XEReader.IsEmptyElement">
<summary>Gets a value indicating whether the currently read element is found to be
      empty.
    </summary>
    <value><c>true</c> If the currently read element is found to be empty; otherwise, <c>false</c> .
    </value>
    <returns>A text string.
    </returns>
</doc>
<doc name="P:PeterO.XEReader.Item(System.String)">
<summary>Gets an attribute from the currently read element.
    </summary>
    <param name='attribute'>The parameter
      <paramref name='attribute'/>
       is a text string.
    </param>
    <returns>A text string.
    </returns>
</doc>
<doc name="P:PeterO.XEReader.LocalName">
<summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
</doc>
<doc name="M:PeterO.XEReader.MoveNext">
<summary>Not documented yet.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.XEReader.MoveNext(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="M:PeterO.XEReader.MoveNext(System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='namespaceName'>The parameter
      <paramref name='namespaceName'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
</doc>
<doc name="P:PeterO.XEReader.Name">
<summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
</doc>
<doc name="P:PeterO.XEReader.NamespaceName">
<summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
</doc>
<doc name="M:PeterO.XEReader.ReadContent">
<summary>Not documented yet.
    </summary>
    <returns>A text string.
    </returns>
</doc>
<doc name="T:PeterO.XEWriter">
<summary>Not documented yet.
    </summary>
</doc>
<doc name="M:PeterO.XEWriter.AddAttribute(System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.XEWriter.AddAttribute(System.String,System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.XEWriter.AddComment(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.XEWriter.AddContent(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.XEWriter.AddElement(System.String)">
<summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
</doc>
<doc name="M:PeterO.XEWriter.AddElement(System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
</doc>
<doc name="M:PeterO.XEWriter.AddSimpleElement(System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.XEWriter.AddSimpleElement(System.String,System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
</doc>
<doc name="M:PeterO.XEWriter.Create(System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
</doc>
<doc name="M:PeterO.XEWriter.Create(System.String,System.String,System.Boolean)">
<summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='indent'>The parameter
      <paramref name='indent'/>
       is either
      <c>true</c> or
      <c>false</c> .
    </param>
    <returns>A XEWriter object.
    </returns>
</doc>
<doc name="M:PeterO.XEWriter.Create(System.String,System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
</doc>
<doc name="M:PeterO.XEWriter.Create(System.String,System.String,System.String,System.Boolean)">
<summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <param name='indent'>The parameter
      <paramref name='indent'/>
       is either
      <c>true</c> or
      <c>false</c> .
    </param>
    <returns>A XEWriter object.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='file'/>
       or
      <paramref name='localName'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.XEWriter.Create(System.Xml.XmlWriter,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='writer'>The parameter
      <paramref name='writer'/>
       is a XmlWriter object.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
</doc>
<doc name="M:PeterO.XEWriter.Create(System.Xml.XmlWriter,System.String,System.String)">
<summary>Not documented yet.
    </summary>
    <param name='writer'>The parameter
      <paramref name='writer'/>
       is a XmlWriter object.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
    <exception cref='ArgumentNullException'>The parameter
      <paramref name='writer'/>
       or
      <paramref name='localName'/>
       is null.
    </exception>
</doc>
<doc name="M:PeterO.XEWriter.Dispose">
<summary>Not documented yet.
    </summary>
</doc>
</docs>
