<docs>
  <doc name='T:PeterO.ArrayUtil'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayHashCode(System.Collections.Generic.IEnumerable{System.Byte})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is not documented yet.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayHashCode(System.Collections.Generic.IEnumerable{System.Double})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is not documented yet.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayHashCode(System.Collections.Generic.IEnumerable{System.Int32})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is not documented yet.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayHashCode(System.Collections.Generic.IEnumerable{System.Single})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is not documented yet.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayHashCode``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayToStringHex(System.Collections.Generic.IEnumerable{System.Byte})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is not documented yet.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayToStringHex(System.Collections.Generic.IEnumerable{System.Int32})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is not documented yet.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayToStringHex``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArrayToString``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArraysEqual(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})'>
    <summary>Not documented yet.
    </summary>
    <param name='array1'>The parameter
      <paramref name='array1'/>
       is not documented yet.
    </param>
    <param name='array2'>The parameter
      <paramref name='array2'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArraysEqual(System.Collections.Generic.IEnumerable{System.Single},System.Collections.Generic.IEnumerable{System.Single})'>
    <summary>Not documented yet.
    </summary>
    <param name='array1'>The parameter
      <paramref name='array1'/>
       is not documented yet.
    </param>
    <param name='array2'>The parameter
      <paramref name='array2'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArraysEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})'>
    <summary>Determines whether two enumerable objects are equal.
    </summary>
    <param name='array1'>First enumerable to compare.
    </param>
    <param name='array2'>Second enumerable to compare.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
    <returns><c>true</c> if both enumerable objects are null or both enumerable objects have the
      same elements and number of elements in the same order; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ArraysEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})'>
    <summary>Determines whether two enumerable objects are equal.
    </summary>
    <param name='array1'>First enumerable to compare.
    </param>
    <param name='array2'>Second enumerable to compare.
    </param>
    <param name='comparer'>Equality comparer for comparing each element in the enumerable objects.
    </param>
    <typeparam name='T'>Not documented yet.
    </typeparam>
    <returns><c>true</c> if both enumerable objects are null or both enumerable objects have the
      same elements and number of elements in the same order; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='comparer'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayUtil.CompareArrays``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
    </summary>
    <param name='array1'>The parameter
      <paramref name='array1'/>
       is an IEnumerable object.
    </param>
    <param name='array2'>The parameter
      <paramref name='array2'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.CompareArrays``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})'>
    <summary>Not documented yet.
    </summary>
    <param name='array1'>The parameter
      <paramref name='array1'/>
       is an IEnumerable object.
    </param>
    <param name='array2'>The parameter
      <paramref name='array2'/>
       is an IEnumerable object.
    </param>
    <param name='comparer'>The parameter
      <paramref name='comparer'/>
       is an IComparer object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayUtil.CompareLists``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})'>
    <summary>Compares two lists with the same type of items.
    </summary>
    <param name='list1'>The first list to compare. Can be null.
    </param>
    <param name='list2'>The second list of compare. Can be null.
    </param>
    <typeparam name='T'>Not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
    <example><para>The examples below will clarify the comparison rules used in this
        method. In the examples below, this method would return -1 if it were
        passed the following pairs of lists, since list 1 is less than list 2:
      </para>
      <para>list1 = {0, 2, 5, 1}
      </para>
      <para>list2 = {2, 2, 5, 1}
      </para>
      <para>list1 = {0, 2, 5, 3}
      </para>
      <para>list2 = {0, 2, 7, 1}
      </para>
      <para>list1 = {0, 2, 5, 3, 0, 5, 6}
      </para>
      <para>list2 = {0, 2, 7, 1}
      </para>
      <para>list1 = null
      </para>
      <para>list2 = {0}
      </para>
      <para>list1 = {0, 2, 5}
      </para>
      <para>list2 = {0, 2, 5, 0}
      </para>
      <para>If instead, list1 and list2 were switched, the method would return 1,
        since list1 is now greater than list2.
      </para>
    </example>
  </doc>
  <doc name='M:PeterO.ArrayUtil.CompareLists``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})'>
    <summary>Compares two lists with the same type of items.
    </summary>
    <param name='list1'>The first list to compare. Can be null.
    </param>
    <param name='list2'>The second list of compare. Can be null.
    </param>
    <param name='comparer'>The parameter
      <paramref name='comparer'/>
       is an IComparer object.
    </param>
    <typeparam name='T'>Not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
    <example>See CompareLists(IList, IList) for an example of the comparison rules.
    </example>
  </doc>
  <doc name='M:PeterO.ArrayUtil.FindItem``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},``0)'>
    <summary>Not documented yet.
    </summary>
    <param name='items'>The parameter
      <paramref name='items'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Predicate object.
    </param>
    <param name='defaultValue'>The parameter
      <paramref name='defaultValue'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='items'/>
       or
      <paramref name='func'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayUtil.FindItem``1(System.Collections.Generic.IEnumerable{``0},``0,``0)'>
    <summary>Finds an item or returns a default value if an item is not found.
    </summary>
    <param name='items'>The parameter
      <paramref name='items'/>
       is an IEnumerable object.
    </param>
    <param name='itemToFind'>An item to compare with each item in the list.
    </param>
    <param name='defaultValue'>This value is returned if _itemToFind_ is not found.
    </param>
    <typeparam name='T'>Not documented yet.
    </typeparam>
    <returns>The item within the list that equals _itemToFind_, or _defaultValue_ if
      the item is not found.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='items'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayUtil.Reverse``1(System.Collections.Generic.IList{``0})'>
    <summary>Reverses the order of the elements in the given list.
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
    <exception cref='T:System.ArgumentNullException'>The parameter "array" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayUtil.Reverse``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)'>
    <summary>Reverses the order of the elements in the given list at the specified
      index and length.
    </summary>
    <param name='list'>The list where the order of elements should be reversed.
    </param>
    <param name='index'>Starting index in the list.
    </param>
    <param name='count'>Number of elements in the list to reverse.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='list'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='index'/>
       or
      <paramref name='count'/>
       is less than 0 or greater than
      <paramref name='list'/>
       's length, or
      <paramref name='list'/>
       ' s length minus
      <paramref name='index'/>
       is less than
      <paramref name='count'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayUtil.Shuffle``1(System.Collections.Generic.IList{``0},System.Random)'>
    <summary>Randomizes the order of a list's items.
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='random'>The parameter
      <paramref name='random'/>
       is a Random object.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='random'/>
       or
      <paramref name='list'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayUtil.StableSort``1(System.Collections.Generic.IList{``0})'>
    <summary>Not documented yet.
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
  </doc>
  <doc name='M:PeterO.ArrayUtil.StableSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})'>
    <summary>Not documented yet.
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='comparer'>The parameter
      <paramref name='comparer'/>
       is an IComparer object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='list'/>
       or
      <paramref name='comparer'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayUtil.StableSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)'>
    <summary>Sorts an array of objects using a sorting method that preserves the order
      of equal elements.
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='list'/>
       begins.
    </param>
    <param name='count'>The number of elements in the desired portion of
      <paramref name='list'/>
       (but not more than
      <paramref name='list'/>
       's length).
    </param>
    <typeparam name=' T'>Type parameter not documented yet.
    </typeparam>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='count'/>
       is less than 0 or greater than
      <paramref name='list'/>
       's length, or
      <paramref name='list'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='count'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayUtil.StableSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})'>
    <summary>Sorts an array of objects using a sorting method that preserves the order
      of equal elements.
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='list'/>
       begins.
    </param>
    <param name='count'>The number of elements in the desired portion of
      <paramref name='list'/>
       (but not more than
      <paramref name='list'/>
       's length).
    </param>
    <param name='comparer'>The parameter
      <paramref name='comparer'/>
       is an IComparer object.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
  </doc>
  <doc name='M:PeterO.ArrayUtil.ToArray``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Converts an enumerable to an array.
    </summary>
    <param name='collection'>An enumerable converted to an array.
    </param>
    <typeparam name='T'>Not documented yet.
    </typeparam>
    <returns>An array generated from the specified enumerable. Note that the order of
      elements is not guaranteed if the enumerable does not implement IList.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter _collection_ is null.
    </exception>
  </doc>
  <doc name='T:PeterO.ArrayWriter'>
    <summary>An array of bytes that grows as needed.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.ArrayWriter'/>
       class with a default buffer size.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.#ctor(System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.ArrayWriter'/>
       class with the given initial buffer size.
    </summary>
    <param name='initialSize'>The parameter
      <paramref name='initialSize'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.ArrayWriter.Clear'>
    <summary>Offers a fast way to reset the length of the array writer's data to 0.
    </summary>
  </doc>
  <doc name='M:PeterO.ArrayWriter.ToArray'>
    <summary>Generates an array of all bytes written so far to it.
    </summary>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.ArrayWriter.Write(System.Byte[],System.Int32,System.Int32)'>
    <summary>Writes a series of bytes to the array.
    </summary>
    <param name='src'>Byte array containing the data to write.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='src'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='src'/>
       (but not more than
      <paramref name='src'/>
       's length).
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='src'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='src'/>
       's length, or
      <paramref name='src'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.ArrayWriter.WriteByte(System.Int32)'>
    <summary>Writes an 8-bit byte to the array.
    </summary>
    <param name='byteValue'>An integer containing the byte to write. Only the lower 8 bits of this
      value will be used.
    </param>
  </doc>
  <doc name='T:PeterO.BigInteger'>
    <summary><para><b>This class is largely obsolete. It will be replaced by a new version
          of this class in a different namespace/package and library, called
          <c>PeterO.Numbers.EInteger</c> in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c> </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.EInteger</c> in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java). This new class can be used in the
          <c>CBORObject.FromObject(object)</c> method (by including the new library in your code, among other
          things).</b> </para>
       An arbitrary-precision integer.
      <para><b>Thread safety:</b> Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        value are interchangeable, but they should be compared using the
        "Equals" method rather than the "==" operator.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.BigInteger.CompareTo(PeterO.BigInteger)'>
    <summary>Compares this value to another.
    </summary>
    <param name='other'>The parameter
      <paramref name='other'/>
       is an arbitrary-precision integer.
    </param>
    <returns>Less than 0 if this value is less than, 0 if equal to, or greater than 0
      if greater than the other value.
    </returns>
  </doc>
  <doc name='M:PeterO.BigInteger.Equals(PeterO.BigInteger)'>
    <summary>Returns whether this number's value equals another number's value.
    </summary>
    <param name='other'>An arbitrary-precision integer.
    </param>
    <returns><c>true</c> if this number's value equals another number's value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.BigInteger.Equals(System.Object)'>
    <inheritdoc/>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.BigInteger.GetHashCode'>
    <summary>Returns the hash code for this instance. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='F:PeterO.BigInteger.ONE'>
    <summary>BigInteger for the number one.
    </summary>
  </doc>
  <doc name='P:PeterO.BigInteger.One'>
    <summary>Gets the arbitrary-precision integer for one.
    </summary>
    <value>The arbitrary-precision integer for one.
    </value>
  </doc>
  <doc name='M:PeterO.BigInteger.ToString'>
    <summary>Converts this object to a text string in base 10.
    </summary>
    <returns>A string representation of this object. If negative, the string will begin
      with a minus sign ("-", U+002D). The string will use the basic digits 0 to
      9 (U+0030 to U+0039).
    </returns>
  </doc>
  <doc name='P:PeterO.BigInteger.Zero'>
    <summary>Gets the arbitrary-precision integer for zero.
    </summary>
    <value>The arbitrary-precision integer for zero.
    </value>
  </doc>
  <doc name='M:PeterO.BigInteger.bitLength'>
    <summary>Finds the minimum number of bits needed to represent this object's value,
      except for its sign. If the value is negative, finds the number of bits in
      a value equal to this object's absolute value minus 1.
    </summary>
    <returns>The number of bits in this object's value. Returns 0 if this object's
      value is 0 or negative 1.
    </returns>
  </doc>
  <doc name='M:PeterO.BigInteger.fromBytes(System.Byte[],System.Boolean)'>
    <summary>Initializes an arbitrary-precision integer from an array of bytes.
    </summary>
    <param name='bytes'>A byte array consisting of the two's-complement form of the
      arbitrary-precision integer to create. The last byte contains the lowest
      8-bits, the next-to-last contains the next lowest 8 bits, and so on. To
      encode negative numbers, take the absolute value of the number, subtract
      by 1, encode the number into bytes, XOR each byte, and if the
      most-significant bit of the first byte isn't set, add an additional byte
      at the start with the value 255. For little-endian, the byte order is
      reversed from the byte order just discussed.
    </param>
    <param name='littleEndian'>If true, the byte order is little-endian, or least-significant-byte first.
      If false, the byte order is big-endian, or most-significant-byte first.
    </param>
    <returns>An arbitrary-precision integer. Returns 0 if the byte array's length is 0.

    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.BigInteger.fromRadixString(System.String,System.Int32)'>
    <summary>Converts a string to an arbitrary-precision integer.
    </summary>
    <param name='str'>A text string. The string must contain only characters allowed by the
      given radix, except that it may start with a minus sign ("-", U+002D) to
      indicate a negative number. The string is not allowed to contain white
      space characters, including spaces.
    </param>
    <param name='radix'>A base from 2 to 36. Depending on the radix, the string can use the basic
      digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041
      to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </param>
    <returns>An arbitrary-precision integer with the same value as given in the string.

    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='radix'/>
       is less than 2 or greater than 36.
    </exception>
    <exception cref='T:System.FormatException'>The string is empty or in an invalid format.
    </exception>
  </doc>
  <doc name='M:PeterO.BigInteger.fromString(System.String)'>
    <summary>Converts a string to an arbitrary-precision integer.
    </summary>
    <param name='str'>A text string. The string must contain only basic digits 0 to 9 (U+0030 to
      U+0039), except that it may start with a minus sign ("-", U+002D) to
      indicate a negative number. The string is not allowed to contain white
      space characters, including spaces.
    </param>
    <returns>An arbitrary-precision integer with the same value as given in the string.

    </returns>
    <exception cref='T:System.FormatException'>The parameter
      <paramref name='str'/>
       is in an invalid format.
    </exception>
  </doc>
  <doc name='M:PeterO.BigInteger.toBytes(System.Boolean)'>
    <summary>Returns a byte array of this object's value. The byte array will take the
      form of the number's two' s-complement representation, using the fewest
      bytes necessary to represent its value unambiguously. If this value is
      negative, the bits that appear "before" the most significant bit of the
      number will be all ones.
    </summary>
    <param name='littleEndian'>If true, the least significant bits will appear first.
    </param>
    <returns>A byte array. If this value is 0, returns a byte array with the single
      element 0.
    </returns>
  </doc>
  <doc name='M:PeterO.BigInteger.toRadixString(System.Int32)'>
    <summary>Generates a string representing the value of this object, in the given
      radix.
    </summary>
    <param name='radix'>A radix from 2 through 36. For example, to generate a hexadecimal
      (base-16) string, specify 16. To generate a decimal (base-10) string,
      specify 10.
    </param>
    <returns>A string representing the value of this object. If this value is 0,
      returns "0". If negative, the string will begin with a hyphen/minus ("-").
      Depending on the radix, the string will use the basic digits 0 to 9
      (U+0030 to U+0039) and then the basic letters A to Z (U+0041 to U+005A).
      For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter "index" is less than 0, "endIndex" is less than 0, or either
      is greater than the string's length, or "endIndex" is less than "index" ;
      or radix is less than 2 or greater than 36.
    </exception>
  </doc>
  <doc name='M:PeterO.BigInteger.valueOf(System.Int64)'>
    <summary>Converts a 64-bit signed integer to a big integer.
    </summary>
    <param name='longerValue'>The parameter
      <paramref name='longerValue'/>
       is a 64-bit signed integer.
    </param>
    <returns>An arbitrary-precision integer with the same value as the 64-bit number.
    </returns>
  </doc>
  <doc name='T:PeterO.BinaryIO'>
    <summary>Reads and writes data types in little endian or big endian.
    </summary>
  </doc>
  <doc name='M:PeterO.BinaryIO.#ctor(System.IO.Stream)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.BinaryIO'/>
       class. Initializes a new BinaryIO instance.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is a Stream object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.BinaryIO.CanRead'>
    <summary>Gets a value indicating whether the underlying stream can be read.
    </summary>
    <value><c>true</c> If the underlying stream can be read; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.BinaryIO.CanSeek'>
    <summary>Gets a value indicating whether the underlying stream supports seeking.
    </summary>
    <value><c>true</c> If the underlying stream supports seeking; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.BinaryIO.CanWrite'>
    <summary>Gets a value indicating whether the underlying stream supports writing.
    </summary>
    <value><c>true</c> If the underlying stream supports writing; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.BinaryIO.Length'>
    <summary>Gets the length of the underlying stream.
    </summary>
    <value>The length of the underlying stream.
    </value>
  </doc>
  <doc name='P:PeterO.BinaryIO.Position'>
    <summary>Gets or sets the position of the underlying stream.
    </summary>
    <value>The position of the underlying stream.
    </value>
  </doc>
  <doc name='M:PeterO.BinaryIO.Read(System.Byte[],System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='data'>A byte array.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='data'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='data'/>
       (but not more than
      <paramref name='data'/>
       's length).
    </param>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='data'/>
       's length, or
      <paramref name='data'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.BinaryIO.Read7BitEncodedInt32BE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Read7BitEncodedInt32LE'>
    <summary>Reads a signed 32-bit integer encoded in 7-bit encoding to the stream.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
    <remarks>
       In 7-bit encoding, an integer is encoded in one or more bytes. Each byte
      contains 7 bits of the result, starting with the least-significant bits.
      If the eighth (highest) bit is 1, then the byte that follows it contains 7
      more bits, and so on. Otherwise, the process stops and the resulting
      integer is returned. The return value of this method can be up to 32 bits
      long. If bit 32 is 1, the return value is negative; otherwise positive.
    </remarks>
  </doc>
  <doc name='M:PeterO.BinaryIO.Read7BitEncodedInt64BE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Read7BitEncodedInt64LE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Read7BitEncodedUInt32BE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Read7BitEncodedUInt32LE'>
    <summary>Reads an unsigned 32-bit integer encoded in 7-bit encoding to the stream.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
    <remarks>
       In 7-bit encoding, an integer is encoded in one or more bytes. Each byte
      contains 7 bits of the result, starting with the least-significant bits.
      If the eighth (highest) bit is 1, then the byte that follows it contains 7
      more bits, and so on. Otherwise, the process stops and the resulting
      integer is returned. The return value of this method can be up to 31 bits
      long and is positive.
    </remarks>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadByte'>
    <summary>Not documented yet.
    </summary>
    <returns>A byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadBytes(System.Int32)'>
    <summary>Reads data from a stream into a byte array.
    </summary>
    <param name='size'>The parameter
      <paramref name='size'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte array containing the data read.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadDoubleBE'>
    <summary>Reads a 64-bit floating-point number in big-endian byte order.
    </summary>
    <returns>A 64-bit floating-point number.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadDoubleLE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 64-bit floating-point number.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadInt16BE'>
    <summary>Reads a 16-bit signed integer in big-endian byte order (2 bytes).
    </summary>
    <returns>A 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadInt16LE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadInt32BE'>
    <summary>Reads a 32-bit signed integer in big-endian byte order (4 bytes).
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadInt32LE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadInt64BE'>
    <summary>Reads a 64-bit signed integer in big-endian byte order (8 bytes).
    </summary>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadInt64LE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadSingleBE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit floating-point number.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.ReadSingleLE'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit floating-point number.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write(System.Byte)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a byte (from 0 to 255).
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write(System.Byte[])'>
    <summary>Not documented yet.
    </summary>
    <param name='data'>A byte array to write to the stream.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write(System.Byte[],System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='data'>A byte array. (2).
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='data'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='data'/>
       (but not more than
      <paramref name='data'/>
       's length).
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write7BitEncodedInt32BE(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write7BitEncodedInt32LE(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write7BitEncodedInt64BE(System.Int64)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write7BitEncodedInt64LE(System.Int64)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write7BitEncodedUInt32BE(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.Write7BitEncodedUInt32LE(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteBE(System.Byte)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a byte (from 0 to 255).
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteBE(System.Double)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit floating-point number.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteBE(System.Int16)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 16-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteBE(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteBE(System.Int64)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteBE(System.Single)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit floating-point number.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteLE(System.Byte)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a byte (from 0 to 255).
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteLE(System.Double)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit floating-point number.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteLE(System.Int16)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 16-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteLE(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteLE(System.Int64)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.BinaryIO.WriteLE(System.Single)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit floating-point number.
    </param>
  </doc>
  <doc name='T:PeterO.Cbor.CBORDataUtilities'>
    <summary>Contains methods useful for reading and writing data, with a focus on
      CBOR.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String)'>
    <summary>Parses a number whose format follows the JSON specification. See
      #ParseJSONNumber(String, integersOnly, parseOnly) for more information.
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)'>
    <summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)'>
    <summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary>
    <param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param>
    <param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param>
    <param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param>
    <param name='preserveNegativeZero'>If true, returns positive zero if the number is a zero that starts with a
      minus sign (such as "-0" or "-0.0"). Otherwise, returns negative zero in
      this case.
    </param>
    <returns>A CBOR object that represents the parsed number. Returns null if the
      parsing fails, including if the string is null or empty.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.CBOREncodeOptions'>
    <summary>Specifies options for encoding and decoding CBOR objects.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.#ctor(System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
       class.
    </summary>
    <param name='useIndefLengthStrings'>A value indicating whether to always encode strings with a definite-length
      encoding.
    </param>
    <param name='allowDuplicateKeys'>A value indicating whether to disallow duplicate keys when reading CBOR
      objects from a data stream.
    </param>
  </doc>
  <doc name='P:PeterO.Cbor.CBOREncodeOptions.AllowDuplicateKeys'>
    <summary>Gets a value indicating whether to disallow duplicate keys when reading
      CBOR objects from a data stream. Used only when decoding CBOR objects.
    </summary>
    <value>A value indicating whether to disallow duplicate keys when reading CBOR
      objects from a data stream.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.And(PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Returns an options object containing the flags shared by this and another
      options object.
    </summary>
    <param name='o'>The parameter
      <paramref name='o'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBOREncodeOptions object.
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.Default'>
    <summary>Default options for CBOR objects. Disallow duplicate keys, and always
      encode strings using definite-length encoding. These are recommended
      settings for the options that may be adopted by certain CBORObject methods
      in the next major version.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.NoDuplicateKeys'>
    <summary>Disallow duplicate keys when reading CBOR objects from a data stream. Used
      only when decoding CBOR objects. Value: 2.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.NoIndefLengthStrings'>
    <summary>Always encode strings with a definite-length encoding. Used only when
      encoding CBOR objects. Value: 1.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBOREncodeOptions.None'>
    <summary>No special options for encoding/decoding. Value: 0.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBOREncodeOptions.Or(PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Returns an options object containing the combined flags of this and
      another options object.
    </summary>
    <param name='o'>The parameter
      <paramref name='o'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A new CBOREncodeOptions object.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBOREncodeOptions.UseIndefLengthStrings'>
    <summary>Gets a value indicating whether to always encode strings with a
      definite-length encoding.
    </summary>
    <value>A value indicating whether to always encode strings with a definite-length
      encoding.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBOREncodeOptions.Value'>
    <summary>Gets this options object's value.
    </summary>
    <value>This options object's value.
    </value>
  </doc>
  <doc name='T:PeterO.Cbor.CBORException'>
    <summary>Exception thrown for errors involving CBOR data.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORException.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.CBORException'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORException.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.CBORException'/>
       class.
    </summary>
    <param name='message'>The parameter
      <paramref name='message'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORException.#ctor(System.String,System.Exception)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.CBORException'/>
       class. Uses the given message and inner exception.
    </summary>
    <param name='message'>The parameter
      <paramref name='message'/>
       is a text string.
    </param>
    <param name='innerException'>The parameter
      <paramref name='innerException'/>
       is an Exception object.
    </param>
  </doc>
  <doc name='T:PeterO.Cbor.CBORObject'>
    <summary>Represents an object in Concise Binary Object Representation (CBOR) and
      contains methods for reading and writing CBOR data. CBOR is defined in RFC
      7049.
      <para><b>Converting CBOR objects</b> </para>
      <para>There are many ways to get a CBOR object, including from bytes, objects,
        streams and JSON, as described below.
      </para>
      <para><b>To and from byte arrays:</b> The CBORObject.DecodeToBytes method converts a byte array in CBOR
        format to a CBOR object. The EncodeToBytes method converts a CBOR object
        to its corresponding byte array in CBOR format.
      </para>
      <para><b>To and from data streams:</b> The CBORObject.Write methods write many kinds of objects to a data
        stream, including numbers, CBOR objects, strings, and arrays of numbers
        and strings. The CBORObject.Read method reads a CBOR object from a data
        stream.
      </para>
      <para><b>To and from other objects:</b> The CBORObject.FromObject method converts many kinds of objects to a
        CBOR object, including numbers, strings, and arrays and maps of numbers
        and strings. Methods like AsDouble, AsByte, and AsString convert a CBOR
        object to different types of object.
      </para>
      <para><b>To and from JSON:</b> This class also doubles as a reader and writer of JavaScript Object
        Notation (JSON). The CBORObject.FromJSONString method converts JSON to a
        CBOR object, and the ToJSONString method converts a CBOR object to a
        JSON string.
      </para>
      <para>In addition, the CBORObject.WriteJSON method writes many kinds of
        objects as JSON to a data stream, including numbers, CBOR objects,
        strings, and arrays of numbers and strings. The CBORObject.Read method
        reads a CBOR object from a JSON data stream.
      </para>
      <para><b>Comparison Considerations:</b> </para>
      <para>Instances of CBORObject should not be compared for equality using the
        "==" operator; it's possible to create two CBOR objects with the same
        value but not the same reference. (The "==" operator might only check if
        each side of the operator is the same instance.)
      </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. This is important to consider especially if an
        application wants to compare numbers, since the CBOR number type
        supports numbers of different formats, such as big integers, rational
        numbers, and arbitrary-precision decimal numbers.
      </para>
      <para>Another consideration is that two values that are otherwise equal may
        have different tags. To strip the tags from a CBOR object before
        comparing, use the
        <c>Untag</c> method.
      </para>
      <para>To compare two numbers, the CompareToIgnoreTags or CompareTo method
        should be used. Which method to use depends on whether two equal values
        should still be considered equal if they have different tags.
      </para>
      <para>Although this class is inconsistent with the Equals method, it is safe
        to use CBORObject instances as hash keys as long as all of the keys are
        untagged text strings (which means GetTags returns an empty array and
        the Type property, or "getType()" in Java, returns TextString). This is
        because the natural ordering of these instances is consistent with the
        Equals method.
      </para>
      <para><b>Thread Safety:</b> </para>
      <para>CBOR objects that are numbers, "simple values", and text strings are
        immutable (their values can't be changed), so they are inherently safe
        for use by multiple threads.
      </para>
      <para>CBOR objects that are arrays, maps, and byte strings are mutable, but
        this class doesn't attempt to synchronize reads and writes to those
        objects by multiple threads, so those objects are not thread safe
        without such synchronization.
      </para>
      <para>One kind of CBOR object is called a map, or a list of key-value pairs.
        Keys can be any kind of CBOR object, including numbers, strings, arrays,
        and maps. However, text strings are the most suitable to use as keys;
        other kinds of CBOR object are much better used as map values instead,
        keeping in mind that some of them are not thread safe without
        synchronizing reads and writes to them.
      </para>
      <para>To find the type of a CBOR object, call its Type property (or
        "getType()" in Java). The return value can be Number, Boolean,
        SimpleValue, or TextString for immutable CBOR objects, and Array, Map,
        or ByteString for mutable CBOR objects.
      </para>
      <para><b>Nesting Depth:</b> </para>
      <para>The DecodeFromBytes and Read methods can only read objects with a
        limited maximum depth of arrays and maps nested within other arrays and
        maps. The code sets this maximum depth to 500 (allowing more than enough
        nesting for most purposes), but it's possible that stack overflows in
        some runtimes might lower the effective maximum nesting depth. When the
        nesting depth goes above 500, the DecodeFromBytes and Read methods throw
        a CBORException.
      </para>
      <para>The ReadJSON and FromJSONString methods currently have nesting depths of
        1000.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Abs'>
    <summary>Gets this object's absolute value.
    </summary>
    <returns>This object's absolute without its negative sign.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Add(PeterO.Cbor.CBORObject)'>
    <summary>Adds a new object to the end of this array. (Used to throw
      ArgumentNullException on a null reference, but now converts the null
      reference to CBORObject.Null, for convenience with the Object overload of
      this method.).
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is a CBOR object.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object is not an array.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Add(System.Object)'>
    <summary>Converts an object to a CBOR object and adds it to the end of this array.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is a CBOR object.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentException'>The type of
      <paramref name='obj'/>
       is not supported.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Add(System.Object,System.Object)'>
    <summary>Adds a new key and its value to this CBOR map, or adds the value if the
      key doesn't exist.
    </summary>
    <param name='key'>An object representing the key, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <param name='valueOb'>An object representing the value, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='key'/>
       already exists in this map.
    </exception>
    <exception cref='T:System.InvalidOperationException'>This object is not a map.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='key'/>
       or
      <paramref name='valueOb'/>
       has an unsupported type.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AddConverter``1(System.Type,PeterO.Cbor.ICBORConverter{``0})'>
    <summary>Registers an object that converts objects of a given type to CBOR objects
      (called a CBOR converter).
    </summary>
    <param name='type'>A Type object specifying the type that the converter converts to CBOR
      objects.
    </param>
    <param name='converter'>The parameter
      <paramref name='converter'/>
       is an ICBORConverter object.
    </param>
    <typeparam name='T'>Must be the same as the "type" parameter.
    </typeparam>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='type'/>
       or
      <paramref name='converter'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AddTagHandler(PeterO.BigInteger,PeterO.Cbor.ICBORTag)'>
    <summary>Registers an object that validates CBOR objects with new tags.
    </summary>
    <param name='bigintTag'>An arbitrary-precision integer.
    </param>
    <param name='handler'>The parameter
      <paramref name='handler'/>
       is an ICBORTag object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintTag'/>
       or
      <paramref name='handler'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='bigintTag'/>
       is less than 0 or greater than (2^64-1).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AddTagHandler(PeterO.Numbers.EInteger,PeterO.Cbor.ICBORTag)'>
    <summary>Registers an object that validates CBOR objects with new tags.
    </summary>
    <param name='bigintTag'>An arbitrary-precision integer.
    </param>
    <param name='handler'>The parameter
      <paramref name='handler'/>
       is an ICBORTag object.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Finds the sum of two CBOR numbers.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentException'>Either or both operands are not numbers (as opposed to Not-a-Number, NaN).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsBigInteger'>
    <summary>Converts this object to an arbitrary-precision integer. Fractional values
      are truncated to an integer.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including if this object is
      CBORObject.Null.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value is infinity or not-a-number (NaN).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsBoolean'>
    <summary>Returns false if this object is False, Null, or Undefined; otherwise,true.

    </summary>
    <returns>False if this object is False, Null, or Undefined; otherwise,true.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsByte'>
    <summary>Converts this object to a byte (0 to 255). Floating point values are
      truncated to an integer.
    </summary>
    <returns>The closest byte-sized integer to this object.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a byte (would be less than 0 or
      greater than 255 when truncated to an integer).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsDecimal'>
    <summary>Converts this object to a .NET decimal.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a .NET decimal.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsDouble'>
    <summary>Converts this object to a 64-bit floating point number.
    </summary>
    <returns>The closest 64-bit floating point number to this object. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsEDecimal'>
    <summary>Converts this object to a decimal number.
    </summary>
    <returns>A decimal number for this object's value. If this object is a rational
      number with a nonterminating decimal expansion, returns a decimal number
      rounded to 34 digits.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsEFloat'>
    <summary>Converts this object to an arbitrary-precision binary floating point
      number.
    </summary>
    <returns>An arbitrary-precision binary floating point number for this object's
      value. Note that if this object is a decimal number with a fractional
      part, the conversion may lose information depending on the number. If this
      object is a rational number with a nonterminating binary expansion,
      returns a binary floating-point number rounded to 113 bits.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsEInteger'>
    <summary>Converts this object to an arbitrary-precision integer. Fractional values
      are truncated to an integer.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsERational'>
    <summary>Converts this object to a rational number.
    </summary>
    <returns>A rational number for this object's value.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsExtendedDecimal'>
    <summary>Converts this object to a decimal number.
    </summary>
    <returns>A decimal number for this object's value. If this object is a rational
      number with a nonterminating decimal expansion, returns a decimal number
      rounded to 34 digits.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsExtendedFloat'>
    <summary>Converts this object to an arbitrary-precision binary floating point
      number.
    </summary>
    <returns>An arbitrary-precision binary floating point number for this object's
      value. Note that if this object is a decimal number with a fractional
      part, the conversion may lose information depending on the number. If this
      object is a rational number with a nonterminating binary expansion,
      returns a binary floating-point number rounded to 113 bits.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsExtendedRational'>
    <summary>Converts this object to a rational number.
    </summary>
    <returns>A rational number for this object's value.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsInt16'>
    <summary>Converts this object to a 16-bit signed integer. Floating point values are
      truncated to an integer.
    </summary>
    <returns>The closest 16-bit signed integer to this object.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 16-bit signed integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsInt32'>
    <summary>Converts this object to a 32-bit signed integer. Floating point values are
      truncated to an integer.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 32-bit signed integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsInt64'>
    <summary>Converts this object to a 64-bit signed integer. Floating point values are
      truncated to an integer.
    </summary>
    <returns>The closest 64-bit signed integer to this object.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 64-bit signed integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsSByte'>
    <summary>Converts this object to an 8-bit signed integer.
    </summary>
    <returns>An 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsSingle'>
    <summary>Converts this object to a 32-bit floating point number.
    </summary>
    <returns>The closest 32-bit floating point number to this object. The return value
      can be positive infinity or negative infinity if this object's value
      exceeds the range of a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsString'>
    <summary>Gets the value of this object as a text string.
    </summary>
    <returns>Gets this object's string.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a string, including if this object is
      CBORObject.Null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsUInt16'>
    <summary>Converts this object to a 16-bit unsigned integer. The return value will
      be truncated as necessary.
    </summary>
    <returns>A 16-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value is outside the range of a 16-bit unsigned integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsUInt32'>
    <summary>Converts this object to a 32-bit unsigned integer. The return value will
      be truncated as necessary.
    </summary>
    <returns>A 32-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value is outside the range of a 32-bit unsigned integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.AsUInt64'>
    <summary>Converts this object to a 64-bit unsigned integer. Non-integer values are
      truncated to an integer.
    </summary>
    <returns>The closest big integer to this object.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 64-bit unsigned integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanFitInDouble'>
    <summary>Returns whether this object's value can be converted to a 64-bit floating
      point number without loss of its numerical value.
    </summary>
    <returns>Whether this object's value can be converted to a 64-bit floating point
      number without loss of its numerical value. Returns true if this is a
      not-a-number value, even if the value's diagnostic information can' t fit
      in a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanFitInInt32'>
    <summary>Returns whether this object's value is an integral value, is -(2^31) or
      greater, and is less than 2^31.
    </summary>
    <returns><c>true</c> if this object's value is an integral value, is -(2^31) or greater, and
      is less than 2^31; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanFitInInt64'>
    <summary>Returns whether this object's value is an integral value, is -(2^63) or
      greater, and is less than 2^63.
    </summary>
    <returns><c>true</c> if this object's value is an integral value, is -(2^63) or greater, and
      is less than 2^63; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanFitInSingle'>
    <summary>Returns whether this object's value can be converted to a 32-bit floating
      point number without loss of its numerical value.
    </summary>
    <returns>Whether this object's value can be converted to a 32-bit floating point
      number without loss of its numerical value. Returns true if this is a
      not-a-number value, even if the value's diagnostic information can' t fit
      in a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt32'>
    <summary>Returns whether this object's value, truncated to an integer, would be
      -(2^31) or greater, and less than 2^31.
    </summary>
    <returns><c>true</c> if this object's value, truncated to an integer, would be -(2^31) or
      greater, and less than 2^31; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CanTruncatedIntFitInInt64'>
    <summary>Returns whether this object's value, truncated to an integer, would be
      -(2^63) or greater, and less than 2^63.
    </summary>
    <returns><c>true</c> if this object's value, truncated to an integer, would be -(2^63) or
      greater, and less than 2^63; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Clear'>
    <summary/>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CompareTo(PeterO.Cbor.CBORObject)'>
    <summary>Compares two CBOR objects.
      <para>In this implementation:
      </para>
      <list type=''>
        <item>The null pointer (null reference) is considered less than any other
          object.
        </item>
        <item>If either object is true, false, CBORObject.Null, or the undefined
          value, it is treated as less than the other value. If both objects
          have one of these four values, then undefined is less than
          CBORObject.Null, which is less than false, which is less than true.
        </item>
        <item>If both objects are numbers, their mathematical values are compared.
          Here, NaN (not-a-number) is considered greater than any number.
        </item>
        <item>If both objects are simple values other than true, false,
          CBORObject.Null, and the undefined value, the objects are compared
          according to their ordinal numbers.
        </item>
        <item>If both objects are arrays, each element is compared. If one array is
          shorter than the other and the other array begins with that array (for
          the purposes of comparison), the shorter array is considered less than
          the longer array.
        </item>
        <item>If both objects are strings, compares each string code-point by
          code-point, as though by the DataUtilities.CodePointCompare method.
        </item>
        <item>If both objects are maps, compares each map as though each were an
          array with the sorted keys of that map as the array's elements. If
          both maps have the same keys, their values are compared in the order
          of the sorted keys.
        </item>
        <item>If each object is a different type, then they are sorted by their type
          number, in the order given for the CBORType enumeration.
        </item>
        <item>If each object has different tags and both objects are otherwise equal
          under this method, each element is compared as though each were an
          array with that object's tags listed in order from outermost to
          innermost.
        </item>
      </list>
      <para>This method is not consistent with the Equals method.
      </para>
    </summary>
    <param name='other'>A value to compare with.
    </param>
    <returns>Less than 0, if this value is less than the other object; or 0, if both
      values are equal; or greater than 0, if this value is less than the other
      object or if the other object is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.CompareToIgnoreTags(PeterO.Cbor.CBORObject)'>
    <summary>Compares this object and another CBOR object, ignoring the tags they have,
      if any. See the CompareTo method for more information on the comparison
      function.
    </summary>
    <param name='other'>A value to compare with.
    </param>
    <returns>Less than 0, if this value is less than the other object; or 0, if both
      values are equal; or greater than 0, if this value is less than the other
      object or if the other object is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ContainsKey(PeterO.Cbor.CBORObject)'>
    <summary>Determines whether a value of the given key exists in this object.
    </summary>
    <param name='key'>An object that serves as the key.
    </param>
    <returns><c>true</c> if the given key is found, or false if the given key is not found or this
      object is not a map.
    </returns>
    <exception cref='T:System.ArgumentNullException'>Key is null (as opposed to CBORObject.Null).
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ContainsKey(System.String)'>
    <summary>Determines whether a value of the given key exists in this object.
    </summary>
    <param name='key'>A string that serves as the key.
    </param>
    <returns><c>true</c> if the given key (as a CBOR object) is found, or false if the given key
      is not found or this object is not a map.
    </returns>
    <exception cref='T:System.ArgumentNullException'>Key is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.ConverterInfo.Converter'>
    <summary>Gets or sets the ICBORConverter object.
    </summary>
    <value>The ICBORConverter object.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.ConverterInfo.ToObject'>
    <summary>Gets or sets the converter's ToCBORObject method.
    </summary>
    <value>The converter's ToCBORObject method.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Count'>
    <summary>Gets the number of keys in this map, or the number of items in this array,
      or 0 if this item is neither an array nor a map.
    </summary>
    <value>The number of keys in this map, or the number of items in this array, or 0
      if this item is neither an array nor a map.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[])'>
    <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c> contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b> </para>
      <para>Generates a CBOR object from an array of CBOR-encoded bytes.
      </para>
    </summary>
    <param name='data'>A byte array.
    </param>
    <returns>A CBOR object corresponding to the data.
    </returns>
    <exception cref='T:PeterO.Cbor.CBORException'>There was an error in reading or parsing the data. This includes cases
      where not all of the byte array represents a CBOR object. This exception
      is also thrown if the parameter
      <paramref name='data'/>
       is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.DecodeFromBytes(System.Byte[],PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Generates a CBOR object from an array of CBOR-encoded bytes, using the
      given
      <c>CBOREncodeOptions</c> object to control the decoding process.
    </summary>
    <param name='data'>A byte array.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBOR object corresponding to the data.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Divide(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Divides a CBORObject object by the value of a CBORObject object.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>The quotient of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.EncodeToBytes'>
    <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c> contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b> </para>
      <para>Writes the binary representation of this CBOR object and returns a byte
        array of that representation. If the CBOR object contains CBOR maps, or
        is a CBOR map itself, the keys to the map are written out to the byte
        array in an undefined order. The example code given in
        <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/>
         can be used to write out certain keys of a CBOR map in a given order.
      </para>
    </summary>
    <returns>A byte array in CBOR format.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.EncodeToBytes(PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Writes the binary representation of this CBOR object and returns a byte
      array of that representation, using the specified options for encoding the
      object to CBOR format. If the CBOR object contains CBOR maps, or is a CBOR
      map itself, the keys to the map are written out to the byte array in an
      undefined order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/>
       can be used to write out certain keys of a CBOR map in a given order.
    </summary>
    <param name='options'>Options for encoding the data to CBOR.
    </param>
    <returns>A byte array in CBOR format.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='options'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Equals(PeterO.Cbor.CBORObject)'>
    <summary>Compares the equality of two CBOR objects. Not-a-number values can be
      considered equal by this method.
    </summary>
    <param name='other'>The object to compare.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal and have the
      same type. Not-a-number values can be considered equal by this method.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.False'>
    <summary>Represents the value false.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromJSONString(System.String)'>
    <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c> contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b> </para>
      <para>Generates a CBOR object from a text string in JavaScript Object Notation
        (JSON) format.
      </para>
      <para>If a JSON object has the same key, only the last given value will be
        used for each duplicated key.
      </para>
    </summary>
    <param name='str'>A string in JSON format. The entire string must contain a single JSON
      object and not multiple objects. The string may not begin with a
      byte-order mark (U+FEFF).
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:PeterO.Cbor.CBORException'>The string is not in JSON format.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromJSONString(System.String,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Generates a CBOR object from a text string in JavaScript Object Notation
      (JSON) format, using the specified options to control the decoding
      process.
      <para>By default, if a JSON object has the same key, only the last given value
        will be used for each duplicated key.
      </para>
    </summary>
    <param name='str'>A string in JSON format. The entire string must contain a single JSON
      object and not multiple objects. The string may not begin with a
      byte-order mark (U+FEFF).
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.BigInteger)'>
    <summary>Generates a CBOR object from an arbitrary-precision integer.
    </summary>
    <param name='bigintValue'>An arbitrary-precision value.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject)'>
    <summary>Generates a CBOR object from a CBOR object.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a CBOR object.
    </param>
    <returns>Same as.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Cbor.CBORObject[])'>
    <summary>Generates a CBOR object from an array of CBOR objects.
    </summary>
    <param name='array'>An array of CBOR objects.
    </param>
    <returns>A CBOR object where each element of the given array is copied to a new
      array, or CBORObject.Null if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedDecimal)'>
    <summary>Generates a CBOR object from a decimal number.
    </summary>
    <param name='otherValue'>An arbitrary-precision decimal number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedFloat)'>
    <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary>
    <param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.ExtendedRational)'>
    <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary>
    <param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EDecimal)'>
    <summary>Generates a CBOR object from a decimal number.
    </summary>
    <param name='otherValue'>An arbitrary-precision decimal number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EFloat)'>
    <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary>
    <param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.EInteger)'>
    <summary>Generates a CBOR object from an arbitrary-precision integer.
    </summary>
    <param name='bigintValue'>An arbitrary-precision value.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(PeterO.Numbers.ERational)'>
    <summary>Generates a CBOR object from a rational number.
    </summary>
    <param name='bigValue'>A rational number.
    </param>
    <returns>A CBOR number.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Boolean)'>
    <summary>Returns the CBOR true value or false value, depending on "value".
    </summary>
    <param name='value'>Either True or False.
    </param>
    <returns>CBORObject.True if value is true; otherwise CBORObject.False.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Byte)'>
    <summary>Generates a CBOR object from a byte (0 to 255).
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a byte (from 0 to 255).
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Byte[])'>
    <summary>Generates a CBOR object from a byte array. The byte array is copied to a
      new byte array. (This method can't be used to decode CBOR data from a byte
      array; for that, use the DecodeFromBytes method instead.).
    </summary>
    <param name='bytes'>A byte array. Can be null.
    </param>
    <returns>A CBOR byte string object where each byte of the given byte array is
      copied to a new array, or CBORObject.Null if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Char)'>
    <summary>Generates a CBOR string object from a Unicode character.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a char object.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='value'/>
       is a surrogate code point.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Decimal)'>
    <summary>Converts a .NET decimal to a CBOR object.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a Decimal object.
    </param>
    <returns>A CBORObject object with the same value as the .NET decimal.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Double)'>
    <summary>Generates a CBOR object from a 64-bit floating-point number.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int16)'>
    <summary>Generates a CBOR object from a 16-bit signed integer.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 16-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int32)'>
    <summary>Generates a CBOR object from a 32-bit signed integer.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int32[])'>
    <summary>Generates a CBOR object from an array of 32-bit integers.
    </summary>
    <param name='array'>An array of 32-bit integers.
    </param>
    <returns>A CBOR array object where each element of the given array is copied to a
      new array, or CBORObject.Null if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int64)'>
    <summary>Generates a CBOR object from a 64-bit signed integer.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Int64[])'>
    <summary>Generates a CBOR object from an array of 64-bit integers.
    </summary>
    <param name='array'>An array of 64-bit integers.
    </param>
    <returns>A CBOR array object where each element of the given array is copied to a
      new array, or CBORObject.Null if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Object)'>
    <summary>Generates a CBORObject from an arbitrary object. See the overload of this
      method that takes a PODOptions argument.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns>A CBOR object corresponding to the given object. Returns CBORObject.Null
      if the object is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Object,PeterO.Cbor.PODOptions)'>
    <summary><para>Generates a CBORObject from an arbitrary object, using the given options
        to control how certain objects are converted to CBOR objects. The
        following types are specially handled by this method: null; primitive
        types; string; CBORObject; the
        <c>EDecimal</c> ,
        <c>EFloat</c> ,
        <c>EInteger</c> , and
        <c>ERational</c> classes in the new
        <a href='https://www.nuget.org/packages/PeterO.Numbers'>
          <c>PeterO.Numbers</c> </a>
         library (in .NET) or the
        <a href='https://github.com/peteroupc/numbers-java'>
          <c>com.github.peteroupc/numbers</c> </a>
         artifact (in Java); the legacy
        <c>ExtendedDecimal</c> ,
        <c>ExtendedFloat</c> ,
        <c>ExtendedInteger</c> , and
        <c>ExtendedRational</c> classes in this library; arrays; enumerations (
        <c>Enum</c> objects); and maps. (See also the other overloads to the FromObject
        method.)
      </para>
      <para>In the .NET version, if the object is a type not specially handled by
        this method, returns a CBOR map with the values of each of its
        read/write properties (or all properties in the case of a
        compiler-generated type). Properties are converted to their camel-case
        names (meaning if a name starts with A to Z, that letter is
        lower-cased). If the property name begins with the word "Is" followed by
        an upper-case A to Z, the "Is" prefix is deleted from the name. (Passing
        the appropriate "options" parameter can be done to control whether the
        "Is" prefix is removed and whether a camel-case conversion happens.)
        Also, .NET
        <c>Enum</c> objects will be converted to their integer values, and a
        multidimensional array is converted to an array of arrays.
      </para>
      <para>In the Java version, if the object is a type not specially handled by
        this method, this method checks the CBOR object for methods starting
        with the word "get" or "is" (either word followed by an upper-case A to
        Z) that take no parameters, and returns a CBOR map with one entry for
        each such method found. For each method found, the starting word "get"
        or "is" is deleted from its name, and the name is converted to camel
        case (meaning if a name starts with A to Z, that letter is lower-cased).
        (Passing the appropriate "options" parameter can be done to control
        whether the "is" prefix is removed and whether a camel-case conversion
        happens.) Also, Java
        <c>Enum</c> objects will be converted to the result of their
        <c>name</c> method.
      </para>
      <para>If the input is a byte array, the byte array is copied to a new byte
        array. (This method can't be used to decode CBOR data from a byte array;
        for that, use the DecodeFromBytes method instead.).
      </para>
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <param name='options'>An object containing options to control how certain objects are converted
      to CBOR objects.
    </param>
    <returns>A CBOR object corresponding to the given object. Returns CBORObject.Null
      if the object is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.SByte)'>
    <summary>Converts a signed 8-bit integer to a CBOR object.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is an 8-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.Single)'>
    <summary>Generates a CBOR object from a 32-bit floating-point number.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit floating-point number.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.String)'>
    <summary>Generates a CBOR object from a text string.
    </summary>
    <param name='strValue'>A string value. Can be null.
    </param>
    <returns>A CBOR object representing the string, or CBORObject.Null if stringValue
      is null.
    </returns>
    <exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.UInt16)'>
    <summary>Converts a 16-bit unsigned integer to a CBOR object.
    </summary>
    <param name='value'>A 16-bit unsigned integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.UInt32)'>
    <summary>Converts a 32-bit unsigned integer to a CBOR object.
    </summary>
    <param name='value'>A 32-bit unsigned integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject(System.UInt64)'>
    <summary>Converts a 64-bit unsigned integer to a CBOR object.
    </summary>
    <param name='value'>A 64-bit unsigned integer.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,PeterO.BigInteger)'>
    <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary>
    <param name='valueOb'>An arbitrary object. If the tag number is 2 or 3, this must be a byte
      string whose bytes represent an integer in little-endian byte order, and
      the value of the number is 1 minus the integer's value for tag 3. If the
      tag number is 4 or 5, this must be an array with two elements: the first
      must be an integer representing the exponent, and the second must be an
      integer representing a mantissa.
    </param>
    <param name='bigintTag'>Tag number. The tag number 55799 can be used to mark a "self-described
      CBOR" object.
    </param>
    <returns>A CBOR object where the object
      <paramref name='valueOb'/>
       is converted to a CBOR object and given the tag
      <paramref name='bigintTag'/>
       .
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='bigintTag'/>
       is less than 0 or greater than 2^64-1, or
      <paramref name='valueOb'/>
       's type is unsupported.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintTag'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,PeterO.Numbers.EInteger)'>
    <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary>
    <param name='valueOb'>An arbitrary object. If the tag number is 2 or 3, this must be a byte
      string whose bytes represent an integer in little-endian byte order, and
      the value of the number is 1 minus the integer's value for tag 3. If the
      tag number is 4 or 5, this must be an array with two elements: the first
      must be an integer representing the exponent, and the second must be an
      integer representing a mantissa.
    </param>
    <param name='bigintTag'>Tag number. The tag number 55799 can be used to mark a "self-described
      CBOR" object.
    </param>
    <returns>A CBOR object where the object
      <paramref name='valueOb'/>
       is converted to a CBOR object and given the tag
      <paramref name='bigintTag'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.Int32)'>
    <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary>
    <param name='valueObValue'>An arbitrary object. If the tag number is 2 or 3, this must be a byte
      string whose bytes represent an integer in little-endian byte order, and
      the value of the number is 1 minus the integer's value for tag 3. If the
      tag number is 4 or 5, this must be an array with two elements: the first
      must be an integer representing the exponent, and the second must be an
      integer representing a mantissa.
    </param>
    <param name='smallTag'>A 32-bit integer that specifies a tag number. The tag number 55799 can be
      used to mark a "self-described CBOR" object.
    </param>
    <returns>A CBOR object where the object
      <paramref name='valueObValue'/>
       is converted to a CBOR object and given the tag
      <paramref name='smallTag'/>
       .
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='smallTag'/>
       is less than 0 or
      <paramref name='valueObValue'/>
       's type is unsupported.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObjectAndTag(System.Object,System.UInt64)'>
    <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary>
    <param name='o'>The parameter
      <paramref name='o'/>
       is an arbitrary object.
    </param>
    <param name='tag'>A 64-bit unsigned integer.
    </param>
    <returns>A CBOR object where the object
      <paramref name='o'/>
       is converted to a CBOR object and given the tag
      <paramref name='tag'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Generates a CBOR object from an enumerable set of objects.
    </summary>
    <param name='value'>An object that implements the IEnumerable interface. In the .NET version,
      this can be the return value of an iterator or the result of a LINQ query.

    </param>
    <typeparam name='T'>A type convertible to CBORObject.
    </typeparam>
    <returns>A CBOR object where each element of the given enumerable object is
      converted to a CBOR object and copied to a new array, or CBORObject.Null
      if the value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject``1(System.Collections.Generic.IList{``0})'>
    <summary>Generates a CBOR object from a list of objects.
    </summary>
    <param name='value'>An array of CBOR objects. Can be null.
    </param>
    <typeparam name='T'>A type convertible to CBORObject.
    </typeparam>
    <returns>A CBOR object where each element of the given array is converted to a CBOR
      object and copied to a new array, or CBORObject.Null if the value is null.

    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromObject``2(System.Collections.Generic.IDictionary{``0,``1})'>
    <summary>Generates a CBOR object from a map of objects.
    </summary>
    <param name='dic'>A map of CBOR objects.
    </param>
    <typeparam name='TKey'>A type convertible to CBORObject; the type of the keys.
    </typeparam>
    <typeparam name='TValue'>A type convertible to CBORObject; the type of the values.
    </typeparam>
    <returns>A CBOR object where each key and value of the given map is converted to a
      CBOR object and copied to a new map, or CBORObject.Null if
      <paramref name='dic'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.FromSimpleValue(System.Int32)'>
    <summary>Creates a CBOR object from a simple value number.
    </summary>
    <param name='simpleValue'>The parameter
      <paramref name='simpleValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='simpleValue'/>
       is less than 0, greater than 255, or from 24 through 31.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetAllTags'>
    <summary>Gets a list of all tags, from outermost to innermost.
    </summary>
    <returns>An array of tags, or the empty string if this object is untagged.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetByteString'>
    <summary>Gets the byte array used in this object, if this object is a byte string,
      without copying the data to a new one. This method's return value can be
      used to modify the array's contents. Note, though, that the array' s
      length can't be changed.
    </summary>
    <returns>A byte array.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object is not a byte string.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.GetTags'>
    <summary>Gets a list of all tags, from outermost to innermost.
    </summary>
    <returns>An array of tags, or the empty string if this object is untagged.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.HasTag(PeterO.BigInteger)'>
    <summary>Returns whether this object has a tag of the given number.
    </summary>
    <param name='bigTagValue'>The tag value to search for.
    </param>
    <returns><c>true</c> if this object has a tag of the given number; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>BigTagValue is null.
    </exception>
    <exception cref='T:System.ArgumentException'>BigTagValue is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.HasTag(PeterO.Numbers.EInteger)'>
    <summary>Returns whether this object has a tag of the given number.
    </summary>
    <param name='bigTagValue'>The tag value to search for.
    </param>
    <returns><c>true</c> if this object has a tag of the given number; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.HasTag(System.Int32)'>
    <summary>Returns whether this object has a tag of the given number.
    </summary>
    <param name='tagValue'>The tag value to search for.
    </param>
    <returns><c>true</c> if this object has a tag of the given number; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentException'>TagValue is less than 0.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter "obj" is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.InnermostTag'>
    <summary>Gets the last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary>
    <value>The last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Insert(System.Int32,System.Object)'>
    <summary>Inserts an object at the specified position in this CBOR array.
    </summary>
    <param name='index'>Zero-based index to insert at.
    </param>
    <param name='valueOb'>An object representing the value, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='valueOb'/>
       has an unsupported type; or
      <paramref name='index'/>
       is not a valid index into this array.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsFalse'>
    <summary>Gets a value indicating whether this value is a CBOR false value.
    </summary>
    <value><c>true</c> If this value is a CBOR false value; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsFinite'>
    <summary>Gets a value indicating whether this CBOR object represents a finite
      number.
    </summary>
    <value><c>true</c> If this CBOR object represents a finite number; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.IsInfinity'>
    <summary>Gets a value indicating whether this CBOR object represents infinity.
    </summary>
    <returns><c>true</c> if this CBOR object represents infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsIntegral'>
    <summary>Gets a value indicating whether this object represents an integral number,
      that is, a number without a fractional part. Infinity and not-a-number are
      not considered integral.
    </summary>
    <value><c>true</c> If this object represents an integral number, that is, a number without a
      fractional part; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.IsNaN'>
    <summary>Gets a value indicating whether this CBOR object represents a not-a-number
      value (as opposed to whether this object's type is not a number type).
    </summary>
    <returns><c>true</c> if this CBOR object represents a not-a-number value (as opposed to
      whether this object's type is not a number type); otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsNegative'>
    <summary>Gets a value indicating whether this object is a negative number.
    </summary>
    <value><c>true</c> If this object is a negative number; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.IsNegativeInfinity'>
    <summary>Gets a value indicating whether this CBOR object represents negative
      infinity.
    </summary>
    <returns><c>true</c> if this CBOR object represents negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsNull'>
    <summary>Gets a value indicating whether this value is a CBOR null value.
    </summary>
    <value><c>true</c> If this value is a CBOR null value; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.IsPositiveInfinity'>
    <summary>Gets a value indicating whether this CBOR object represents positive
      infinity.
    </summary>
    <returns><c>true</c> if this CBOR object represents positive infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsTagged'>
    <summary>Gets a value indicating whether this data item has at least one tag.
    </summary>
    <value><c>true</c> If this data item has at least one tag; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsTrue'>
    <summary>Gets a value indicating whether this value is a CBOR true value.
    </summary>
    <value><c>true</c> If this value is a CBOR true value; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsUndefined'>
    <summary>Gets a value indicating whether this value is a CBOR undefined value.
    </summary>
    <value><c>true</c> If this value is a CBOR undefined value; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.IsZero'>
    <summary>Gets a value indicating whether this object's value equals 0.
    </summary>
    <value><c>true</c> If this object's value equals 0; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Item(PeterO.Cbor.CBORObject)'>
    <summary>Gets the value of a CBOR object in this map, using a CBOR object as the
      key.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a CBOR object.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The key is null (as opposed to CBORObject.Null); or the set method is
      called and the value is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Item(System.Int32)'>
    <summary>Gets the value of a CBOR object by integer index in this array.
    </summary>
    <param name='index'>Zero-based index of the element.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "value" is null (as opposed to CBORObject.Null).
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Item(System.String)'>
    <summary>Gets the value of a CBOR object in this map, using a string as the key.
    </summary>
    <param name='key'>A key that points to the desired value.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The key is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Keys'>
    <summary>Gets a collection of the keys of this CBOR object in an undefined order.
    </summary>
    <value>A collection of the keys of this CBOR object.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.MostInnerTag'>
    <summary>Gets the last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary>
    <value>The last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.MostOuterTag'>
    <summary>Gets the outermost tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary>
    <value>The outermost tag for this CBOR data item, or -1 if the item is untagged.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Multiplies two CBOR numbers.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>The product of the two numbers.
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.NaN'>
    <summary>A not-a-number value.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Negate'>
    <summary>Gets this object's value with the sign reversed.
    </summary>
    <returns>The reversed-sign form of this number.
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.NegativeInfinity'>
    <summary>The value negative infinity.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.NewArray'>
    <summary>Creates a new empty CBOR array.
    </summary>
    <returns>A new CBOR array.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.NewMap'>
    <summary>Creates a new empty CBOR map.
    </summary>
    <returns>A new CBOR map.
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.Null'>
    <summary>Represents the value null.
    </summary>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.OutermostTag'>
    <summary>Gets the outermost tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary>
    <value>The outermost tag for this CBOR data item, or -1 if the item is untagged.
    </value>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.PositiveInfinity'>
    <summary>The value positive infinity.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Read(System.IO.Stream)'>
    <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c> contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b> </para>
      <para>Reads an object in CBOR format from a data stream. This method will read
        from the stream until the end of the CBOR object is reached or an error
        occurs, whichever happens first.
      </para>
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <returns>A CBOR object that was read.
    </returns>
    <exception cref='T:PeterO.Cbor.CBORException'>There was an error in reading or parsing the data.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Read(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Reads an object in CBOR format from a data stream, using the specified
      options to control the decoding process. This method will read from the
      stream until the end of the CBOR object is reached or an error occurs,
      whichever happens first.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBOR object that was read.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream)'>
    <summary>Generates a CBOR object from a data stream in JavaScript Object Notation
      (JSON) format. The JSON stream may begin with a byte-order mark (U+FEFF).
      Since version 2.0, the JSON stream can be in UTF-8, UTF-16, or UTF-32
      encoding; the encoding is detected by assuming that the first character
      read must be a byte-order mark or a nonzero basic character (U+0001 to
      U+007F). (In previous versions, only UTF-8 was allowed.)
      <para>If a JSON object has the same key, only the last given value will be
        used for each duplicated key.
      </para>
    </summary>
    <param name='stream'>A readable data stream. The sequence of bytes read from the data stream
      must contain a single JSON object and not multiple objects.
    </param>
    <returns>A CBORObject object.
    </returns>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <exception cref='T:PeterO.Cbor.CBORException'>The data stream contains invalid encoding or is not in JSON format.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ReadJSON(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Generates a CBOR object from a data stream in JavaScript Object Notation
      (JSON) format, using the specified options to control the decoding
      process. The JSON stream may begin with a byte-order mark (U+FEFF). Since
      version 2.0, the JSON stream can be in UTF-8, UTF-16, or UTF-32 encoding;
      the encoding is detected by assuming that the first character read must be
      a byte-order mark or a nonzero basic character (U+0001 to U+007F). (In
      previous versions, only UTF-8 was allowed.)
      <para>By default, if a JSON object has the same key, only the last given value
        will be used for each duplicated key.
      </para>
    </summary>
    <param name='stream'>A readable data stream. The sequence of bytes read from the data stream
      must contain a single JSON object and not multiple objects.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Remainder(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Finds the remainder that results when a CBORObject object is divided by
      the value of a CBORObject object.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Remove(PeterO.Cbor.CBORObject)'>
    <summary>If this object is an array, removes the first instance of the specified
      item from the array. If this object is a map, removes the item with the
      given key from the map.
    </summary>
    <param name='obj'>The item or key to remove.
    </param>
    <returns><c>true</c> if the item was removed; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='obj'/>
       is null (as opposed to CBORObject.Null).
    </exception>
    <exception cref='T:System.InvalidOperationException'>The object is not an array or map.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Remove(System.Object)'>
    <summary>Not documented yet.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.RemoveAt(System.Int32)'>
    <summary/>
    <param name='index'>The parameter
      <paramref name='index'/>
       is not documented yet.
    </param>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Set(System.Object,System.Object)'>
    <summary>Maps an object to a key in this CBOR map, or adds the value if the key
      doesn't exist.
    </summary>
    <param name='key'>An object representing the key, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <param name='valueOb'>An object representing the value, which will be converted to a CBORObject.
      Can be null, in which case this value is converted to CBORObject.Null.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Sign'>
    <summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary>
    <value>This value's sign: -1 if negative; 1 if positive; 0 if zero.
    </value>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including the special
      not-a-number value (NaN).
    </exception>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.SimpleValue'>
    <summary>Gets the simple value ID of this object, or -1 if this object is not a
      simple value (including if the value is a floating-point number).
    </summary>
    <value>The simple value ID of this object, or -1 if this object is not a simple
      value (including if the value is a floating-point number).
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Subtract(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Finds the difference between two CBOR number objects.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToJSONString'>
    <summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format, using the specified options to control the encoding process. See
      the overload to JSONString taking a JSONOptions argument.
      <para>If the CBOR object contains CBOR maps, or is a CBOR map itself, the keys
        to the map are written out to the JSON string in an undefined order. The
        example code given in
        <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
         can be used to write out certain keys of a CBOR map in a given order to
        a JSON string.
      </para>
      <returns>A text string containing the converted object.
      </returns>
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'>
    <summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format, using the specified options to control the encoding process. This
      function works not only with arrays and maps, but also integers, strings,
      byte arrays, and other JSON data types. Notes:
      <list type=''>
        <item>If this object contains maps with non-string keys, the keys are
          converted to JSON strings before writing the map as a JSON string.
        </item>
        <item>If the CBOR object contains CBOR maps, or is a CBOR map itself, the
          keys to the map are written out to the JSON string in an undefined
          order.
        </item>
        <item>If a number in the form of an arbitrary-precision binary float has a
          very high binary exponent, it will be converted to a double before
          being converted to a JSON string. (The resulting double could overflow
          to infinity, in which case the arbitrary-precision binary float is
          converted to null.)
        </item>
        <item>The string will not begin with a byte-order mark (U+FEFF); RFC 8259
          (the JSON specification) forbids placing a byte-order mark at the
          beginning of a JSON string.
        </item>
        <item>Byte strings are converted to Base64 URL without whitespace or padding
          by default (see section 4.1 of RFC 7049). A byte string will instead
          be converted to traditional base64 without whitespace or padding by
          default if it has tag 22, or base16 for tag 23. Padding will be
          included in the Base64 URL or traditional base64 form if
          <b>Base64Padding</b> in the JSON options is set to
          <b>true</b> .
        </item>
        <item>Rational numbers will be converted to their exact form, if possible,
          otherwise to a high-precision approximation. (The resulting
          approximation could overflow to infinity, in which case the rational
          number is converted to null.)
        </item>
        <item>Simple values other than true and false will be converted to null.
          (This doesn't include floating-point numbers.)
        </item>
        <item>Infinity and not-a-number will be converted to null.
        </item>
      </list>
       The example code given below (written in in C# for the .NET version) can
      be used to write out certain keys of a CBOR map in a given order to a JSON
      string.
      <code>// Generates a JSON string of 'mapObj' whose keys are in the order given
        in 'keys'. Only keys // found in 'keys' will be written if they exist in
        'mapObj'. private static string KeysToJSONMap(CBORObject mapObj,
        IList&lt;CBORObject&gt; keys){ if(mapObj==null) throw new
        ArgumentNullException(nameof(mapObj)); if(keys==null) throw new
        ArgumentNullException(nameof(keys)); if(obj.Type!=CBORType.Map){ throw
        new ArgumentException("'obj' is not a map."); } var builder=new
        StringBuilder(); var first=true; builder.Append("{"); for(CBORObject key
        in keys){ if(mapObj.ContainsKey(key)){ if(!first)builder.Append(", ");
        var keyString=(key.CBORType==CBORType.String) ? key.AsString() :
        key.ToJSONString(); builder.Append(CBORObject.FromObject(keyString)
        .ToJSONString()) .Append(":").Append(mapObj[key].ToJSONString());
        first=false; } } return builder.Append("}").ToString(); }</code> .
    </summary>
    <param name='options'>An object containing the options to control writing the CBOR object to
      JSON.
    </param>
    <returns>A text string containing the converted object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.ToString'>
    <summary>Returns this CBOR object in string form. The format is intended to be
      human-readable, not machine-readable, the format is not intended to be
      parsed, and the format may change at any time.
    </summary>
    <returns>A text representation of this object.
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.True'>
    <summary>Represents the value true.
    </summary>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Type'>
    <summary>Gets the general data type of this CBOR object.
    </summary>
    <value>The general data type of this CBOR object.
    </value>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.Undefined'>
    <summary>Represents the value undefined.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Untag'>
    <summary>Gets an object with the same value as this one but without the tags it
      has, if any. If this object is an array, map, or byte string, the data
      will not be copied to the returned object, so changes to the returned
      object will be reflected in this one.
    </summary>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.UntagOne'>
    <summary>Gets an object with the same value as this one but without this object's
      outermost tag, if any. If this object is an array, map, or byte string,
      the data will not be copied to the returned object, so changes to the
      returned object will be reflected in this one.
    </summary>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.CBORObject.Values'>
    <summary>Gets a collection of the values of this CBOR object. If this object is a
      map, returns one value for each key in the map in an undefined order. If
      this is an array, returns all the values of the array in the order they
      are listed.
    </summary>
    <value>A collection of the values of this CBOR object.
    </value>
    <exception cref='T:System.InvalidOperationException'>This object is not a map or an array.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.BigInteger,System.IO.Stream)'>
    <summary>Writes a big integer in CBOR format to a data stream.
    </summary>
    <param name='bigint'>Big integer to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Cbor.CBORObject,System.IO.Stream)'>
    <summary>Writes a CBOR object to a CBOR data stream.
    </summary>
    <param name='value'>The value to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedDecimal,System.IO.Stream)'>
    <summary>Writes a decimal floating-point number in CBOR format to a data stream, as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          big integer otherwise.
        </item>
        <item>In all other cases, writes the value as a decimal number.
        </item>
      </list>
    </summary>
    <param name='bignum'>The arbitrary-precision decimal number to write. Can be null.
    </param>
    <param name='stream'>Stream to write to.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedFloat,System.IO.Stream)'>
    <summary>Writes a binary floating-point number in CBOR format to a data stream as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          big integer otherwise.
        </item>
        <item>In all other cases, writes the value as a big float.
        </item>
      </list>
    </summary>
    <param name='bignum'>An arbitrary-precision binary float.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.ExtendedRational,System.IO.Stream)'>
    <summary>Writes a rational number in CBOR format to a data stream.
    </summary>
    <param name='rational'>An arbitrary-precision rational number.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EDecimal,System.IO.Stream)'>
    <summary>Writes a decimal floating-point number in CBOR format to a data stream, as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          big integer otherwise.
        </item>
        <item>In all other cases, writes the value as a decimal number.
        </item>
      </list>
    </summary>
    <param name='bignum'>The arbitrary-precision decimal number to write. Can be null.
    </param>
    <param name='stream'>Stream to write to.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EFloat,System.IO.Stream)'>
    <summary>Writes a binary floating-point number in CBOR format to a data stream as
      follows:
      <list type=''>
        <item>If the value is null, writes the byte 0xF6.
        </item>
        <item>If the value is negative zero, infinity, or NaN, converts the number
          to a
          <c>double</c> and writes that
          <c>double</c> . If negative zero should not be written this way, use the Plus
          method to convert the value beforehand.
        </item>
        <item>If the value has an exponent of zero, writes the value as an unsigned
          integer or signed integer if the number can fit either type or as a
          big integer otherwise.
        </item>
        <item>In all other cases, writes the value as a big float.
        </item>
      </list>
    </summary>
    <param name='bignum'>An arbitrary-precision binary float.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.EInteger,System.IO.Stream)'>
    <summary>Writes a big integer in CBOR format to a data stream.
    </summary>
    <param name='bigint'>Big integer to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(PeterO.Numbers.ERational,System.IO.Stream)'>
    <summary>Writes a rational number in CBOR format to a data stream.
    </summary>
    <param name='rational'>An arbitrary-precision rational number.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Boolean,System.IO.Stream)'>
    <summary>Writes a Boolean value in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Byte,System.IO.Stream)'>
    <summary>Writes a byte (0 to 255) in CBOR format to a data stream. If the value is
      less than 24, writes that byte. If the value is 25 to 255, writes the byte
      24, then this byte's value.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Char,System.IO.Stream)'>
    <summary>Writes a Unicode character as a string in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Double,System.IO.Stream)'>
    <summary>Writes a 64-bit floating-point number in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Int16,System.IO.Stream)'>
    <summary>Writes a 16-bit signed integer in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Int32,System.IO.Stream)'>
    <summary>Writes a 32-bit signed integer in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Int64,System.IO.Stream)'>
    <summary>Writes a 64-bit signed integer in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream)'>
    <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c> contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b> </para>
      <para>Writes a CBOR object to a CBOR data stream. See the three-parameter
        Write method that takes a CBOREncodeOptions.
      </para>
    </summary>
    <param name='objValue'>The parameter
      <paramref name='objValue'/>
       is an arbitrary object.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Object,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Writes an arbitrary object to a CBOR data stream, using the specified
      options for controlling how the object is encoded to CBOR data format. If
      the object is convertible to a CBOR map or a CBOR object that contains
      CBOR maps, the keys to those maps are written out to the data stream in an
      undefined order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/>
       can be used to write out certain keys of a CBOR map in a given order.
      Currently, the following objects are supported:
      <list type=''>
        <item>Lists of CBORObject.
        </item>
        <item>Maps of CBORObject. The keys to the map are written out to the data
          stream in an undefined order.
        </item>
        <item>Null.
        </item>
        <item>Byte arrays, which will always be written as definite-length byte
          strings.
        </item>
        <item>String objects, which will be written as indefinite-length text
          strings if their size exceeds a certain threshold (this behavior may
          change in future versions of this library).
        </item>
        <item>Any object accepted by the FromObject static methods.
        </item>
      </list>
    </summary>
    <param name='objValue'>The arbitrary object to be serialized. Can be null.
    </param>
    <param name='output'>A writable data stream.
    </param>
    <param name='options'>CBOR options for encoding the CBOR object to bytes.
    </param>
    <exception cref='T:System.ArgumentException'>The object's type is not supported.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='options'/>
       or
      <paramref name='output'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.SByte,System.IO.Stream)'>
    <summary>Writes an 8-bit signed integer in CBOR format to a data stream.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is an 8-bit signed integer.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.Single,System.IO.Stream)'>
    <summary>Writes a 32-bit floating-point number in CBOR format to a data stream.
    </summary>
    <param name='value'>The value to write.
    </param>
    <param name='s'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream)'>
    <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c> contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b> </para>
      <para>Writes a string in CBOR format to a data stream. The string will be
        encoded using indefinite-length encoding if its length exceeds a certain
        threshold (this behavior may change in future versions of this library).

      </para>
    </summary>
    <param name='str'>The string to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.String,System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Writes a string in CBOR format to a data stream, using the given options
      to control the encoding process.
    </summary>
    <param name='str'>The string to write. Can be null.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='options'>Options for encoding the data to CBOR.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.UInt16,System.IO.Stream)'>
    <summary>Writes a 16-bit unsigned integer in CBOR format to a data stream.
    </summary>
    <param name='value'>A 16-bit unsigned integer.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.UInt32,System.IO.Stream)'>
    <summary>Writes a 32-bit unsigned integer in CBOR format to a data stream.
    </summary>
    <param name='value'>A 32-bit unsigned integer.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.Write(System.UInt64,System.IO.Stream)'>
    <summary>Writes a 64-bit unsigned integer in CBOR format to a data stream.
    </summary>
    <param name='value'>A 64-bit unsigned integer.
    </param>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteJSON(System.Object,System.IO.Stream)'>
    <summary>Converts an arbitrary object to a string in JavaScript Object Notation
      (JSON) format, as in the ToJSONString method, and writes that string to a
      data stream in UTF-8. If the object is convertible to a CBOR map, or to a
      CBOR object that contains CBOR maps, the keys to those maps are written
      out to the JSON string in an undefined order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
       can be used to write out certain keys of a CBOR map in a given order to a
      JSON string.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <param name='outputStream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream)'>
    <summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format, as in the ToJSONString method, and writes that string to a data
      stream in UTF-8. If the CBOR object contains CBOR maps, or is a CBOR map,
      the keys to the map are written out to the JSON string in an undefined
      order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
       can be used to write out certain keys of a CBOR map in a given order to a
      JSON string.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='outputStream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteJSONTo(System.IO.Stream,PeterO.Cbor.JSONOptions)'>
    <summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format, as in the ToJSONString method, and writes that string to a data
      stream in UTF-8, using the given JSON options to control the encoding
      process. If the CBOR object contains CBOR maps, or is a CBOR map, the keys
      to the map are written out to the JSON string in an undefined order. The
      example code given in
      <see cref='M:PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)'/>
       can be used to write out certain keys of a CBOR map in a given order to a
      JSON string.
    </summary>
    <param name='outputStream'>A writable data stream.
    </param>
    <param name='options'>An object containing the options to control writing the CBOR object to
      JSON.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'>
    <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:PeterO.Cbor.CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c> contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b> </para>
      <para>Writes this CBOR object to a data stream. If the CBOR object contains
        CBOR maps, or is a CBOR map, the keys to the map are written out to the
        data stream in an undefined order. The example method given below
        (written in C# for the .NET version) can be used to write out certain
        keys of a CBOR map in a given order:
      </para>
      <code>// Writes each key of 'mapObj' to 'outputStream'in the order given in
        'keys'. Only keys // found in 'keys' will be written if they exist in
        'mapObj'. private static void WriteKeysToIndefMap(CBORObject mapObj,
        IList&lt;CBORObject&gt; keys, Stream outputStream){ if(mapObj==null)
        throw new ArgumentNullException(nameof(mapObj)); if(keys==null) throw
        new ArgumentNullException(nameof(keys)); if(outputStream==null) throw
        new ArgumentNullException(nameof(outputStream));
        if(obj.Type!=CBORType.Map){ throw new ArgumentException("'obj' is not a
        map."); } outputStream.WriteByte((byte)0xBF); for(CBORObject key in
        keys)[ if(mapObj.ContainsKey(key)){ key.WriteTo(outputStream);
        mapObj[key].WriteTo(outputStream); } }
        outputStream.WriteByte((byte)0xBF); }</code> .
    </summary>
    <param name='stream'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream,PeterO.Cbor.CBOREncodeOptions)'>
    <summary>Writes this CBOR object to a data stream, using the specified options for
      encoding the data to CBOR format. If the CBOR object contains CBOR maps,
      or is a CBOR map, the keys to the map are written out to the data stream
      in an undefined order. The example code given in
      <see cref='M:PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/>
       can be used to write out certain keys of a CBOR map in a given order.
    </summary>
    <param name='stream'>A writable data stream.
    </param>
    <param name='options'>Options for encoding the data to CBOR.
    </param>
  </doc>
  <doc name='F:PeterO.Cbor.CBORObject.Zero'>
    <summary>Gets a CBOR object for the number zero.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Addition(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Adds two CBOR objects and returns their result.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The sum of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Division(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Divides a CBORObject object by the value of a CBORObject object.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The quotient of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Modulus(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Finds the remainder that results when a CBORObject object is divided by
      the value of a CBORObject object.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Multiply(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Multiplies a CBORObject object by the value of a CBORObject object.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The product of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORObject.op_Subtraction(PeterO.Cbor.CBORObject,PeterO.Cbor.CBORObject)'>
    <summary>Subtracts a CBORObject object from a CBORObject object.
    </summary>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param>
    <param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.CBORObjectMath'>
    <summary>Implements arithmetic operations with CBOR objects.
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.CBORTag3'>
    <summary>Implements CBOR tag 3.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTag37.ToCBORObject(System.Guid)'>
    <summary>Converts a UUID to a CBOR object.
    </summary>
    <param name='obj'>A UUID.
    </param>
    <returns>A CBORObject object.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.CBORTagGenericString'>
    <summary>A generic CBOR tag class for strings.
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.CBORType'>
    <summary>Represents a type that a CBOR object can have.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.Array'>
    <summary>An array of CBOR objects.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.Boolean'>
    <summary>The simple values true and false.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.ByteString'>
    <summary>An array of bytes.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.Map'>
    <summary>A map of CBOR objects.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.Number'>
    <summary>A number of any kind, including integers, big integers, floating point
      numbers, and decimal numbers. The floating-point value Not-a-Number is
      also included in the Number type.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.SimpleValue'>
    <summary>A "simple value" other than floating point values, true, and false.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORType.TextString'>
    <summary>A text string.
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.CBORTypeFilter'>
    <summary>Specifies what kinds of CBOR objects a tag can be. This class is used when
      a CBOR object is being read from a data stream. This class can't be
      inherited; this is a change in version 2.0 from previous versions, where
      the class was inadvertently left inheritable.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORTypeFilter.Any'>
    <summary>A filter that allows any CBOR object.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.ArrayIndexAllowed(System.Int32)'>
    <summary>Determines whether this type filter allows CBOR arrays and the given array
      index is allowed under this type filter.
    </summary>
    <param name='index'>An array index, starting from 0.
    </param>
    <returns><c>true</c> if this type filter allows CBOR arrays and the given array index is
      allowed under this type filter; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.ArrayLengthMatches(PeterO.Numbers.EInteger)'>
    <summary>Returns whether an array's length is allowed under a filter.
    </summary>
    <param name='bigLength'>An arbitrary-precision integer.
    </param>
    <returns><c>true</c> if this filter allows CBOR arrays and an array's length is allowed under
      a filter; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigLength'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.ArrayLengthMatches(System.Int32)'>
    <summary>Returns whether an array's length is allowed under this filter.
    </summary>
    <param name='length'>The length of a CBOR array.
    </param>
    <returns><c>true</c> if this filter allows CBOR arrays and an array's length is allowed under
      this filter; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.ArrayLengthMatches(System.Int64)'>
    <summary>Returns whether an array's length is allowed under a filter.
    </summary>
    <param name='length'>The length of a CBOR array.
    </param>
    <returns><c>true</c> if this filter allows CBOR arrays and an array's length is allowed under
      a filter; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORTypeFilter.ByteString'>
    <summary>A filter that allows byte strings.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.GetSubFilter(System.Int32)'>
    <summary>Gets the type filter for this array filter by its index.
    </summary>
    <param name='index'>A zero-based index of the filter to retrieve.
    </param>
    <returns>Returns None if the index is out of range, or Any if this filter doesn't
      filter an array. Returns the appropriate filter for the array index
      otherwise.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.GetSubFilter(System.Int64)'>
    <summary>Gets the type filter for this array filter by its index.
    </summary>
    <param name='index'>A zero-based index of the filter to retrieve.
    </param>
    <returns>Returns None if the index is out of range, or Any if this filter doesn't
      filter an array. Returns the appropriate filter for the array index
      otherwise.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.MajorTypeMatches(System.Int32)'>
    <summary>Returns whether the given CBOR major type matches a major type allowed by
      this filter.
    </summary>
    <param name='type'>A CBOR major type from 0 to 7.
    </param>
    <returns><c>true</c> if the given CBOR major type matches a major type allowed by this filter;
      otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORTypeFilter.NegativeInteger'>
    <summary>A filter that allows negative integers.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.NonFPSimpleValueAllowed'>
    <summary>Returns whether this filter allows simple values that are not
      floating-point numbers.
    </summary>
    <returns><c>true</c> if this filter allows simple values that are not floating-point numbers;
      otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORTypeFilter.None'>
    <summary>A filter that allows no CBOR types.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.TagAllowed(PeterO.Numbers.EInteger)'>
    <summary>Gets a value indicating whether CBOR objects can have the given tag
      number.
    </summary>
    <param name='bigTag'>A tag number. Returns false if this is less than 0.
    </param>
    <returns><c>true</c> if CBOR objects can have the given tag number; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigTag'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.TagAllowed(System.Int32)'>
    <summary>Gets a value indicating whether CBOR objects can have the given tag
      number.
    </summary>
    <param name='tag'>A tag number. Returns false if this is less than 0.
    </param>
    <returns><c>true</c> if CBOR objects can have the given tag number; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.TagAllowed(System.Int64)'>
    <summary>Gets a value indicating whether CBOR objects can have the given tag
      number.
    </summary>
    <param name='longTag'>A tag number. Returns false if this is less than 0.
    </param>
    <returns><c>true</c> if CBOR objects can have the given tag number; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='F:PeterO.Cbor.CBORTypeFilter.TextString'>
    <summary>A filter that allows text strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.CBORTypeFilter.UnsignedInteger'>
    <summary>A filter that allows unsigned integers.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithArrayAnyLength'>
    <summary>Copies this filter and includes arrays of any length in the new filter.
    </summary>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithArrayExactLength(System.Int32,PeterO.Cbor.CBORTypeFilter[])'>
    <summary>Copies this filter and includes CBOR arrays with an exact length to the
      new filter.
    </summary>
    <param name='arrayLength'>The desired maximum length of an array.
    </param>
    <param name='elements'>An array containing the allowed types for each element in the array. There
      must be at least as many elements here as given in the arrayLength
      parameter.
    </param>
    <returns>A CBORTypeFilter object.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter arrayLength is less than 0.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter elements is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter elements has fewer elements than specified in arrayLength.
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithArrayMinLength(System.Int32,PeterO.Cbor.CBORTypeFilter[])'>
    <summary>Copies this filter and includes CBOR arrays with at least a given length
      to the new filter.
    </summary>
    <param name='arrayLength'>The desired minimum length of an array.
    </param>
    <param name='elements'>An array containing the allowed types for each element in the array. There
      must be at least as many elements here as given in the arrayLength
      parameter.
    </param>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithByteString'>
    <summary>Copies this filter and includes byte strings in the new filter.
    </summary>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithFloatingPoint'>
    <summary>Copies this filter and includes floating-point numbers in the new filter.
    </summary>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithMap'>
    <summary>Copies this filter and includes maps in the new filter.
    </summary>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithNegativeInteger'>
    <summary>Copies this filter and includes negative integers in the new filter.
    </summary>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithTags(System.Int32[])'>
    <summary>Copies this filter and includes a set of valid CBOR tags in the new
      filter.
    </summary>
    <param name='tags'>An array of the CBOR tags to add to the new filter.
    </param>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithTextString'>
    <summary>Copies this filter and includes text strings in the new filter.
    </summary>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.CBORTypeFilter.WithUnsignedInteger'>
    <summary>Copies this filter and includes unsigned integers in the new filter.
    </summary>
    <returns>A CBORTypeFilter object.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.CBORUtilities'>
    <summary>Contains utility methods that may have use outside of the CBORObject
      class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.FastInteger2.Multiply(System.Int32)'>
    <summary>Sets this object's value to the current value times another integer.
    </summary>
    <param name='val'>The integer to multiply by.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='P:PeterO.Cbor.FastInteger2.Sign'>
    <summary>Gets the sign of this object's value.
    </summary>
    <value>1 if positive, -1 if negative, 0 if zero.
    </value>
  </doc>
  <doc name='M:PeterO.Cbor.FastInteger2.Subtract(PeterO.Cbor.FastInteger2)'>
    <summary>Sets this object's value to the current value minus the given FastInteger
      value.
    </summary>
    <param name='val'>The subtrahend.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.FastInteger2.SubtractInt(System.Int32)'>
    <summary>Sets this object's value to the current value minus the given integer.
    </summary>
    <param name='val'>The subtrahend.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.ICBORConverter`1'>
    <summary>Interface implemented by classes that convert objects of arbitrary types
      to CBOR objects.
    </summary>
    <typeparam name='T'>Type to convert to a CBOR object.
    </typeparam>
  </doc>
  <doc name='M:PeterO.Cbor.ICBORConverter`1.ToCBORObject(`0)'>
    <summary>Converts an object to a CBOR object.
    </summary>
    <param name='obj'>An object to convert to a CBOR object.
    </param>
    <returns>A CBOR object.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.ICBORTag'>
    <summary>Implemented by classes that validate CBOR objects belonging to a specific
      tag.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.ICBORTag.GetTypeFilter'>
    <summary>Gets a type filter specifying what kinds of CBOR objects are supported by
      this tag.
    </summary>
    <returns>A CBOR type filter.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.ICBORTag.ValidateObject(PeterO.Cbor.CBORObject)'>
    <summary>Generates a CBOR object based on the data of another object. If the data
      is not valid, should throw a CBORException.
    </summary>
    <param name='obj'>A CBOR object with the corresponding tag handled by the ICBORTag object.
    </param>
    <returns>A CBORObject object. Note that this method may choose to return the same
      object as the parameter.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.ICharacterInput'>
    <summary>An interface for reading Unicode characters from a data source.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.ICharacterInput.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>Index in the output buffer to start writing to.
    </param>
    <param name='length'>Maximum number of code points to write.
    </param>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.ICharacterInput.ReadChar'>
    <summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.Cbor.JSONOptions'>
    <summary>Includes options to control how CBOR objects are converted to JSON.
    </summary>
    <seealso cref='M:PeterO.Cbor.CBORObject.ToJSONString'/>
  </doc>
  <doc name='M:PeterO.Cbor.JSONOptions.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.JSONOptions'/>
       class with default options.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.JSONOptions.#ctor(System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.JSONOptions'/>
       class with the given values for the options.
    </summary>
    <param name='base64Padding'>Whether padding is included when writing data in base64url or traditional
      base64 format to JSON.
    </param>
  </doc>
  <doc name='P:PeterO.Cbor.JSONOptions.Base64Padding'>
    <summary>If
      <b>true</b> , include padding when writing data in base64url or traditional base64
      format to JSON.
    </summary>
    <value>The default is
      <b>false</b> , no padding.
    </value>
    <remarks>
       The padding character is '='.
    </remarks>
  </doc>
  <doc name='F:PeterO.Cbor.JSONOptions.Default'>
    <summary>The default options for converting CBOR objects to JSON.
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.PODOptions'>
    <summary>Options for converting "plain old data" objects to CBOR objects.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.PODOptions.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.PODOptions'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.PODOptions.#ctor(System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Cbor.PODOptions'/>
       class.
    </summary>
    <param name='removeIsPrefix'>If set to
      <c>true</c> remove is prefix.
    </param>
    <param name='useCamelCase'>If set to
      <c>true</c> use camel case.
    </param>
  </doc>
  <doc name='F:PeterO.Cbor.PODOptions.Default'>
    <summary>The default settings for "plain old data" options.
    </summary>
  </doc>
  <doc name='P:PeterO.Cbor.PODOptions.RemoveIsPrefix'>
    <summary>Gets a value indicating whether the "Is" prefix in property names is
      removed before they are used as keys.
    </summary>
    <value><c>true</c> if the prefix is removed; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Cbor.PODOptions.UseCamelCase'>
    <summary>Gets a value indicating whether property names are converted to camel case
      before they are used as keys.
    </summary>
    <value><c>true</c> if the names are converted to camel case; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='T:PeterO.Cbor.StringRefs'>
    <summary>Implements CBOR string references, described at
      <c>http://cbor.schmorp.de/stringref</c> .
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.URIUtility'>
    <summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
  </doc>
  <doc name='T:PeterO.Cbor.URIUtility.ParseMode'>
    <summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRIStrict'>
    <summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.IRISurrogateLenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.URILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
  </doc>
  <doc name='F:PeterO.Cbor.URIUtility.ParseMode.URIStrict'>
    <summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.PercentDecode(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.escapeURI(System.String,System.Int32)'>
    <summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.hasScheme(System.String)'>
    <summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.hasSchemeForURI(System.String)'>
    <summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)'>
    <summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise,
      <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.relativeResolve(System.String,System.String,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> . Can be null.
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. The
      scheme, authority, query, and fragment components, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Cbor.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Cbor.URIUtility.ParseMode)'>
    <summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. The scheme,
      authority, query, and fragment components, if present, will each be given
      without the ending colon, the starting "//", the starting "?", and the
      starting "#", respectively. If a component is absent, both indices in that
      pair will be -1 (an index won't be less than 0 in any other case). If the
      string is null or is not a valid IRI, returns null.
    </returns>
  </doc>
  <doc name='T:PeterO.CulturedText'>
    <summary>Contains string processing operations that should be formatted according
      to the current locale's formatting rules.
    </summary>
    <remarks>
       This class, along with the InvariantText class, supports the correct use
      of string functions in the framework. InvariantText is intended for use in
      locale-independent string processing, such as data and file system
      processing, while CulturedText is intended for text display. Use
      CulturedText for formatting the messages of exceptions and within the
      Console.Write method.
    </remarks>
  </doc>
  <doc name='M:PeterO.CulturedText.Compare(System.String,System.String)'>
    <summary>Compares a text string with a string.
    </summary>
    <param name='value1'>The parameter
      <paramref name='value1'/>
       is a text string.
    </param>
    <param name='value2'>The parameter
      <paramref name='value2'/>
       is a text string.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.CompareIgnoreCase(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='value1'>The parameter
      <paramref name='value1'/>
       is a text string.
    </param>
    <param name='value2'>The parameter
      <paramref name='value2'/>
       is a text string.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.EndsWith(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='value1'>The parameter
      <paramref name='value1'/>
       is a text string.
    </param>
    <param name='value2'>The parameter
      <paramref name='value2'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='value1'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.CulturedText.Format(System.String,System.Object[])'>
    <summary>Not documented yet.
    </summary>
    <param name='formattedText'>The parameter
      <paramref name='formattedText'/>
       is a text string.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a params object.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ParseInt32(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ParseInt32Hex(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.StartsWith(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='value1'>The parameter
      <paramref name='value1'/>
       is a text string.
    </param>
    <param name='value2'>The parameter
      <paramref name='value2'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ToString(System.Byte)'>
    <summary>Converts this object to a text string.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a byte (from 0 to 255).
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ToString(System.Double)'>
    <summary>Converts this object to a text string.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ToString(System.Int16)'>
    <summary>Converts this object to a text string.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 16-bit signed integer.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ToString(System.Int32)'>
    <summary>Converts this object to a text string.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ToString(System.Int64)'>
    <summary>Converts this object to a text string.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ToString(System.Object)'>
    <summary>Converts this object to a text string.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is an arbitrary object.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.CulturedText.ToString(System.Single)'>
    <summary>Converts this object to a text string.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit floating-point number.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='T:PeterO.DataIO'>
    <summary>Convenience class that contains static methods for wrapping byte arrays
      and streams into byte readers and byte writers.
    </summary>
  </doc>
  <doc name='M:PeterO.DataIO.ByteArrayTransform.Read(System.Byte[],System.Int32,System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='bytes'>The parameter
      <paramref name='bytes'/>
       is not documented yet.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='bytes'/>
       begins.
    </param>
    <param name='length'>The length, in bytes, of the desired portion of
      <paramref name='bytes'/>
       (but not more than
      <paramref name='bytes'/>
       's length).
    </param>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='bytes'/>
       's length, or
      <paramref name='bytes'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.DataIO.ByteArrayTransform.ReadByte'>
    <summary>This is an internal method.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.DataIO.ToByteReader(System.Byte[])'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing byte[] and can be called as follows:
        <c>bytes.ToByteReader()</c> . If the object's class already has a ToByteReader method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='bytes'>The parameter
      <paramref name='bytes'/>
       is not documented yet.
    </param>
    <returns>An IByteReader object.
    </returns>
  </doc>
  <doc name='M:PeterO.DataIO.ToByteReader(System.Byte[],System.Int32,System.Int32)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing byte[] and can be called as follows:
        <c>bytes.ToByteReader(offset, length)</c> . If the object's class already has a ToByteReader method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='bytes'>The parameter
      <paramref name='bytes'/>
       is not documented yet.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='bytes'/>
       begins.
    </param>
    <param name='length'>The length, in bytes, of the desired portion of
      <paramref name='bytes'/>
       (but not more than
      <paramref name='bytes'/>
       's length).
    </param>
    <returns>An IByteReader object.
    </returns>
  </doc>
  <doc name='M:PeterO.DataIO.ToByteReader(System.IO.Stream)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Stream and can be called as follows:
        <c>input.ToByteReader()</c> . If the object's class already has a ToByteReader method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is not documented yet.
    </param>
    <returns>An IByteReader object.
    </returns>
  </doc>
  <doc name='M:PeterO.DataIO.ToReader(System.Byte[])'>
    <summary>Wraps a byte array into a byte reader. The reader will start at the
      beginning of the byte array.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any byte array object and can be called as follows:
        <c>bytes.ToByteReader()</c> . If the object's class already has a ToByteReader method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='bytes'>The byte array to wrap.
    </param>
    <returns>A byte reader wrapping the byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.DataIO.ToReader(System.Byte[],System.Int32,System.Int32)'>
    <summary>Wraps a portion of a byte array into a byte reader object.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any byte array object and can be called as follows:
        <c>bytes.ToByteReader(offset, length)</c> . If the object's class already has a ToByteReader method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='bytes'>The byte array to wrap.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "bytes" begins.
    </param>
    <param name='length'>The length, in bytes, of the desired portion of "bytes" (but not more than
      "bytes" 's length).
    </param>
    <returns>A byte reader wrapping the byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.DataIO.ToReader(System.IO.Stream)'>
    <summary>Wraps an input stream into a reader object. If an IOException is thrown by
      the input stream, the reader object throws InvalidOperationException
      instead.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Stream and can be called as follows:
        <c>input.ToByteReader()</c> . If the object's class already has a ToByteReader method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='input'>The input stream to wrap.
    </param>
    <returns>A byte reader wrapping the input stream.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='input'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataIO.ToWriter(PeterO.IByteWriter)'>
    <summary>Wraps a byte writer (one that only implements a ReadByte method) to a
      writer (one that also implements a three-parameter Read method.)
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IByteWriter and can be called as
        follows:
        <c>output.ToWriter()</c> . If the object's class already has a ToWriter method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='output'>A byte stream.
    </param>
    <returns>A writer that wraps the given stream.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='output'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataIO.ToWriter(System.IO.Stream)'>
    <summary>Wraps an output stream into a writer object. If an IOException is thrown
      by the input stream, the writer object throws InvalidOperationException
      instead.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Stream and can be called as follows:
        <c>output.ToWriter()</c> . If the object's class already has a ToWriter method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='output'>Output stream to wrap.
    </param>
    <returns>A byte writer that wraps the given output stream.
    </returns>
  </doc>
  <doc name='M:PeterO.DataIO.WrappedOutputStream.Write(System.Byte[],System.Int32,System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='bytes'>A byte array.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "bytes" begins.
    </param>
    <param name='length'>The length, in bytes, of the desired portion of "bytes" (but not more than
      "bytes" 's length).
    </param>
  </doc>
  <doc name='M:PeterO.DataIO.WrappedOutputStream.WriteByte(System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='byteValue'>The parameter
      <paramref name='byteValue'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.DataIO.WrappedOutputStreamFromByteWriter.Write(System.Byte[],System.Int32,System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='bytes'>A byte array.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "bytes" begins.
    </param>
    <param name='length'>The length, in bytes, of the desired portion of "bytes" (but not more than
      "bytes" 's length).
    </param>
  </doc>
  <doc name='M:PeterO.DataIO.WrappedOutputStreamFromByteWriter.WriteByte(System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='byteValue'>The parameter
      <paramref name='byteValue'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.DataIO.WrappedStream.ReadByte'>
    <summary>This is an internal method.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='T:PeterO.DataUtilities'>
    <summary>Contains methods useful for reading and writing strings. It is designed to
      have no dependencies other than the basic runtime class library.
      <para>Many of these methods work with text encoded in UTF-8, an encoding form
        of the Unicode Standard which uses one byte to encode the most basic
        characters and two to four bytes to encode other characters. For
        example, the
        <c>GetUtf8</c> method converts a text string to an array of bytes in UTF-8.
      </para>
      <para>In C# and Java, text strings are represented as sequences of 16-bit
        values called
        <c>char</c> s. These sequences are well-formed under UTF-16, a 16-bit encoding form
        of Unicode, except if they contain unpaired surrogate code points. (A
        surrogate code point is used to encode supplementary characters, those
        with code points U+10000 or higher, in UTF-16. A surrogate pair is a
        high surrogate [U+D800 to U+DBFF] followed by a low surrogate [U+DC00 to
        U+DFFF]. An unpaired surrogate code point is a surrogate not appearing
        in a surrogate pair.) Many of the methods in this class allow setting
        the behavior to follow when unpaired surrogate code points are found in
        text strings, such as throwing an error or treating the unpaired
        surrogate as a replacement character (U+FFFD).
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)'>
    <summary>Gets the Unicode code point at the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <returns>The Unicode code point at the given position. Returns -1 if
      <paramref name='index'/>
       is less than 0, or is the string's length or greater. Returns the
      replacement character (U+FFFD) if the current character is an unpaired
      surrogate code point.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)'>
    <summary>Gets the Unicode code point at the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <param name='surrogateBehavior'>Specifies what kind of value to return if the previous character is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param>
    <returns>The Unicode code point at the current position. Returns -1 if
      <paramref name='index'/>
       is less than 0, or is the string's length or greater. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the previous character is an unpaired surrogate code point.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)'>
    <summary>Gets the Unicode code point just before the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns the
      replacement character (U+FFFD) if the previous character is an unpaired
      surrogate code point.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)'>
    <summary>Gets the Unicode code point just before the given index of the string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>Index of the current position into the string.
    </param>
    <param name='surrogateBehavior'>Specifies what kind of value to return if the previous character is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param>
    <returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the previous character is an unpaired surrogate code point.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)'>
    <summary>Compares two strings in Unicode code point order. Unpaired surrogate code
      points are treated as individual code points.
    </summary>
    <param name='strA'>The first string. Can be null.
    </param>
    <param name='strB'>The second string. Can be null.
    </param>
    <returns>A value indicating which string is " less" or " greater" . 0: Both strings
      are equal or null. Less than 0: a is null and b isn't; or the first code
      point that's different is less in A than in B; or b starts with a and is
      longer than a. Greater than 0: b is null and a isn't; or the first code
      point that's different is greater in A than in B; or a starts with b and
      is longer than b.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)'>
    <summary>Encodes a string in UTF-8 as a byte array.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>The string encoded in UTF-8.
    </returns>
    <exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)'>
    <summary>Encodes a string in UTF-8 as a byte array.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param>
    <returns>The string encoded in UTF-8.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)'>
    <summary>Calculates the number of bytes needed to encode a string in UTF-8.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='replace'>If true, treats unpaired surrogate code points as having 3 UTF-8 bytes
      (the UTF-8 length of the replacement character U+FFFD).
    </param>
    <returns>The number of bytes needed to encode the given string in UTF-8, or -1 if
      the string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)'>
    <summary>Generates a text string from a UTF-8 byte array.
    </summary>
    <param name='bytes'>A byte array containing text encoded in UTF-8.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>A string represented by the UTF-8 byte array.
    </returns>
    <exception cref='T:System.ArgumentException'>The string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)'>
    <summary>Generates a text string from a portion of a UTF-8 byte array.
    </summary>
    <param name='bytes'>A byte array containing text encoded in UTF-8.
    </param>
    <param name='offset'>Offset into the byte array to start reading.
    </param>
    <param name='bytesCount'>Length, in bytes, of the UTF-8 string.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>A string represented by the UTF-8 byte array.
    </returns>
    <exception cref='T:System.ArgumentException'>The portion of the byte array is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      "data" .
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a data stream.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this function
      will read until the end of the stream.
    </param>
    <param name='builder'>A string builder object where the resulting string will be stored.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when an unpaired surrogate code point
      is seen.
    </param>
    <returns>0 if the entire string was read without errors, -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false, or -2 if the end of the stream was reached before the last
      character was read completely (which is only the case if
      <paramref name='bytesCount'/>
       is 0 or greater).
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a byte array.
    </summary>
    <param name='data'>A byte array containing a UTF-8 string.
    </param>
    <param name='offset'>Offset into the byte array to start reading.
    </param>
    <param name='bytesCount'>Length, in bytes, of the UTF-8 string.
    </param>
    <param name='builder'>A string builder object where the resulting string will be stored.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param>
    <returns>0 if the entire string was read without errors, or -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      <paramref name='data'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)'>
    <summary>Reads a string in UTF-8 encoding from a data stream in full and returns
      that string. Replaces invalid encoding with the replacement character
      (U+FFFD).
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <returns>The string read.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)'>
    <summary>Reads a string in UTF-8 encoding from a data stream and returns that
      string.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
    <param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this function
      will read until the end of the stream.
    </param>
    <param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, throws an error if an unpaired surrogate code point is
      seen.
    </param>
    <returns>The string read.
    </returns>
    <exception cref='T:System.IO.IOException'>An I/O error occurred; or, the string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)'>
    <summary>Returns a string with the basic upper-case letters A to Z (U+0041 to
      U+005A) converted to lower-case. Other characters remain unchanged.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.ToUpperCaseAscii(System.String)'>
    <summary>Returns a string with the basic lower-case letters A to Z (U+0061 to
      U+007A) converted to upper-case. Other characters remain unchanged.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)'>
    <summary>Writes a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>0 if the entire string was written; or -1 if the string contains an
      unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)'>
    <summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='offset'>The zero-based index where the string portion to write begins.
    </param>
    <param name='length'>The length of the string portion to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception>
  </doc>
  <doc name='M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)'>
    <summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary>
    <param name='str'>A string to write.
    </param>
    <param name='offset'>The zero-based index where the string portion to write begins.
    </param>
    <param name='length'>The length of the string portion to write.
    </param>
    <param name='stream'>A writable data stream.
    </param>
    <param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param>
    <param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param>
    <returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns>
  </doc>
  <doc name='T:PeterO.DisposableList`1'>
    <summary>Holds a list of disposable objects, which can all be disposed at once when
      this object is disposed.
    </summary>
    <typeparam name='T'>Any object type that implements IDisposable.
    </typeparam>
  </doc>
  <doc name='M:PeterO.DisposableList`1.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.DisposableList`1'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.DisposableList`1.Add(`0)'>
    <summary>Not documented yet.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
  </doc>
  <doc name='M:PeterO.DisposableList`1.Clear'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.DisposableList`1.Contains(`0)'>
    <summary>Not documented yet.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.DisposableList`1.CopyTo(`0[],System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>A T[] object.
    </param>
    <param name='arrayIndex'>Zero-based index into the array to start copying items.
    </param>
  </doc>
  <doc name='P:PeterO.DisposableList`1.Count'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.DisposableList`1.Dispose'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.DisposableList`1.GetEnumerator'>
    <summary>Not documented yet.
    </summary>
    <returns>An IEnumerator(T) object.
    </returns>
  </doc>
  <doc name='M:PeterO.DisposableList`1.IndexOf(`0)'>
    <summary>Not documented yet.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.DisposableList`1.Insert(System.Int32,`0)'>
    <summary>Not documented yet.
    </summary>
    <param name='index'>Zero-based index into the list.
    </param>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
  </doc>
  <doc name='P:PeterO.DisposableList`1.IsReadOnly'>
    <summary>Gets a value indicating whether this list is read only.
    </summary>
    <value><c>true</c> If this list is read only; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.DisposableList`1.Item(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a 32-bit signed integer.
    </param>
    <returns>A T object.
    </returns>
  </doc>
  <doc name='M:PeterO.DisposableList`1.Remove(`0)'>
    <summary>Not documented yet.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.DisposableList`1.RemoveAt(System.Int32)'>
    <summary>Removes an item at a given index from the list.
    </summary>
    <param name='index'>Zero-based index into the list.
    </param>
  </doc>
  <doc name='T:PeterO.DisposableLists'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.DisposableLists.Create'>
    <summary>Not documented yet.
    </summary>
    <returns>A DisposableList(IDisposable) object.
    </returns>
  </doc>
  <doc name='M:PeterO.DisposableLists.Create``1(``0)'>
    <summary>Not documented yet.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is a T object.
    </param>
    <typeparam name='T'>Any object type that implements IDisposable.
    </typeparam>
    <returns>A DisposableList(T) object.
    </returns>
  </doc>
  <doc name='M:PeterO.DoubleComparer.GetHashCode(System.Double)'>
    <summary>Returns the hash code for this instance.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is not documented yet.
    </param>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='T:PeterO.ExtendedDecimal'>
    <summary><para><b>This class is largely obsolete. It will be replaced by a new version
          of this class in a different namespace/package and library, called
          <c>PeterO.Numbers.EDecimal</c> in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c> </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.EDecimal</c> in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java). This new class can be used in the
          <c>CBORObject.FromObject(object)</c> method (by including the new library in your code, among other
          things).</b> </para>
       Represents an arbitrary-precision decimal floating-point number.
      <para><b>About decimal arithmetic</b> </para>
      <para>Decimal (base-10) arithmetic, such as that provided by this class, is
        appropriate for calculations involving such real-world data as prices
        and other sums of money, tax rates, and measurements. These calculations
        often involve multiplying or dividing one decimal with another decimal,
        or performing other operations on decimal numbers. Many of these
        calculations also rely on rounding behavior in which the result after
        rounding is a decimal number (for example, multiplying a price by a
        premium rate, then rounding, should result in a decimal amount of
        money).
      </para>
      <para>On the other hand, most implementations of
        <c>float</c> and
        <c>double</c> , including in C# and Java, store numbers in a binary (base-2)
        floating-point format and use binary floating-point arithmetic. Many
        decimal numbers can't be represented exactly in binary floating-point
        format (regardless of its length). Applying binary arithmetic to numbers
        intended to be decimals can sometimes lead to unintuitive results, as is
        shown in the description for the FromDouble() method of this class.
      </para>
      <para><b>About ExtendedDecimal instances</b> </para>
      <para>Each instance of this class consists of an integer mantissa and an
        integer exponent, both arbitrary-precision. The value of the number
        equals mantissa * 10^exponent.
      </para>
      <para>The mantissa is the value of the digits that make up a number, ignoring
        the decimal point and exponent. For example, in the number 2356.78, the
        mantissa is 235678. The exponent is where the "floating" decimal point
        of the number is located. A positive exponent means "move it to the
        right", and a negative exponent means "move it to the left." In the
        example 2, 356.78, the exponent is -2, since it has 2 decimal places and
        the decimal point is "moved to the left by 2." Therefore, in the
        arbitrary-precision decimal representation, this number would be stored
        as 235678 * 10^-2.
      </para>
      <para>The mantissa and exponent format preserves trailing zeros in the
        number's value. This may give rise to multiple ways to store the same
        value. For example, 1.00 and 1 would be stored differently, even though
        they have the same value. In the first case, 100 * 10^-2 (100 with
        decimal point moved left by 2), and in the second case, 1 * 10^0 (1 with
        decimal point moved 0).
      </para>
      <para>This class also supports values for negative zero, not-a-number (NaN)
        values, and infinity.
        <b>Negative zero</b> is generally used when a negative number is rounded to 0; it has the
        same mathematical value as positive zero.
        <b>Infinity</b> is generally used when a non-zero number is divided by zero, or when a
        very high number can't be represented in a given exponent range.
        <b>Not-a-number</b> is generally used to signal errors.
      </para>
      <para><b>Errors and Exceptions</b> </para>
      <para>Passing a signaling NaN to any arithmetic operation shown here will
        signal the flag FlagInvalid and return a quiet NaN, even if another
        operand to that operation is a quiet NaN, unless noted otherwise.
      </para>
      <para>Passing a quiet NaN to any arithmetic operation shown here will return a
        quiet NaN, unless noted otherwise. Invalid operations will also return a
        quiet NaN, as stated in the individual methods.
      </para>
      <para>Unless noted otherwise,passing a null arbitrary-precision decimal
        argument to any method here will throw an exception.
      </para>
      <para>When an arithmetic operation signals the flag FlagInvalid, FlagOverflow,
        or FlagDivideByZero, it will not throw an exception too, unless the
        flag's trap is enabled in the precision context (see EContext's Traps
        property).
      </para>
      <para>If an operation requires creating an intermediate value that might be
        too big to fit in memory (or might require more than 2 gigabytes of
        memory to store -- due to the current use of a 32-bit integer internally
        as a length), the operation may signal an invalid-operation flag and
        return not-a-number (NaN). In certain rare cases, the CompareTo method
        may throw OutOfMemoryException (called OutOfMemoryError in Java) in the
        same circumstances.
      </para>
      <para><b>Serialization</b> </para>
      <para>An arbitrary-precision decimal value can be serialized (converted to a
        stable format) in one of the following ways:
      </para>
      <list>
        <item>By calling the toString() method, which will always return distinct
          strings for distinct arbitrary-precision decimal values.
        </item>
        <item>By calling the UnsignedMantissa, Exponent, and IsNegative properties,
          and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods.
          The return values combined will uniquely identify a particular
          arbitrary-precision decimal value.
        </item>
      </list>
      <para><b>Thread safety</b> </para>
      <para>Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
      <para><b>Comparison considerations</b> </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. The CompareTo method compares the mathematical values of
        the two instances passed to it (and considers two different NaN values
        as equal), while two instances with the same mathematical value, but
        different exponents, will be considered unequal under the Equals method.

      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.CompareTo(PeterO.ExtendedDecimal)'>
    <summary>Compares this extended decimal to another.
    </summary>
    <param name='other'>The parameter
      <paramref name='other'/>
       is an ExtendedDecimal object.
    </param>
    <returns>Less than 0 if this value is less than, 0 if equal to, or greater than 0
      if greater than the other extended decimal.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.Create(PeterO.BigInteger,PeterO.BigInteger)'>
    <summary>Creates a number with the value exponent*10^mantissa.
    </summary>
    <param name='mantissa'>The un-scaled value.
    </param>
    <param name='exponent'>The decimal exponent.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='mantissa'/>
       or
      <paramref name='exponent'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.Equals(PeterO.ExtendedDecimal)'>
    <summary>Determines whether this object's mantissa and exponent are equal to those
      of another object.
    </summary>
    <param name='other'>An arbitrary-precision decimal number.
    </param>
    <returns><c>true</c> if this object's mantissa and exponent are equal to those of another
      object; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.Equals(System.Object)'>
    <summary>Determines whether this object's mantissa and exponent are equal to those
      of another object and that other object is an arbitrary-precision decimal
      number.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedDecimal.Exponent'>
    <summary>Gets this object's exponent. This object's value will be an integer if the
      exponent is positive or zero.
    </summary>
    <value>This object's exponent. This object's value will be an integer if the
      exponent is positive or zero.
    </value>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.FromString(System.String)'>
    <summary>Creates a decimal number from a text string that represents a number. See
      <c>FromString(String, int, int, EContext)</c> for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
    <exception cref='T:System.FormatException'>The parameter
      <paramref name='str'/>
       is not a correctly formatted number string.
    </exception>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.GetHashCode'>
    <summary>Calculates this object's hash code. No application or process IDs are used
      in the hash code calculation.
    </summary>
    <returns>This object's hash code.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.IsInfinity'>
    <summary>Gets a value indicating whether this object is positive or negative
      infinity.
    </summary>
    <returns><c>true</c> if this object is positive or negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.IsNaN'>
    <summary>Gets a value indicating whether this object is not a number (NaN).
    </summary>
    <returns><c>true</c> if this object is not a number (NaN); otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedDecimal.IsNegative'>
    <summary>Gets a value indicating whether this object is negative, including
      negative zero.
    </summary>
    <value><c>true</c> If this object is negative, including negative zero; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.IsQuietNaN'>
    <summary>Gets a value indicating whether this object is a quiet not-a-number value.

    </summary>
    <returns><c>true</c> if this object is a quiet not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedDecimal.Mantissa'>
    <summary>Gets this object's un-scaled value.
    </summary>
    <value>This object's un-scaled value. Will be negative if this object's value is
      negative (including a negative NaN).
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedDecimal.NaN'>
    <summary>A not-a-number value.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedDecimal.NegativeInfinity'>
    <summary>Negative infinity, less than any other number.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedDecimal.NegativeZero'>
    <summary>Represents the number negative zero.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedDecimal.One'>
    <summary>Represents the number 1.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedDecimal.PositiveInfinity'>
    <summary>Positive infinity, greater than any other number.
    </summary>
  </doc>
  <doc name='P:PeterO.ExtendedDecimal.Sign'>
    <summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary>
    <value>This value's sign: -1 if negative; 1 if positive; 0 if zero.
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedDecimal.SignalingNaN'>
    <summary>A not-a-number value that signals an invalid operation flag when it's
      passed as an argument to any arithmetic operation in arbitrary-precision
      decimal.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedDecimal.Ten'>
    <summary>Represents the number 10.
    </summary>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.ToDouble'>
    <summary>Converts this value to a 64-bit floating-point number. The half-even
      rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 64-bit floating point
        number's mantissa for a quiet NaN, and clears it for a signaling NaN.
        Then the next highest bit of the mantissa is cleared for a quiet NaN,
        and set for a signaling NaN. Then the other bits of the mantissa are set
        to the lowest bits of this object's unsigned mantissa.
      </para>
    </summary>
    <returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.ToSingle'>
    <summary>Converts this value to a 32-bit floating-point number. The half-even
      rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's mantissa for a quiet NaN, and clears it for a signaling NaN.
        Then the next highest bit of the mantissa is cleared for a quiet NaN,
        and set for a signaling NaN. Then the other bits of the mantissa are set
        to the lowest bits of this object's unsigned mantissa.
      </para>
    </summary>
    <returns>The closest 32-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedDecimal.ToString'>
    <summary>Converts this value to a string. Returns a value compatible with this
      class's FromString method.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedDecimal.UnsignedMantissa'>
    <summary>Gets the absolute value of this object's un-scaled value.
    </summary>
    <value>The absolute value of this object's un-scaled value.
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedDecimal.Zero'>
    <summary>Represents the number 0.
    </summary>
  </doc>
  <doc name='T:PeterO.ExtendedFloat'>
    <summary><para><b>This class is largely obsolete. It will be replaced by a new version
          of this class in a different namespace/package and library, called
          <c>PeterO.Numbers.EFloat</c> in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c> </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.EFloat</c> in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java). This new class can be used in the
          <c>CBORObject.FromObject(object)</c> method (by including the new library in your code, among other
          things).</b> </para>
      <para>Represents an arbitrary-precision binary floating-point number. Consists
        of an integer mantissa and an integer exponent, both
        arbitrary-precision. The value of the number equals mantissa *
        2^exponent. This class also supports values for negative zero,
        not-a-number (NaN) values, and infinity.
      </para>
      <para>Passing a signaling NaN to any arithmetic operation shown here will
        signal the flag FlagInvalid and return a quiet NaN, even if another
        operand to that operation is a quiet NaN, unless noted otherwise.
      </para>
      <para>Passing a quiet NaN to any arithmetic operation shown here will return a
        quiet NaN, unless noted otherwise.
      </para>
      <para>Unless noted otherwise,passing a null arbitrary-precision binary float
        argument to any method here will throw an exception.
      </para>
      <para>When an arithmetic operation signals the flag FlagInvalid, FlagOverflow,
        or FlagDivideByZero, it will not throw an exception too, unless the
        operation's trap is enabled in the precision context (see
        PrecisionContext's Traps property).
      </para>
      <para>An arbitrary-precision binary float value can be serialized in one of
        the following ways:
      </para>
      <list>
        <item>By calling the toString() method. However, not all strings can be
          converted back to an arbitrary-precision binary float without loss,
          especially if the string has a fractional part.
        </item>
        <item>By calling the UnsignedMantissa, Exponent, and IsNegative properties,
          and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods.
          The return values combined will uniquely identify a particular
          arbitrary-precision binary float value.
        </item>
      </list>
      <para>If an operation requires creating an intermediate value that might be
        too big to fit in memory (or might require more than 2 gigabytes of
        memory to store -- due to the current use of a 32-bit integer internally
        as a length), the operation may signal an invalid-operation flag and
        return not-a-number (NaN). In certain rare cases, the CompareTo method
        may throw OutOfMemoryException (called OutOfMemoryError in Java) in the
        same circumstances.
      </para>
      <para><b>Thread safety:</b> Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.CompareTo(PeterO.ExtendedFloat)'>
    <summary>Compares this extended float to another.
    </summary>
    <param name='other'>The parameter
      <paramref name='other'/>
       is not documented yet.
    </param>
    <returns>Less than 0 if this value is less than, 0 if equal to, or greater than 0
      if greater than the other value.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.Create(PeterO.BigInteger,PeterO.BigInteger)'>
    <summary>Creates a number with the value exponent*2^mantissa.
    </summary>
    <param name='mantissa'>The un-scaled value.
    </param>
    <param name='exponent'>The binary exponent.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.Create(System.Int32,System.Int32)'>
    <summary>Creates a number with the value exponent*2^mantissa.
    </summary>
    <param name='mantissaSmall'>The un-scaled value.
    </param>
    <param name='exponentSmall'>The binary exponent.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.Equals(PeterO.ExtendedFloat)'>
    <summary>Determines whether this object's mantissa and exponent are equal to those
      of another object.
    </summary>
    <param name='other'>An arbitrary-precision binary float.
    </param>
    <returns><c>true</c> if this object's mantissa and exponent are equal to those of another
      object; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='other'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.Equals(System.Object)'>
    <summary>Determines whether this object's mantissa and exponent are equal to those
      of another object and that other object is an arbitrary-precision decimal
      number.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.EqualsInternal(PeterO.ExtendedFloat)'>
    <summary>Determines whether this object's mantissa and exponent are equal to those
      of another object.
    </summary>
    <param name='otherValue'>An arbitrary-precision binary float.
    </param>
    <returns><c>true</c> if this object's mantissa and exponent are equal to those of another
      object; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='otherValue'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.ExtendedFloat.Exponent'>
    <summary>Gets this object's exponent. This object's value will be an integer if the
      exponent is positive or zero.
    </summary>
    <value>This object's exponent. This object's value will be an integer if the
      exponent is positive or zero.
    </value>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.FromString(System.String)'>
    <summary>Creates a binary float from a text string that represents a number.
    </summary>
    <param name='str'>A text string containing the number to convert.
    </param>
    <returns>The parsed number, converted to arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.FromString(System.String,System.Int32,System.Int32,PeterO.PrecisionContext)'>
    <summary>Creates a binary float from a text string that represents a number. Note
      that if the string contains a negative exponent, the resulting value might
      not be exact, in which case the resulting binary float will be an
      approximation of this decimal number's value. (NOTE: This documentation
      previously said the binary float will contain enough precision to
      accurately convert it to a 32-bit or 64-bit floating point number. Due to
      double rounding, this will generally not be the case for certain numbers
      converted from decimal to ExtendedFloat via this method and in turn
      converted to
      <c>double</c> or
      <c>float</c> .)
      <para>The format of the string generally consists of:
      </para>
      <list type=''>
        <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if
          '-' , the value is negative.)
        </item>
        <item>One or more digits, with a single optional decimal point after the
          first digit and before the last digit.
        </item>
        <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-" (negative
          exponent) plus one or more digits specifying the exponent.
        </item>
      </list>
      <para>The string can also be "-INF", "-Infinity", "Infinity", "INF", quiet NaN
        ("NaN") followed by any number of digits, or signaling NaN ("sNaN")
        followed by any number of digits, all in any combination of upper and
        lower case.
      </para>
      <para>All characters mentioned above are the corresponding characters in the
        Basic Latin range. In particular, the digits must be the basic digits 0
        to 9 (U+0030 to U+0039). The string is not allowed to contain white
        space characters, including spaces.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <param name='ctx'>A PrecisionContext object specifying the precision, rounding, and exponent
      range to apply to the parsed number. Can be null.
    </param>
    <returns>The parsed number, converted to arbitrary-precision binary float.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='str'/>
       's length, or
      <paramref name='str'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.GetHashCode'>
    <summary>Calculates this object's hash code. No application or process IDs are used
      in the hash code calculation.
    </summary>
    <returns>This object's hash code.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.IsInfinity'>
    <summary>Gets a value indicating whether this object is positive or negative
      infinity.
    </summary>
    <returns><c>true</c> if this object is positive or negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.IsNaN'>
    <summary>Returns whether this object is a not-a-number value.
    </summary>
    <returns><c>true</c> if this object is a not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedFloat.IsNegative'>
    <summary>Gets a value indicating whether this object is negative, including
      negative zero.
    </summary>
    <value><c>true</c> If this object is negative, including negative zero; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.IsNegativeInfinity'>
    <summary>Returns whether this object is negative infinity.
    </summary>
    <returns><c>true</c> if this object is negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.IsPositiveInfinity'>
    <summary>Returns whether this object is positive infinity.
    </summary>
    <returns><c>true</c> if this object is positive infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.IsQuietNaN'>
    <summary>Gets a value indicating whether this object is a quiet not-a-number value.

    </summary>
    <returns><c>true</c> if this object is a quiet not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.IsSignalingNaN'>
    <summary>Gets a value indicating whether this object is a signaling not-a-number
      value.
    </summary>
    <returns><c>true</c> if this object is a signaling not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedFloat.Mantissa'>
    <summary>Gets this object's un-scaled value.
    </summary>
    <value>This object's un-scaled value. Will be negative if this object's value is
      negative (including a negative NaN).
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedFloat.NaN'>
    <summary>A not-a-number value.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedFloat.NegativeInfinity'>
    <summary>Negative infinity, less than any other number.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedFloat.NegativeZero'>
    <summary>Represents the number negative zero.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedFloat.One'>
    <summary>Represents the number 1.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedFloat.PositiveInfinity'>
    <summary>Positive infinity, greater than any other number.
    </summary>
  </doc>
  <doc name='P:PeterO.ExtendedFloat.Sign'>
    <summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary>
    <value>This value's sign: -1 if negative; 1 if positive; 0 if zero.
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedFloat.SignalingNaN'>
    <summary>A not-a-number value that signals an invalid operation flag when it's
      passed as an argument to any arithmetic operation in arbitrary-precision
      binary float.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedFloat.Ten'>
    <summary>Represents the number 10.
    </summary>
  </doc>
  <doc name='M:PeterO.ExtendedFloat.ToString'>
    <summary>Converts this value to a string.
    </summary>
    <returns>A string representation of this object. The value is converted to decimal
      and the decimal form of this number's value is returned.
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedFloat.UnsignedMantissa'>
    <summary>Gets the absolute value of this object's un-scaled value.
    </summary>
    <value>The absolute value of this object's un-scaled value.
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedFloat.Zero'>
    <summary>Represents the number 0.
    </summary>
  </doc>
  <doc name='T:PeterO.ExtendedRational'>
    <summary><para><b>This class is largely obsolete. It will be replaced by a new version
          of this class in a different namespace/package and library, called
          <c>PeterO.Numbers.ERational</c> in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c> </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.ERational</c> in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java). This new class can be used in the
          <c>CBORObject.FromObject(object)</c> method (by including the new library in your code, among other
          things).</b> </para>
       Arbitrary-precision rational number. This class can't be inherited; this
      is a change in version 2.0 from previous versions, where the class was
      inadvertently left inheritable.
      <para><b>Thread safety:</b> Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.ExtendedRational.#ctor(PeterO.BigInteger,PeterO.BigInteger)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.ExtendedRational'/>
       class.
    </summary>
    <param name='numerator'>An arbitrary-precision integer.
    </param>
    <param name='denominator'>Another arbitrary-precision integer.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='numerator'/>
       or
      <paramref name='denominator'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.ExtendedRational.CompareTo(PeterO.ExtendedRational)'>
    <summary>Compares this value to another.
    </summary>
    <param name='other'>The parameter
      <paramref name='other'/>
       is an ExtendedRational object.
    </param>
    <returns>Less than 0 if this value is less than, 0 if equal to, or greater than 0
      if greater than the other value.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedRational.Create(PeterO.BigInteger,PeterO.BigInteger)'>
    <summary>Creates a rational number with the given numerator and denominator.
    </summary>
    <param name='numerator'>An arbitrary-precision integer.
    </param>
    <param name='denominator'>Another arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedRational.Create(System.Int32,System.Int32)'>
    <summary>Creates a rational number with the given numerator and denominator.
    </summary>
    <param name='numeratorSmall'>The parameter
      <paramref name='numeratorSmall'/>
       is a 32-bit signed integer.
    </param>
    <param name='denominatorSmall'>The parameter
      <paramref name='denominatorSmall'/>
       is a 32-bit signed integer.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedRational.Denominator'>
    <summary>Gets this object's denominator.
    </summary>
    <value>This object's denominator.
    </value>
  </doc>
  <doc name='M:PeterO.ExtendedRational.Equals(PeterO.ExtendedRational)'>
    <summary>Checks whether this and another value are equal.
    </summary>
    <param name='other'>The parameter
      <paramref name='other'/>
       is an ExtendedRational object.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedRational.Equals(System.Object)'>
    <summary>Checks whether this and another value are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ExtendedRational.GetHashCode'>
    <summary>Calculates the hash code for this object. No application or process IDs
      are used in the hash code calculation.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedRational.IsFinite'>
    <summary>Gets a value indicating whether this object is finite (not infinity or
      NaN).
    </summary>
    <value><c>true</c> If this object is finite (not infinity or NaN); otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.ExtendedRational.IsNegative'>
    <summary>Gets a value indicating whether this object's value is negative (including
      negative zero).
    </summary>
    <value><c>true</c> If this object's value is negative; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.ExtendedRational.IsZero'>
    <summary>Gets a value indicating whether this object's value equals 0.
    </summary>
    <value><c>true</c> If this object's value equals 0; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedRational.NaN'>
    <summary>A not-a-number value.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedRational.NegativeInfinity'>
    <summary>Negative infinity, less than any other number.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedRational.NegativeZero'>
    <summary>A rational number for negative zero.
    </summary>
  </doc>
  <doc name='P:PeterO.ExtendedRational.Numerator'>
    <summary>Gets this object's numerator.
    </summary>
    <value>This object's numerator. If this object is a not-a-number value, returns
      the diagnostic information (which will be negative if this object is
      negative).
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedRational.One'>
    <summary>The rational number one.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedRational.PositiveInfinity'>
    <summary>Positive infinity, greater than any other number.
    </summary>
  </doc>
  <doc name='P:PeterO.ExtendedRational.Sign'>
    <summary>Gets the sign of this rational number.
    </summary>
    <value>Zero if this value is zero or negative zero; -1 if this value is less than
      0; and 1 if this value is greater than 0.
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedRational.SignalingNaN'>
    <summary>A signaling not-a-number value.
    </summary>
  </doc>
  <doc name='F:PeterO.ExtendedRational.Ten'>
    <summary>The rational number ten.
    </summary>
  </doc>
  <doc name='M:PeterO.ExtendedRational.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A string representation of this object. The result can be Infinity, NaN,
      or sNaN (with a minus sign before it for negative values), or a number of
      the following form: [-]numerator/denominator.
    </returns>
  </doc>
  <doc name='P:PeterO.ExtendedRational.UnsignedNumerator'>
    <summary>Gets this object's numerator with the sign removed.
    </summary>
    <value>This object's numerator. If this object is a not-a-number value, returns
      the diagnostic information.
    </value>
  </doc>
  <doc name='F:PeterO.ExtendedRational.Zero'>
    <summary>A rational number for zero.
    </summary>
  </doc>
  <doc name='T:PeterO.IByteReader'>
    <summary>A generic interface for reading data one byte at a time.
    </summary>
  </doc>
  <doc name='M:PeterO.IByteReader.ReadByte'>
    <summary>Reads a byte from the data source.
    </summary>
    <returns>The byte read (from 0 through 255), or -1 if the end of the source is
      reached.
    </returns>
  </doc>
  <doc name='T:PeterO.IByteWriter'>
    <summary>A generic interface for writing bytes of data.
    </summary>
  </doc>
  <doc name='M:PeterO.IByteWriter.WriteByte(System.Int32)'>
    <summary>Writes an 8-bit byte to a data source.
    </summary>
    <param name='b'>Byte to write to the data source. Only the lower 8 bits of this value are
      used.
    </param>
  </doc>
  <doc name='T:PeterO.IMarkableCharacterInput'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.GetMarkPosition'>
    <summary>Gets the zero-based character position in the stream from the last-set
      mark.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.MoveBack(System.Int32)'>
    <summary>Moves the stream position back the given number of characters.
    </summary>
    <param name='count'>The parameter
      <paramref name='count'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.SetHardMark'>
    <summary>Sets a mark on the stream's current position.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.SetMarkPosition(System.Int32)'>
    <summary>Sets the stream's position from the last set mark.
      <param name='pos'>Zero-based character offset from the last set mark.
      </param>
    </summary>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.SetSoftMark'>
    <summary>If no mark is set, sets a mark on the stream, and characters read before
      the currently set mark are no longer available, while characters read
      after will be available if MoveBack is called. Otherwise, behaves like
      GetMarkPosition.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.getMarkPosition'>
    <summary>Gets the zero-based character position in the stream from the last-set
      mark.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.moveBack(System.Int32)'>
    <summary>Moves the stream position back the given number of characters.
    </summary>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.setHardMark'>
    <summary>Sets a mark on the stream's current position.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.setMarkPosition(System.Int32)'>
    <summary>Sets the stream's position from the last set mark.
      <param name='pos'>Zero-based character offset from the last set mark.
      </param>
    </summary>
  </doc>
  <doc name='M:PeterO.IMarkableCharacterInput.setSoftMark'>
    <summary>If no mark is set, sets a mark on the stream, and characters read before
      the currently set mark are no longer available, while characters read
      after will be available if moveBack is called. Otherwise, behaves like
      getMarkPosition.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='T:PeterO.IReader'>
    <summary>A generic interface for reading bytes of data from a data source.
    </summary>
  </doc>
  <doc name='M:PeterO.IReader.Read(System.Byte[],System.Int32,System.Int32)'>
    <summary>Reads a portion of a byte array from the data source.
    </summary>
    <param name='bytes'>A byte array which will contain the data that was read from the data
      source.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='bytes'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='bytes'/>
       (but not more than
      <paramref name='bytes'/>
       's length).
    </param>
    <returns>The number of bytes read from the data source. Can be less than "length"
      if the end of the stream was reached.
    </returns>
    <exception cref='T:System.ArgumentNullException'>Should be thrown if the parameter "bytes" is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Should be thrown if either "offset" or "length" is less than 0 or greater
      than "bytes" 's length, or "bytes" 's length minus "offset" is less than
      "length".
    </exception>
  </doc>
  <doc name='T:PeterO.IStructure'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.IStructure.Read(PeterO.BinaryIO)'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.IStructure.Read(System.IO.Stream)'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.IStructure.Write(PeterO.BinaryIO)'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.IStructure.Write(System.IO.Stream)'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='T:PeterO.IWriter'>
    <summary>A generic interface for writing bytes of data.
    </summary>
  </doc>
  <doc name='M:PeterO.IWriter.Write(System.Byte[],System.Int32,System.Int32)'>
    <summary>Writes a portion of a byte array to the data source.
    </summary>
    <param name='bytes'>A byte array containing the data to write.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='bytes'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='bytes'/>
       (but not more than
      <paramref name='bytes'/>
       's length).
    </param>
  </doc>
  <doc name='T:PeterO.IniEntry'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.IniEntry.#ctor(PeterO.IniEntry)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.IniEntry'/>
       class.
    </summary>
    <param name='entry'>The parameter
      <paramref name='entry'/>
       is an IniEntry object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='entry'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.IniEntry.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.IniEntry'/>
       class.
    </summary>
    <param name='comment'>The parameter
      <paramref name='comment'/>
       is a text string.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='comment'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.IniEntry.#ctor(System.String,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.IniEntry'/>
       class.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='key'/>
       or
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.IniEntry.IsComment'>
    <summary>Gets a value indicating whether this entry is a comment line.
    </summary>
    <value><c>true</c> If this entry is a comment line; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.IniEntry.Key'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.IniEntry.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='P:PeterO.IniEntry.Value'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='T:PeterO.IniFile'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.IniFile.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.IniFile'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.IniFile.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.IniFile'/>
       class.
    </summary>
    <param name='path'>The parameter
      <paramref name='path'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.IniFile.#ctor(System.String,PeterO.IniMergeBehavior)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.IniFile'/>
       class.
    </summary>
    <param name='path'>The parameter
      <paramref name='path'/>
       is a text string.
    </param>
    <param name='behavior'>The parameter
      <paramref name='behavior'/>
       is an IniMergeBehavior object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='path'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.IniFile.AddSection(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='sectionName'>The parameter
      <paramref name='sectionName'/>
       is a text string.
    </param>
    <returns>An IniSection object.
    </returns>
  </doc>
  <doc name='M:PeterO.IniFile.AddSection(System.String,PeterO.IniMergeBehavior)'>
    <summary>Not documented yet.
    </summary>
    <param name='sectionName'>The parameter
      <paramref name='sectionName'/>
       is a text string.
    </param>
    <param name='behavior'>The parameter
      <paramref name='behavior'/>
       is an IniMergeBehavior object.
    </param>
    <returns>An IniSection object.
    </returns>
  </doc>
  <doc name='P:PeterO.IniFile.Count'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.IniFile.GetSection(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='sectionName'>The parameter
      <paramref name='sectionName'/>
       is a text string.
    </param>
    <returns>An IniSection object.
    </returns>
  </doc>
  <doc name='M:PeterO.IniFile.GetValue(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='sectionName'>The parameter
      <paramref name='sectionName'/>
       is a text string.
    </param>
    <param name='keyName'>The parameter
      <paramref name='keyName'/>
       is a text string.
    </param>
    <returns>A text string.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='keyName'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.IniFile.RemoveSection(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='sectionName'>The parameter
      <paramref name='sectionName'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.IniFile.Save(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='path'>The parameter
      <paramref name='path'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.IniFile.SetValue(System.String,System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='sectionName'>The parameter
      <paramref name='sectionName'/>
       is a text string.
    </param>
    <param name='keyName'>The parameter
      <paramref name='keyName'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='keyName'/>
       or
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.IniFile.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.IniFile.WriteToStream(System.IO.StreamWriter)'>
    <summary>Not documented yet.
    </summary>
    <param name='writer'>The parameter
      <paramref name='writer'/>
       is a StreamWriter object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='writer'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.IniMergeBehavior'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='F:PeterO.IniMergeBehavior.Merge'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='F:PeterO.IniMergeBehavior.NoMerge'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='T:PeterO.IniSection'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.IniSection.#ctor(PeterO.IniSection)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.IniSection'/>
       class.
    </summary>
    <param name='other'>The parameter
      <paramref name='other'/>
       is an IniSection object.
    </param>
  </doc>
  <doc name='M:PeterO.IniSection.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.IniSection'/>
       class.
    </summary>
    <param name='name'>The parameter
      <paramref name='name'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.IniSection.Add(PeterO.IniEntry)'>
    <summary>Not documented yet.
    </summary>
    <param name='entry'>The parameter
      <paramref name='entry'/>
       is an IniEntry object.
    </param>
  </doc>
  <doc name='M:PeterO.IniSection.Add(PeterO.IniEntry,PeterO.IniMergeBehavior)'>
    <summary>Adds two IniEntry objects.
    </summary>
    <param name='entry'>The parameter
      <paramref name='entry'/>
       is an IniEntry object.
    </param>
    <param name='behavior'>The parameter
      <paramref name='behavior'/>
       is an IniMergeBehavior object.
    </param>
  </doc>
  <doc name='M:PeterO.IniSection.AddComment(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='comment'>The parameter
      <paramref name='comment'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.IniSection.AddEntry(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.IniSection.AddEntry(System.String,System.String,PeterO.IniMergeBehavior)'>
    <summary>Not documented yet.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
    <param name='behavior'>The parameter
      <paramref name='behavior'/>
       is an IniMergeBehavior object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter "keyName" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.IniSection.Clear'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='P:PeterO.IniSection.Count'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.IniSection.GetValue(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='keyName'>The parameter
      <paramref name='keyName'/>
       is a text string.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='P:PeterO.IniSection.Item(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <returns>An IniEntry object.
    </returns>
  </doc>
  <doc name='P:PeterO.IniSection.Name'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.IniSection.RemoveEntry(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.IniSection.SetValue(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='keyName'>The parameter
      <paramref name='keyName'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.IniSection.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='T:PeterO.InvariantText'>
    <summary>Contains string processing operations that should be consistent regardless
      of locale. This class, along with the CulturedText class, supports the
      correct use of string functions in the framework. InvariantText is
      intended for use in locale-independent string processing, such as data and
      file system processing, while CulturedText is intended for text display.
    </summary>
  </doc>
  <doc name='M:PeterO.InvariantText.Format(System.String,System.Object[])'>
    <summary>Not documented yet.
    </summary>
    <param name='formattedText'>The parameter
      <paramref name='formattedText'/>
       is a text string.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a params object.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='T:PeterO.ListSegment`1'>
    <summary>Specifies a segment of a list defined by an offset and length. This class
      cannot be inherited.
    </summary>
    <typeparam name='T'>Any object type.
    </typeparam>
  </doc>
  <doc name='M:PeterO.ListSegment`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)'>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='start'>The parameter
      <paramref name='start'/>
       is a 32-bit signed integer.
    </param>
    <param name='count'>The parameter
      <paramref name='count'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.ListSegment`1.Add(`0)'>
    <summary>This method is not supported.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is not documented yet.
    </param>
    <exception cref='T:System.NotSupportedException'>Always thrown, because changing the size of a list segment is not
      supported.
    </exception>
  </doc>
  <doc name='M:PeterO.ListSegment`1.Clear'>
    <summary>This method is not supported.
    </summary>
  </doc>
  <doc name='M:PeterO.ListSegment`1.Contains(`0)'>
    <summary>Not documented yet.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ListSegment`1.CopyTo(`0[],System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='array'>A T[] object.
    </param>
    <param name='arrayIndex'>The parameter
      <paramref name='arrayIndex'/>
       is a 32-bit signed integer.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='array'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.ListSegment`1.Count'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.ListSegment`1.GetEnumerator'>
    <summary>Not documented yet.
    </summary>
    <returns>An IEnumerator(T) object.
    </returns>
  </doc>
  <doc name='M:PeterO.ListSegment`1.IndexOf(`0)'>
    <summary>Not documented yet.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.ListSegment`1.Insert(System.Int32,`0)'>
    <summary>This method is not supported.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
  </doc>
  <doc name='P:PeterO.ListSegment`1.IsReadOnly'>
    <summary>Gets a value indicating whether this list segment is read only.
    </summary>
    <value><c>true</c> If this list segment is read only; otherwise,
      <c>false</c> .
    </value>
    <remarks>
       The read-only status of the list segment is the same as that of the
      underlying list. However, operations that would change the list segment's
      size, such as adding and removing items, are not supported.
    </remarks>
  </doc>
  <doc name='P:PeterO.ListSegment`1.Item(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <returns>A T object.
    </returns>
  </doc>
  <doc name='P:PeterO.ListSegment`1.ListSegmentEnumerator.Current'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.ListSegment`1.ListSegmentEnumerator.Dispose'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.ListSegment`1.ListSegmentEnumerator.MoveNext'>
    <summary>Not documented yet.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ListSegment`1.ListSegmentEnumerator.Reset'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.ListSegment`1.Remove(`0)'>
    <summary>This method is not supported.
    </summary>
    <param name='item'>The parameter
      <paramref name='item'/>
       is a T object.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.ListSegment`1.RemoveAt(System.Int32)'>
    <summary>This method is not supported.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='P:PeterO.ListSegment`1.StartIndex'>
    <summary>Gets the starting index within the underlying list for this list segment.
    </summary>
    <value>The starting index within the underlying list for this list segment.
    </value>
  </doc>
  <doc name='T:PeterO.Mail.Address'>
    <summary>Represents an email address.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.Address.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.Address'/>
       class.
    </summary>
    <param name='addressValue'>An email address.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='addressValue'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The email address contains invalid syntax. For example, it doesn't contain
      an '@' sign or either side of the '@' contains invalid characters, the
      address is too long, or the address contains comments (text within
      parentheses).
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Address.Domain'>
    <summary>Gets the domain of this email address (the part after the "@" sign).
    </summary>
    <value>The domain of this email address (the part after the "@" sign).
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Address.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Address.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Address.LocalPart'>
    <summary>Gets the local part of this email address (the part before the "@" sign).
    </summary>
    <value>The local part of this email address (the part before the "@" sign).
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Address.ToString'>
    <summary>Converts this address object to a text string.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.Base64Encoder'>
    <summary>This is an internal class.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.ContentDisposition'>
    <summary>Specifies how a message body should be displayed or handled by a mail user
      agent. This type is immutable; its contents can't be changed after it's
      created. To create a changeable disposition object, use the
      DispositionBuilder class.
      <para><b>About the "filename" parameter</b> </para>
      <para>The "filename" parameter of a content disposition suggests a name to use
        when saving data to a file. For the "filename" parameter, the
        GetParameter method and Parameters property (
        <c>getParameters</c> ) method in Java) do not adapt that parameter's value using the
        ContentDisposition.MakeFilename method. Thus, for example, the
        "filename" parameter, if any, returned by this method could have an
        arbitrary length, be encoded using RFC 2047 encoded words (which some
        email and HTTP implementations still like to write out in headers, even
        though that RFC says encoded words "MUST NOT appear within a
        'quoted-string'"; see ContentDisposition.MakeFilename), or not be usable
        as is as a file name.
      </para>
      <para><b>Example:</b> An example of RFC 2047 encoded words is:
      </para>
      <para><b>=?UTF-8?Q?test?=</b> </para>
      <para>Content-Disposition header fields like the following have appeared in
        practice:
      </para>
      <para><b>Content-Disposition: attachment; filename==?UTF-8?Q?example?=</b> </para>
      <para><b>Content-Disposition: attachment; filename==?UTF-8?Q?test.png?=</b> </para>
      <para><b>Content-Disposition: attachment; filename="=?UTF-8?Q?test.png?="</b> </para>
      <para>In this implementation, the first and second of these are syntactically
        invalid, so they trigger parse errors, while the third of these is
        syntactically valid, but the "filename" parameter is treated as
        "=?UTF-8?Q?test.png?=", not "test.png" or something else -- RFC 2047
        encoded words are not decoded at the moment a content disposition is
        parsed (using the Parse method).
      </para>
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.ContentDisposition.Attachment'>
    <summary>The content disposition value "attachment".
    </summary>
  </doc>
  <doc name='P:PeterO.Mail.ContentDisposition.DispositionType'>
    <summary>Gets a string containing this object's disposition type, such as "inline"
      or "attachment". Note that under RFC 6266 sec. 4.2 and RFC 2183 sec. 2.8,
      unrecognized disposition types should be treated as "attachment".
    </summary>
    <value>A string containing this object's disposition type, such as "inline" or
      "attachment".
    </value>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetCreationDate'>
    <summary>Gets the date and time extracted from this content disposition's
      "creation-date" parameter, which specifies the date of creation of a file
      (RFC 2183 sec. 2.4). See
      <see cref='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this method's return value.
    </summary>
    <returns>The extracted date and time as an 8-element array, or
      <c>null</c> if the "creation-date" parameter doesn't exist, is an empty string, or is
      syntactically invalid, or if the parameter's year would overflow a 32-bit
      signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetFilename'>
    <summary>Gets an adapted version of the "filename" parameter in this content
      disposition object by using the "MakeFilename" method.
    </summary>
    <returns>The adapted file name in the form of a string. Returns the empty string if
      there is no "filename" parameter or that parameter is empty.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetModificationDate'>
    <summary>Gets the date and time extracted from this content disposition's
      "modification-date" parameter, which specifies the date of last
      modification of a file (RFC 2183 sec. 2.5). See
      <see cref='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this method's return value.
    </summary>
    <returns>The extracted date and time as an 8-element array, or
      <c>null</c> if the "modification-date" parameter doesn't exist, is an empty string,
      or is syntactically invalid, or if the parameter's year would overflow a
      32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetParameter(System.String)'>
    <summary>Gets a parameter from this disposition object. For the "filename"
      parameter, the value of that parameter is not adapted with the
      ContentDisposition.MakeFilename method; see the documentation for the
      ContentDisposition class.
    </summary>
    <param name='name'>The name of the parameter to get. The name will be matched using a basic
      case-insensitive comparison. (Two strings are equal in such a comparison,
      if they match after converting the basic upper-case letters A to Z (U+0041
      to U+005A) in both strings to lower case.). Can't be null.
    </param>
    <returns>The value of the parameter, or null if the parameter does not exist.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='name'/>
       is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.GetReadDate'>
    <summary>Gets the date and time extracted from this content disposition's
      "read-date" parameter, which specifies the date at which a file was last
      read (RFC 2183 sec. 2.6). See
      <see cref='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this method's return value.
    </summary>
    <returns>The extracted date and time as an 8-element array, or
      <c>null</c> if the "read-date" parameter doesn't exist, is an empty string, or is
      syntactically invalid, or if the parameter's year would overflow a 32-bit
      signed integer.
    </returns>
  </doc>
  <doc name='F:PeterO.Mail.ContentDisposition.Inline'>
    <summary>The content disposition value "inline".
    </summary>
  </doc>
  <doc name='P:PeterO.Mail.ContentDisposition.IsAttachment'>
    <summary>Gets a value indicating whether the disposition type is attachment.
    </summary>
    <value><c>true</c> If the disposition type is attachment; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.ContentDisposition.IsInline'>
    <summary>Gets a value indicating whether the disposition type is inline.
    </summary>
    <value><c>true</c> If the disposition type is inline; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.MakeFilename(System.String)'>
    <summary>Converts a file name from the Content-Disposition header to a suitable
      name for saving data to a file. This method is idempotent; that is,
      calling the method again on the result doesn't change that result.
      <para>Examples:
      </para>
      <para><c>"=?utf-8?q?hello=2Etxt?=" -&gt; "hello.txt"</c> (RFC 2047 encoding)
      </para>
      <para><c>"=?utf-8?q?long_filename?=" -&gt; "long filename"</c> (RFC 2047 encoding)
      </para>
      <para><c>"utf-8'en'hello%2Etxt" -&gt; "hello.txt"</c> (RFC 2231 encoding)
      </para>
      <para><c>"nul.txt" -&gt; "_nul.txt"</c> (Reserved name)
      </para>
      <para><c>"dir1/dir2/file" -&gt; "dir1_dir2_file"</c> (Directory separators)
      </para>
    </summary>
    <param name='str'>A string representing a file name. Can be null.
    </param>
    <returns>A string with the converted version of the file name. Among other things,
      encoded words under RFC 2047 are decoded (since they occur so frequently
      in Content-Disposition filenames); the value is decoded under RFC 2231 if
      possible; characters unsuitable for use in a filename (including the
      directory separators slash and backslash) are replaced with underscores;
      spaces and tabs are collapsed to a single space; leading and trailing
      spaces and tabs are removed; and the filename is truncated if it would
      otherwise be too long. The returned string will be in normalization form
      C. Returns the empty string if "str" is null or empty.
    </returns>
    <remarks>
      <para><b>Remark:</b> Email and HTTP headers may specify suggested filenames using the
        Content-Disposition header field's
        <c>filename</c> parameter or, in practice, the Content-Type header field's
        <c>name</c> parameter.
      </para>
      <para>Although RFC 2047 encoded words appearing in both parameters are written
        out by some implementations, this practice is discouraged by some
        (especially since the RFC itself says that encoded words "MUST NOT
        appear within a 'quoted-string'"). Nevertheless, the MakeFilename method
        has a basis in the RFCs to decode RFC 2047 encoded words (and RFC 2231
        encoding) in file names passed to this method.
      </para>
      <para>RFC 2046 sec. 4.5.1 (
        <c>application/octet-stream</c> subtype in Content-Type header field) cites an earlier RFC 1341, which
        "defined the use of a 'NAME' parameter which gave a
        <i>
           suggested
        </i>
         file name to be used if the data were written to a file". Also, RFC
        2183 sec. 2.3 (
        <c>filename</c> parameter in Content-Disposition) confirms that the "
        <i>
           suggested
        </i>
         filename" in the
        <c>filename</c> parameter "should be
        <i>
           used as a basis
        </i>
         for the actual filename, where possible", and that that file name
        should "not [be] blindly use[d]". See also RFC 6266, section 4.3, which
        discusses the use of that parameter in Hypertext Transfer Protocol
        (HTTP).
      </para>
      <para>To the extent that the "name" parameter is not allowed in message bodies
        other than those with the media type "application/octet-stream" or
        treated as that media-type, this is a deviation of RFC 2045 and 2046
        (see also RFC 2045 sec. 5, which says that "[t]here are NO globally
        meaningful parameters that apply to all media types"). (Some email
        implementations may still write out the "name" parameter, even in media
        types other than
        <c>application/octet-stream</c> and even though RFC 2046 has deprecated that parameter.)
      </para>
    </remarks>
  </doc>
  <doc name='P:PeterO.Mail.ContentDisposition.Parameters'>
    <summary>Gets a list of parameter names associated with this object and their
      values.
      <para>For the "filename" parameter, the value of that parameter is not adapted
        with the ContentDisposition.MakeFilename method; see the documentation
        for the ContentDisposition class.
      </para>
    </summary>
    <value>A read-only list of parameter names associated with this object and their
      values.
      <para>NOTE: Previous versions erroneously stated that the list will be sorted
        by name. In fact, the names will not be guaranteed to appear in any
        particular order; this is at least the case in version 0.10.0.
      </para>
    </value>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.Parse(System.String)'>
    <summary>Creates a new content disposition object from the value of a
      Content-Disposition header field.
    </summary>
    <param name='dispoValue'>The parameter
      <paramref name='dispoValue'/>
       is a text string.
    </param>
    <returns>A content disposition object, or ContentDisposition.Attachment" if
      <paramref name='dispoValue'/>
       is empty or syntactically invalid.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dispoValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.Parse(System.String,PeterO.Mail.ContentDisposition)'>
    <summary>Parses a content disposition string and returns a content disposition
      object, or the default value if the string is invalid. This method checks
      the syntactic validity of the string, but not whether it has all
      parameters it's required to have or whether the parameters themselves are
      set to valid values for the parameter.
      <para>This method assumes the given content disposition string was directly
        extracted from the Content-Disposition header field (as defined for
        email messages) and follows the syntax given in RFC 2183. Accordingly,
        among other things, the content disposition string can contain comments
        (delimited by parentheses).
      </para>
      <para>RFC 2231 extensions allow each content disposition parameter to be
        associated with a character encoding and/or language, and support
        parameter values that span two or more key-value pairs. Parameters
        making use of RFC 2231 extensions have names with an asterisk ("*").
        Such a parameter will be ignored if it is ill-formed because of RFC
        2231's rules (except for illegal percent-decoding or undecodable
        sequences for the given character enoding). Examples of RFC 2231
        extensions follow (both examples encode the same "filename" parameter):
      </para>
      <para><b>inline; filename*=utf-8'en'filename.txt</b> </para>
      <para><b>inline; filename*0*=utf-8'en'file; filename*1*=name%2Etxt</b> </para>
      <para>This implementation ignores keys (in parameter key-value pairs) that
        appear more than once in the content disposition. Nothing in RFCs 2045,
        2183, 2231, 6266, or 7231 explicitly disallows such keys, or otherwise
        specifies error-handling behavior for such keys.
      </para>
    </summary>
    <param name='dispositionValue'>A text string that should be the value of a Content-Disposition header
      field.
    </param>
    <param name='defaultValue'>The value to return in case the disposition value is syntactically
      invalid. Can be null.
    </param>
    <returns>A ContentDisposition object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dispositionValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.ToSingleLineString'>
    <summary>Converts this content disposition to a text string form suitable for
      inserting in HTTP headers. Notably, the string contains the value of a
      Content-Disposition header field (without the text necessarily starting
      with "Content-Disposition" followed by a space), and consists of a single
      line.
    </summary>
    <returns>A text string form of this content disposition.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.ContentDisposition.ToString'>
    <summary>Converts this content disposition to a text string form suitable for
      inserting in email headers. Notably, the string contains the value of a
      Content-Disposition header field (without the text necessarily starting
      with "Content-Disposition" followed by a space), and consists of one or
      more lines.
    </summary>
    <returns>A text string form of this content disposition.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.DispositionBuilder'>
    <summary>Description of DispositionBuilder.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.DispositionBuilder'/>
       class using the disposition type "attachment".
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.#ctor(PeterO.Mail.ContentDisposition)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.DispositionBuilder'/>
       class using the data from the given content disposition.
    </summary>
    <param name='mt'>The parameter
      <paramref name='mt'/>
       is a ContentDisposition object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='mt'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.DispositionBuilder'/>
       class using the given disposition type.
    </summary>
    <param name='type'>The parameter
      <paramref name='type'/>
       is a text string.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='type'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.DispositionBuilder.DispositionType'>
    <summary>Gets or sets this value's disposition type, such as "inline" or
      "attachment".
    </summary>
    <value>This value's disposition type, such as "inline" or "attachment".
    </value>
  </doc>
  <doc name='P:PeterO.Mail.DispositionBuilder.IsMultipart'>
    <summary>Gets a value indicating whether this is a multipart media type.
    </summary>
    <value><c>true</c> If this is a multipart media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.DispositionBuilder.IsText'>
    <summary>Gets a value indicating whether this is a text media type.
    </summary>
    <value><c>true</c> If this is a text media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.RemoveParameter(System.String)'>
    <summary>Removes a parameter from this content disposition. Does nothing if the
      parameter's name doesn't exist.
    </summary>
    <param name='name'>The parameter to remove. The name is compared using a basic
      case-insensitive comparison. (Two strings are equal in such a comparison,
      if they match after converting the basic upper-case letters A to Z (U+0041
      to U+005A) in both strings to lower case.).
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.SetDispositionType(System.String)'>
    <summary>Sets the disposition type, such as "inline".
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.SetParameter(System.String,System.String)'>
    <summary>Sets a parameter of this content disposition.
    </summary>
    <param name='name'>Name of the parameter to set. If this name already exists (compared using
      a basic case-insensitive comparison), it will be overwritten. (Two strings
      are equal in a basic case-insensitive comparison, if they match after
      converting the basic upper-case letters A to Z (U+0041 to U+005A) in both
      strings to lower case.).
    </param>
    <param name='value'>Value of the parameter to set.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentNullException'>Either
      <paramref name='value'/>
       or
      <paramref name='name'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='name'/>
       is empty, or it isn't a well-formed parameter name.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.ToDisposition'>
    <summary>Converts this object to an immutable ContentDisposition object.
    </summary>
    <returns>A MediaType object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.DispositionBuilder.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.EncodedWordContext'>
    <summary>Specifies the context where an encoded word under RFC 2047 can appear.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.EncodedWordContext.Comment'>
    <summary>Contains methods for parsing and matching language tags.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.EncodedWordContext.Phrase'>
    <summary>In a "word" element within a "phrase" of a structured header field.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.EncodedWordContext.Unstructured'>
    <summary>In an unstructured header field's value.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.LanguageTags'>
    <summary>Contains methods for parsing and matching language tags.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.GetLanguageList(System.String)'>
    <summary>Parses a language list from a Content-Language header field.
    </summary>
    <param name='str'>A string following the syntax of a Content-Language header field (see RFC
      3282). This is a comma-separated list of language tags. RFC 5322 comments
      (in parentheses) can appear. This parameter can be null.
    </param>
    <returns>A list of language tags. Returns an empty list if "str" is null or the
      empty string, or null if "str" syntactically invalid.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.GetRangeListWithQuality(System.String)'>
    <summary>Parses a language range list from an Accept-Language header field.
    </summary>
    <param name='str'>A string following the syntax of an Accept-Language header field (see RFC
      3282). This is a comma-separated list of language ranges, with an optional
      "quality" after the language tag (examples include "en; q=0.5" or
      "de-DE"). RFC 5322 comments (in parentheses) can appear. This parameter
      can be null.
    </param>
    <returns>A list of language ranges with their associated qualities. The list will
      be sorted in descending order by quality; if two or more language ranges
      have the same quality, they will be sorted in the order in which they
      appeared in the given string. Returns null if "str" is null or
      syntactically invalid.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.IsLanguageRange(System.String)'>
    <summary>Returns whether the given string is a basic language range under RFC 4647.
      Examples include "*", "en-us", and "fr".
    </summary>
    <param name='str'>The string to check. Can be null.
    </param>
    <returns><c>true</c> if the given string is a basic language range; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.IsLanguageRange(System.String,System.Boolean)'>
    <summary>Returns whether the given string is a basic or extended language range
      under RFC 4647. Examples of basic (and extended) language ranges include
      "*", "en-us", and "fr". Examples of extended language ranges include
      "*-de" and "it-*".
    </summary>
    <param name='str'>The string to check. Can be null.
    </param>
    <param name='extended'>Check whether the string is a basic language range if "false", or an
      extended language range if "true".
    </param>
    <returns><c>true</c> if the given string is a basic language range (depending on the
      "extended" parameter); otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.IsPotentiallyValidLanguageTag(System.String)'>
    <summary>Returns true if (1) the given string is a well-formed language tag under
      RFC 5646 (that is, the string follows the syntax given in section 2.1 of
      that RFC), and (2) the language tag contains at most one extended language
      subtag, no variant subtags with the same value, and no extension singleton
      subtags with the same value.
    </summary>
    <param name='str'>The string to check.
    </param>
    <returns><c>true</c> , if the string meets the conditions given in the summary,
      <c>false</c> otherwise.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagCase(System.String)'>
    <summary>Sets the given language tag to the case combination recommended by RFC
      5646. For example, "en-us" becomes "en-US", and "zh-hant" becomes
      "zh-Hant".
    </summary>
    <param name='str'>A string of a language tag. Can be null.
    </param>
    <returns>A text string in the recommended case combination, or null if "str" is
      null.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagFilter(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})'>
    <summary>Finds the language tags that match a priority list of basic language
      ranges.
    </summary>
    <param name='ranges'>A list of basic language ranges (see documentation for the
      "IsLanguageRange" method), which should be given in order of descending
      preference.
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <returns>A list of language tags that match the given range, in descending order of
      preference.
    </returns>
    <exception cref='T:System.ArgumentNullException'>languages" or "ranges" is null.
    </exception>
    <exception cref='T:System.ArgumentException'>ranges" contains a value that is not a basic language range, or
      "languages" contains a value that is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagFilter(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Boolean,System.Boolean)'>
    <summary>Finds the language tags that match a priority list of language ranges.
    </summary>
    <param name='ranges'>A list of language ranges (see documentation for the "IsLanguageRange"
      method), which should be given in order of descending preference.
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <returns>A list of language tags that match the given range, in descending order of
      preference.
    </returns>
    <param name='extended'>If true, the ranges in "ranges" are extended language ranges; otherwise,
      they are basic language ranges.
    </param>
    <exception cref='T:System.ArgumentException'>ranges" contains a value that is not a basic or extended language range,
      or "languages" contains a value that is not a potentially valid language
      tag.
    </exception>
    <param name='matchStarAtEnd'>The parameter
      <paramref name='matchStarAtEnd'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String)'>
    <summary>Does a language tag lookup (under RFC 4647) for a matching language tag.
    </summary>
    <param name='ranges'>A list of basic language ranges (see documentation for the
      "IsLanguageRange" method), which should be given in order of descending
      preference.
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='defaultValue'>The value to return if no matching language tag was found.
    </param>
    <returns>The matching language tag, or the parameter "defaultValue" if there is no
      matching language tag.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.String,System.Boolean)'>
    <summary>Does a language tag lookup (under RFC 4647) for a matching language tag.
    </summary>
    <param name='ranges'>A list of language ranges (see documentation for the "IsLanguageRange"
      method), which should be given in order of descending preference.
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='defaultValue'>The value to return if no matching language tag was found.
    </param>
    <param name='extended'>If true, the ranges in "ranges" are extended language ranges; otherwise,
      they are basic language ranges.
    </param>
    <returns>The matching language tag, or the parameter "defaultValue" if there is no
      matching language tag.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.String,System.Collections.Generic.IList{System.String},System.String)'>
    <summary>Does a language tag lookup (under RFC 4647) for a matching language tag.
    </summary>
    <param name='range'>A basic language range (see the documentation for "IsLanguageRange").
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='defaultValue'>The value to return if no matching language tag was found.
    </param>
    <returns>The matching language tag, or the parameter "defaultValue" if there is no
      matching language tag.
    </returns>
    <exception cref='T:System.ArgumentNullException'>languages" is null.
    </exception>
    <exception cref='T:System.ArgumentException'>range" is not a basic language range, or "languages" contains a value that
      is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.LanguageTagLookup(System.String,System.Collections.Generic.IList{System.String},System.String,System.Boolean)'>
    <summary>Does a language tag lookup (under RFC 4647) for a matching language tag.
    </summary>
    <param name='range'>A language range (see the documentation for "IsLanguageRange").
    </param>
    <param name='languages'>A list of language tags, which should be given in order of descending
      preference.
    </param>
    <param name='defaultValue'>The value to return if no matching language tag was found.
    </param>
    <param name='extended'>If true, "range" is an extended language range; otherwise, it's a are
      basic language range.
    </param>
    <returns>The matching language tag, or the parameter "defaultValue" if there is no
      matching language tag.
    </returns>
    <exception cref='T:System.ArgumentException'>range" is not a basic or extended language range, or "languages" contains
      a value that is not a potentially valid language tag.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.LanguageTags.MatchesLanguageTag(System.String,System.String)'>
    <summary>Determines whether the given language tag matches the given language
      range.
    </summary>
    <param name='range'>A basic language range (see the documentation for "IsLanguageRange").
    </param>
    <param name='tag'>A language tag.
    </param>
    <returns><c>true</c> if the language tag matches the language range by the filtering method
      under RFC 4647; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentException'>range" is not a basic language range, or "tag" is not a potentially valid
      language tag.
    </exception>
  </doc>
  <doc name='T:PeterO.Mail.MailDateTime'>
    <summary>Contains methods for parsing and generating date-time strings following
      the Internet Message Format (RFC 5322).
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.GenerateDateString(System.Int32[])'>
    <summary>Generates a date-time string following the Internet Message Format (RFC
      5322) from an 8-element array.
    </summary>
    <returns>A date-time string.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter "dateTime" is null or invalid.
    </exception>
    <param name='dateTime'>The date and time in the form of an 8-element array. See
      <see cref='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this parameter.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.GenerateDateString(System.Int32[],System.Boolean)'>
    <summary>Generates a date-time string following the Internet Message Format (RFC
      5322) from an 8-element array, optionally using a "GMT" time zone
      indicator.
    </summary>
    <returns>A date-time string.
    </returns>
    <exception cref='T:System.NotSupportedException'>The time zone offset is other than 0 and "gmt" is true.
    </exception>
    <param name='dateTime'>The date and time in the form of an 8-element array. See
      <see cref='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this parameter.
    </param>
    <param name='gmt'>If true, uses the string "GMT" as the time zone offset.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.ParseDateString(System.String)'>
    <summary>Gets the date and time extracted from a date-time string following the
      Internet Message Format (RFC 5322). However, this method does not allow
      obsolete time zone strings to appear in the date-time string. See
      <see cref='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for information on the format of this method's return value.
    </summary>
    <returns>An 8-element array containing the date and time, or
      <c>null</c> if
      <paramref name='str'/>
       is null, empty, or syntactically invalid, or if the string's year would
      overflow the range of a 32-bit signed integer.
    </returns>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'>
    <summary>Gets the date and time extracted from a date-time string following the
      Internet Message Format (RFC 5322), with an option to allow obsolete time
      zone strings to appear in the date-time string.
    </summary>
    <returns>An 8-element array containing the date and time, or
      <c>null</c> if
      <paramref name='str'/>
       is null, empty, or syntactically invalid, or if the string's year would
      overflow the range of a 32-bit signed integer. If an array is returned,
      element of that array (starting from 0) is as follows:
      <list>
        <item>0 - The year. For example, the value 2000 means 2000 C.E.
        </item>
        <item>1 - Month of the year, from 1 (January) through 12 (December).
        </item>
        <item>2 - Day of the month, from 1 through 31.
        </item>
        <item>3 - Hour of the day, from 0 through 23.
        </item>
        <item>4 - Minute of the hour, from 0 through 59.
        </item>
        <item>5 - Second of the minute, from 0 through 60 (this value can go up to
          60 to accommodate leap seconds). (Leap seconds are additional seconds
          added to adjust international atomic time, or TAI, to an approximation
          of astronomical time known as coordinated universal time, or UTC.)
        </item>
        <item>6 - Milliseconds of the second, from 0 through 999. Will always be 0.
        </item>
        <item>7 - Number of minutes to subtract from this date and time to get
          global time. This number can be positive or negative.
        </item>
      </list>
    </returns>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <param name='parseObsoleteZones'>If set to
      <c>true</c> , this method allows obsolete time zones (single-letter time zones,
      "GMT", "UT", and certain three-letter combinations) to appear in the
      date-time string.
    </param>
  </doc>
  <doc name='T:PeterO.Mail.MediaType'>
    <summary><para>Specifies what kind of data a message body is.
      </para>
      <para>A media type consists of a top-level type (the general category of the
        data), a subtype (the specific type), and an optional list of
        parameters. For example, the media type
        <c>text/plain; charset = utf-8</c> is a text media type ("text"), namely, a plain text type ("plain"), and
        the parameters say that the data uses UTF-8, a Unicode character
        encoding ("charset = utf-8"). Other top-level types include "audio",
        "video", and "application".
      </para>
      <para>A media type is sometimes known as a "MIME type", for Multipurpose
        Internet Mail Extensions, the standard that introduced media types.
      </para>
      <para>This type is immutable, meaning its values can't be changed once it' s
        created. To create a changeable media type object, use the
        MediaTypeBuilder class.
      </para>
      <para><b>Note:</b> According to RFC 2049, unrecognized subtypes of the top-level type
        <c>multipart</c> must be treated as
        <c>multipart/mixed</c> and unrecognized media types as the media type
        <c>application/octet-stream</c> .
      </para>
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.ApplicationOctetStream'>
    <summary>Specifies the media type "application/octet-stream", used for arbitrary
      binary data.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.GetCharset'>
    <summary>Gets this media type's "charset" parameter, naming a character encoding
      used to represent text in the data that uses this media type.
    </summary>
    <returns>If the "charset" parameter is present and non-empty, returns the result of
      the Encodings.ResolveAliasForEmail method for that parameter, except that
      result's basic upper-case letters A to Z (U+0041 to U+005A) are converted
      to lower case. If the "charset" parameter is absent or empty, returns the
      default value, if any, for that parameter given the media type (e.g.,
      "us-ascii" if the media type is "text/plain"; see RFC2046), or the empty
      string if there is none.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.GetParameter(System.String)'>
    <summary>Gets the value of a parameter in this media type, such as "charset" or
      "format".
    </summary>
    <param name='name'>Name of the parameter to get. The name is compared using a basic
      case-insensitive comparison. (Two strings are equal in such a comparison,
      if they match after converting the basic upper-case letters A to Z (U+0041
      to U+005A) in both strings to lower case.).
    </param>
    <returns>The value of the parameter as a string, or null if the parameter doesn't
      exist.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.IsMultipart'>
    <summary>Gets a value indicating whether this is a multipart media type.
    </summary>
    <value><c>true</c> If this is a multipart media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.IsText'>
    <summary>Gets a value indicating whether this is a text media type ("text/*").
    </summary>
    <value><c>true</c> If this is a text media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.MessageRfc822'>
    <summary>Specifies the media type "message/rfc822", used for Internet mail
      messages.
    </summary>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.Parameters'>
    <summary>Gets a list of the parameters contained in this media type object.
    </summary>
    <value>A list of the parameters contained in this media type object; the names of
      each parameter appear in an undefined order.
      <para>NOTE: Previous versions erroneously stated that the list will be sorted
        by name. In fact, the names will not be guaranteed to appear in any
        particular order; this is at least the case in version 0.10.0.
      </para>
    </value>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.Parse(System.String)'>
    <summary>Parses a media type string and returns a media type object. For further
      information, see the overload taking a MediaType parameter.
    </summary>
    <param name='mediaTypeValue'>A text string representing a media type. This media type can include
      parameters.
    </param>
    <returns>A media type object, or MediaType.TextPlainAscii if
      <paramref name='mediaTypeValue'/>
       is empty or syntactically invalid.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.Parse(System.String,PeterO.Mail.MediaType)'>
    <summary>Parses a media type string and returns a media type object, or the default
      value if the string is invalid. This method checks the syntactic validity
      of the string, but not whether it has all parameters it's required to have
      or whether the parameters themselves are set to valid values for the
      parameter.
      <para>This method assumes the given media type string was directly extracted
        from the Content-Type header field (as defined for email messages) and
        follows the syntax given in RFC 2045. Accordingly, among other things,
        the media type string can contain comments (delimited by parentheses).
      </para>
      <para>RFC 2231 extensions allow each media type parameter to be associated
        with a character encoding and/or language, and support parameter values
        that span two or more key-value pairs. Parameters making use of RFC 2231
        extensions have names with an asterisk ("*"). Such a parameter will be
        ignored if it is ill-formed because of RFC 2231's rules (except for
        illegal percent-decoding or undecodable sequences for the given
        character enoding). Examples of RFC 2231 extensions follow (both
        examples encode the same "filename" parameter):
      </para>
      <para><b>text/example; filename*=utf-8'en'filename.txt</b> </para>
      <para><b>text/example; filename*0*=utf-8'en'file; filename*1*=name%2Etxt</b> </para>
      <para>This implementation ignores keys (in parameter key-value pairs) that
        appear more than once in the media type. Nothing in RFCs 2045, 2183,
        2231, 6266, or 7231 explicitly disallows such keys, or otherwise
        specifies error-handling behavior for such keys.
      </para>
    </summary>
    <param name='str'>A text string representing a media type. This media type can include
      parameters.
    </param>
    <param name='defaultValue'>The media type to return if the string is syntactically invalid. Can be
      null.
    </param>
    <returns>A MediaType object.
    </returns>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.QuotedStringRule.Http'>
    <summary>Use HTTP rules for quoted strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.QuotedStringRule.Rfc5322'>
    <summary>Use Internet Message Format rules for quoted strings.
    </summary>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.SubType'>
    <summary>Gets this media type's subtype.
    </summary>
    <value>This media type's subtype.
    </value>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.TextPlainAscii'>
    <summary>Specifies the media type "text/plain" and the "charset" parameter
      "US-ASCII", used for plain text data.
    </summary>
  </doc>
  <doc name='F:PeterO.Mail.MediaType.TextPlainUtf8'>
    <summary>Specifies the media type "text/plain" and the "charset" parameter "utf-8",
      used for plain text data that may contain characters outside the basic
      Latin range (U+0000 to U+007F).
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.ToSingleLineString'>
    <summary>Converts this media type to a text string form suitable for inserting in
      HTTP headers. Notably, the string contains the value of a Content-Type
      header field (without the text necessarily starting with "Content-Type"
      followed by a space), and consists of a single line.
    </summary>
    <returns>A text string form of this media type.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.ToString'>
    <summary>Converts this media type to a text string form suitable for inserting in
      email headers. Notably, the string contains the value of a Content-Type
      header field (without the text necessarily starting with "Content-Type"
      followed by a space), and consists of one or more lines.
    </summary>
    <returns>A text string form of this media type.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaType.ToUriSafeString'>
    <summary>Converts this media type to a text string form suitable for data URIs.
      Notably, the string contains the value of a Content-Type header field
      (without the text necessarily starting with "Content-Type" followed by a
      space), consists of a single line, and uses percent-encoding as necessary
      or convenient so that the resulting string can validly appear in a URI
      path.
    </summary>
    <returns>A text string form of this media type.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.TopLevelType'>
    <summary>Gets the name of this media type's top-level type (such as "text" or
      "audio").
    </summary>
    <value>The name of this media type's top-level type (such as "text" or "audio".
    </value>
  </doc>
  <doc name='P:PeterO.Mail.MediaType.TypeAndSubType'>
    <summary>Gets the top level type and subtype of this media type, separated by a
      slash; for example, "text/plain".
    </summary>
    <value>The top level type and subtype of this media type, separated by a slash;
      for example, "text/plain".
    </value>
  </doc>
  <doc name='T:PeterO.Mail.MediaTypeBuilder'>
    <summary>A mutable media type object.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.MediaTypeBuilder'/>
       class, using the type "application/octet-stream".
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.#ctor(PeterO.Mail.MediaType)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.MediaTypeBuilder'/>
       class using the data from another media type.
    </summary>
    <param name='mt'>The parameter
      <paramref name='mt'/>
       is a MediaType object.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.#ctor(System.String,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.MediaTypeBuilder'/>
       class.
    </summary>
    <param name='type'>The media type's top-level type.
    </param>
    <param name='subtype'>The media type's subtype.
    </param>
  </doc>
  <doc name='P:PeterO.Mail.MediaTypeBuilder.IsMultipart'>
    <summary>Gets a value indicating whether this is a multipart media type.
    </summary>
    <value><c>true</c> If this is a multipart media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.MediaTypeBuilder.IsText'>
    <summary>Gets a value indicating whether this is a text media type.
    </summary>
    <value><c>true</c> If this is a text media type; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.RemoveParameter(System.String)'>
    <summary>Removes a parameter from this builder object. Does nothing if the
      parameter's name doesn't exist.
    </summary>
    <param name='name'>Name of the parameter to remove. The name is compared using a basic
      case-insensitive comparison. (Two strings are equal in such a comparison,
      if they match after converting the basic upper-case letters A to Z (U+0041
      to U+005A) in both strings to lower case.).
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.SetParameter(System.String,System.String)'>
    <summary>Sets a parameter's name and value for this media type.
    </summary>
    <param name='name'>Name of the parameter to set, such as "charset". The name is compared
      using a basic case-insensitive comparison. (Two strings are equal in such
      a comparison, if they match after converting the basic upper-case letters
      A to Z (U+0041 to U+005A) in both strings to lower case.).
    </param>
    <param name='value'>A text string giving the parameter's value.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='value'/>
       or
      <paramref name='name'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='name'/>
       is empty or syntactically invalid.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.SetSubType(System.String)'>
    <summary>Sets this media type's subtype, such as "plain" or "xml" .
    </summary>
    <param name='str'>A text string naming a media subtype.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='str'/>
       is empty or syntactically invalid.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.SetTopLevelType(System.String)'>
    <summary>Sets this media type's top-level type.
    </summary>
    <param name='str'>A text string naming a top-level type, such as "text" or "audio".
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='str'/>
       is syntactically invalid for a top-level type.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.MediaTypeBuilder.SubType'>
    <summary>Gets or sets this value's subtype.
    </summary>
    <value>This value's subtype.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.ToMediaType'>
    <summary>Converts this builder to an immutable media type object.
    </summary>
    <returns>A MediaType object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.MediaTypeBuilder.ToString'>
    <summary>Converts this object to a text string of the media type it represents, in
      the same form as
      <c>MediaType.ToString</c> .
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.MediaTypeBuilder.TopLevelType'>
    <summary>Gets or sets this value's top-level type.
    </summary>
    <value>This value's top-level type.
    </value>
  </doc>
  <doc name='T:PeterO.Mail.Message'>
    <summary><para>Represents an email message, and contains methods and properties for
        accessing and modifying email message data. This class implements the
        Internet Message Format (RFC 5322) and Multipurpose Internet Mail
        Extensions (MIME; RFC 2045-2047, RFC 2049).
      </para>
      <para><b>Thread safety:</b> This class is mutable; its properties can be changed. None of its
        instance methods are designed to be thread safe. Therefore, access to
        objects from this class must be synchronized if multiple threads can
        access them at the same time.
      </para>
      <para>The following lists known deviations from the mail specifications
        (Internet Message Format and MIME):
      </para>
      <list type=''>
        <item>The content-transfer-encodings "quoted-printable" and "base64" are
          treated as 7bit instead if they occur in a message or body part with
          content type "multipart/*" or "message/*" (other than
          "message/global", "message/global-headers",
          "message/global-disposition-notification", or
          "message/global-delivery-status").
        </item>
        <item>If a message has two or more Content-Type header fields, it is treated
          as having a content type of "application/octet-stream", unless one or
          more of the header fields is syntactically invalid.
        </item>
        <item>Illegal UTF-8 byte sequences appearing in header field values are
          replaced with replacement characters. Moreover, UTF-8 is parsed
          everywhere in header field values, even in those parts of some
          structured header fields where this appears not to be allowed. (UTF-8
          is a character encoding for the Unicode character set.)
        </item>
        <item>This implementation can parse a message even if that message is
          without a From header field, without a Date header field, or without
          both.
        </item>
        <item>The To and Cc header fields are allowed to contain only comments and
          whitespace, but these "empty" header fields will be omitted when
          generating.
        </item>
        <item>There is no line length limit imposed when parsing header fields,
          except header field names.
        </item>
        <item>There is no line length limit imposed when parsing quoted-printable or
          base64 encoded bodies.
        </item>
        <item>If the transfer encoding is absent and the content type is
          "message/rfc822", bytes with values greater than 127 (called "8-bit
          bytes" in the rest of this summary) are still allowed, despite the
          default value of "7bit" for "Content-Transfer-Encoding".
        </item>
        <item>In the following cases, if the transfer encoding is absent, declared
          as 7bit, or treated as 7bit, 8-bit bytes are still allowed:
        </item>
        <item>(a) The preamble and epilogue of multipart messages, which will be
          ignored.
        </item>
        <item>(b) If the charset is declared to be
          <c>utf-8</c> .
        </item>
        <item>(c) If the content type is "text/html" and the charset is declared to
          be
          <c>us-ascii</c> , "windows-1252", "windows-1251", or "iso-8859-*" (all single byte
          encodings).
        </item>
        <item>(d) In non-MIME message bodies and in text/plain message bodies. Any
          8-bit bytes are replaced with the substitute character byte (0x1a).
        </item>
        <item>If the message starts with the word "From" (and no other case
          variations of that word) followed by one or more space (U+0020) not
          followed by colon, that text and the rest of the text is skipped up to
          and including a line feed (U+000A). (See also RFC 4155, which
          describes the so-called "mbox" convention with "From" lines of this
          kind.)
        </item>
        <item>The name
          <c>ascii</c> is treated as a synonym for
          <c>us-ascii</c> , despite being a reserved name under RFC 2046. The name
          <c>cp1252</c> is treated as a synonym for
          <c>windows-1252</c> , even though it's not an IANA registered alias.
        </item>
        <item>The following deviations involve encoded words under RFC 2047:
        </item>
        <item>(a) If a sequence of encoded words decodes to a string with a CTL
          character (U+007F, or a character less than U+0020 and not TAB) after
          being converted to Unicode, the encoded words are left un-decoded.
        </item>
        <item>(b) This implementation can decode encoded words regardless of the
          character length of the line in which they appear. This implementation
          can generate a header field line with one or more encoded words even
          if that line is more than 76 characters long. (This implementation
          follows the recommendation in RFC 5322 to limit header field lines to
          no more than 78 characters, where possible.)
        </item>
      </list>
      <para>It would be appreciated if users of this library contact the author if
        they find other ways in which this implementation deviates from the mail
        specifications or other applicable specifications.
      </para>
      <para>Note that this class currently doesn't support the "padding" parameter
        for message bodies with the media type "application/octet-stream" or
        treated as that media type (see RFC 2046 sec. 4.5.1).
      </para>
      <para>Note that this implementation can decode an RFC 2047 encoded word that
        uses ISO-2022-JP (the only supported encoding that uses code switching)
        even if the encoded word's payload ends in a different mode from "ASCII
        mode". (Each encoded word still starts in "ASCII mode", though.) This,
        however, is not a deviation to RFC 2047 because the relevant rule only
        concerns bringing the output device back to "ASCII mode" after the
        decoded text is displayed (see last paragraph of sec. 6.2) -- since the
        decoded text is converted to Unicode rather than kept as ISO-2022-JP,
        this is not applicable since there is no such thing as "ASCII mode" in
        the Unicode Standard.
      </para>
      <para>Note that this library (the MailLib library) has no facilities for
        sending and receiving email messages, since that's outside this
        library's scope.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.Message.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.Message'/>
       class. The message will be plain text and have an artificial From
      address.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.Message.#ctor(System.Byte[])'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.Message'/>
       class. Reads from the given byte array to initialize the message.
    </summary>
    <param name='bytes'>A readable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.Message.#ctor(System.IO.Stream)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.Message'/>
       class. Reads from the given Stream object to initialize the message.
    </summary>
    <param name='stream'>A readable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddAttachment(PeterO.Mail.MediaType)'>
    <summary>Adds an attachment with an empty body and with the given media type to
      this message. Before the new attachment is added, if this message isn't
      already a multipart message, it becomes a "multipart/mixed" message with
      the current body converted to an inline body part.
    </summary>
    <param name='mediaType'>A media type to assign to the attachment.
    </param>
    <returns>A Message object for the generated attachment.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,PeterO.Mail.MediaType)'>
    <summary>Adds an attachment to this message in the form of data from the given
      readable stream, and with the given media type. Before the new attachment
      is added, if this message isn't already a multipart message, it becomes a
      "multipart/mixed" message with the current body converted to an inline
      body part.
    </summary>
    <example>The following example (written in C# for the .NET version) is an extension
      method that adds an attachment from a byte array to a message.
      <code>public static Message AddAttachmentFromBytes(this Message msg, byte[]
        bytes, MediaType mediaType){ using(var fs=new MemoryStream(bytes)){
        return msg.AddAttachment(fs,mediaType); } }</code> .
    </example>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='mediaType'>A media type to assign to the attachment.
    </param>
    <returns>A Message object for the generated attachment.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "inputStream" or "mediaType" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,PeterO.Mail.MediaType,System.String)'>
    <summary>Adds an attachment to this message in the form of data from the given
      readable stream, and with the given media type and file name. Before the
      new attachment is added, if this message isn't already a multipart
      message, it becomes a "multipart/mixed" message with the current body
      converted to an inline body part.
    </summary>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='mediaType'>A media type to assign to the attachment.
    </param>
    <param name='filename'>A file name to assign to the attachment. Can be null or empty, in which
      case no file name is assigned. Only the file name portion of this
      parameter is used, which in this case means the portion of the string
      after the last "/" or "\", if either character exists, or the entire
      string otherwise.
    </param>
    <returns>A Message object for the generated attachment.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddAttachment(System.IO.Stream,System.String)'>
    <summary>Adds an attachment to this message in the form of data from the given
      readable stream, and with the given file name. Before the new attachment
      is added, if this message isn't already a multipart message, it becomes a
      "multipart/mixed" message with the current body converted to an inline
      body part.
    </summary>
    <example>The following example (written in C# for the .NET version) is an extension
      method that adds an attachment from a data file to a message.
      <code>public static Message AddAttachmentFromFile(this Message msg, string
        filename){ using(var fs=new FileStream(filename,FileMode.Open)){ return
        msg.AddAttachment(fs,filename); } }</code> .
    </example>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='filename'>A file name to assign to the attachment. If the file name has one of
      certain extensions (such as ".html"), an appropriate media type will be
      assigned to the attachment based on that extension; otherwise, the media
      type "application/octet-stream" is assigned. Can be null or empty, in
      which case no file name is assigned. Only the file name portion of this
      parameter is used, which in this case means the portion of the string
      after the last "/" or "\", if either character exists, or the entire
      string otherwise.
    </param>
    <returns>A Message object for the generated attachment.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "inputStream" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddHeader(System.Collections.Generic.KeyValuePair{System.String,System.String})'>
    <summary>Adds a header field to the end of the message's header.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='header'>A key/value pair. The key is the name of the header field, such as "From"
      or "Content-ID". The value is the header field's value.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The key or value of
      <paramref name='header'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The header field name is too long or contains an invalid character, or the
      header field's value is syntactically invalid.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddHeader(System.String,System.String)'>
    <summary>Adds a header field to the end of the message's header.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='name'>Name of a header field, such as "From" or "Content-ID".
    </param>
    <param name='value'>Value of the header field.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='name'/>
       or
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddInline(PeterO.Mail.MediaType)'>
    <summary>Adds an inline body part with an empty body and with the given media type
      to this message. Before the new body part is added, if this message isn't
      already a multipart message, it becomes a "multipart/mixed" message with
      the current body converted to an inline body part.
    </summary>
    <param name='mediaType'>A media type to assign to the body part.
    </param>
    <returns>A Message object for the generated body part.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddInline(System.IO.Stream,PeterO.Mail.MediaType)'>
    <summary>Adds an inline body part to this message in the form of data from the
      given readable stream, and with the given media type. Before the new body
      part is added, if this message isn't already a multipart message, it
      becomes a "multipart/mixed" message with the current body converted to an
      inline body part.
    </summary>
    <example>The following example (written in C# for the .NET version) is an extension
      method that adds an inline body part from a byte array to a message.
      <code>public static Message AddInlineFromBytes(this Message msg, byte[] bytes,
        MediaType mediaType){ using(var fs=new MemoryStream(bytes)){ return
        msg.AddInline(fs,mediaType); } }</code> .
    </example>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='mediaType'>A media type to assign to the body part.
    </param>
    <returns>A Message object for the generated body part.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddInline(System.IO.Stream,PeterO.Mail.MediaType,System.String)'>
    <summary>Adds an inline body part to this message in the form of data from the
      given readable stream, and with the given media type and file name. Before
      the new body part is added, if this message isn't already a multipart
      message, it becomes a "multipart/mixed" message with the current body
      converted to an inline body part.
    </summary>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='mediaType'>A media type to assign to the body part.
    </param>
    <param name='filename'>A file name to assign to the body part.
    </param>
    <returns>A Message object for the generated body part.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.AddInline(System.IO.Stream,System.String)'>
    <summary>Adds an inline body part to this message in the form of data from the
      given readable stream, and with the given file name. Before the new body
      part is added, if this message isn't already a multipart message, it
      becomes a "multipart/mixed" message with the current body converted to an
      inline body part.
    </summary>
    <example>The following example (written in C# for the .NET version) is an extension
      method that adds an inline body part from a data file to a message.
      <code>public static Message AddAttachmentFromInline(this Message msg, string
        filename){ using(var fs=new FileStream(filename,FileMode.Open)){ return
        msg.AddInline(fs,filename); } }</code> .
    </example>
    <param name='inputStream'>A readable data stream.
    </param>
    <param name='filename'>A file name to assign to the body part. If the file name has one of
      certain extensions (such as ".html"), an appropriate media type will be
      assigned to the body part based on that extension; otherwise, the media
      type "application/octet-stream" is assigned. Can be null or empty, in
      which case no file name is assigned. Only the file name portion of this
      parameter is used, which in this case means the portion of the string
      after the last "/" or "\", if either character exists, or the entire
      string otherwise.
    </param>
    <returns>A Message object for the generated body part.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Message.BccAddresses'>
    <summary>Gets a list of addresses found in the BCC header field or fields.
    </summary>
    <value>A list of addresses found in the BCC header field or fields.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.BodyString'>
    <summary>Gets the body of this message as a text string.
    </summary>
    <value>The body of this message as a text string.
    </value>
    <exception cref='T:System.NotSupportedException'>Either this message is a multipart message, so it doesn't have its own
      body text, or this message has no character encoding declared or assumed
      for it (which is usually the case for non-text messages), or the character
      encoding is not supported.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Message.CCAddresses'>
    <summary>Gets a list of addresses found in the CC header field or fields.
    </summary>
    <value>A list of addresses found in the CC header field or fields.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.ClearHeaders'>
    <summary>Deletes all header fields in this message. Also clears this message's
      content disposition and resets its content type to
      MediaType.TextPlainAscii.
    </summary>
    <returns>This object.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Message.ContentDisposition'>
    <summary>Gets or sets this message's content disposition. The content disposition
      specifies how a user agent should display or otherwise handle this
      message. Can be set to null. If set to a disposition or to null, updates
      the Content-Disposition header field as appropriate.
    </summary>
    <value>This message's content disposition, or null if none is specified.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.ContentType'>
    <summary>Gets or sets this message's media type. When getting, the media type may
      differ in certain cases from the value of the Content-Type header field,
      if any, and may have a value even if the Content-Type header field is
      absent from this message. If set to a media type, updates the Content-Type
      header field as appropriate. Cannot be set to null.
    </summary>
    <value>This message's media type.
    </value>
    <exception cref='T:System.ArgumentNullException'>This value is being set and "value" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.DecodeHeaderValue(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='name'>The parameter
      <paramref name='name'/>
       is not documented yet.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is not documented yet.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Message.FileName'>
    <summary><para>Gets a file name suggested by this message for saving the message's body
        to a file. For more information on the algorithm, see
        ContentDisposition.MakeFilename.
      </para>
      <para>This method generates a file name based on the
        <c>filename</c> parameter of the Content-Disposition header field, if it exists, or on
        the
        <c>name</c> parameter of the Content-Type header field, otherwise.
      </para>
    </summary>
    <value>A suggested name for the file. Returns the empty string if there is no
      filename suggested by the content type or content disposition, or if that
      filename is an empty string.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.FromAddresses'>
    <summary>Gets a list of addresses found in the From header field or fields.
    </summary>
    <value>A list of addresses found in the From header field or fields.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.Generate'>
    <summary>Generates this message's data in text form.
      <para>The generated message will have only Basic Latin code points (U+0000 to
        U+007F), and the transfer encoding will always be 7bit,
        quoted-printable, or base64 (the declared transfer encoding for this
        message will be ignored).
      </para>
      <para>The following applies to the following header fields: From, To, Cc, Bcc,
        Reply-To, Sender, Resent-To, Resent-From, Resent-Cc, Resent-Bcc, and
        Resent-Sender. If the header field exists, but has an invalid syntax,
        has no addresses, or appears more than once, this method will generate a
        synthetic header field with the display-name set to the contents of all
        of the header fields with the same name, and the address set to
        <c>me@[header-name]-address.invalid</c> as the address (a
        <c>.invalid</c> address is a reserved address that can never belong to anyone). (An
        exception is that the Resent-* header fields may appear more than once.)
        The generated message should always have a From header field.
      </para>
      <para>If a Date and/or Message-ID header field doesn't exist, a field with
        that name will be generated (using the current local time for the Date
        field).
      </para>
      <para>When encoding the message's body, if the message has a text content type
        ("text/*"), the line breaks are a CR byte (carriage return, 0x0d)
        followed by an LF byte (line feed, 0x0a), CR alone, or LF alone. If the
        message has any other content type, only CR followed by LF is considered
        a line break.
      </para>
    </summary>
    <returns>The generated message.
    </returns>
    <exception cref='T:PeterO.Mail.MessageDataException'>The message can't be generated.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.GenerateBytes'>
    <summary>Generates this message's data as a byte array, using the same algorithm as
      the Generate method.
    </summary>
    <returns>The generated message as a byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetAddresses(System.String)'>
    <summary>Gets a list of addresses contained in the header fields with the given
      name in this message.
    </summary>
    <param name='headerName'>The name of the header fields to retrieve.
    </param>
    <returns>A list of addresses, in the order in which they appear in this message's
      header fields of the given name.
    </returns>
    <exception cref='T:System.NotSupportedException'>headerName" is not supported for this method. Currently, the only header
      fields supported are To, Cc, Bcc, Reply-To, Sender, and From.
    </exception>
    <exception cref='T:System.ArgumentNullException'>headerName" is null.
    </exception>
    <exception cref='T:System.ArgumentException'>headerName" is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetBody'>
    <summary>Gets the byte array for this message's body. This method doesn't make a
      copy of that byte array.
    </summary>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetBodyMessage'>
    <summary>Returns the mail message contained in this message's body.
    </summary>
    <returns>A message object if this object's content type is "message/rfc822",
      "message/news", or "message/global", or null otherwise.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetDate'>
    <summary>Gets the date and time extracted from this message's Date header field
      (the value of which is found as though GetHeader("date") were called). See

      <see cref='M:PeterO.Mail.MailDateTime.ParseDateString(System.String,System.Boolean)'/>
       for more information on the format of the date-time array returned by
      this method.
    </summary>
    <returns>An array containing eight elements. Returns null if the Date header
      doesn't exist, if the Date field is syntactically or semantically invalid,
      or if the field's year would overflow a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetHeader(System.Int32)'>
    <summary>Gets the name and value of a header field by index.
    </summary>
    <param name='index'>Zero-based index of the header field to get.
    </param>
    <returns>A key/value pair. The key is the name of the header field, such as "From"
      or "Content-ID". The value is the header field's value.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='index'/>
       is 0 or at least as high as the number of header fields.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetHeader(System.String)'>
    <summary>Gets the first instance of the header field with the specified name, using
      a basic case-insensitive comparison. (Two strings are equal in such a
      comparison, if they match after converting the basic upper-case letters A
      to Z (U+0041 to U+005A) in both strings to lower case.).
    </summary>
    <param name='name'>The name of a header field.
    </param>
    <returns>The value of the first header field with that name, or null if there is
      none.
    </returns>
    <exception cref='T:System.ArgumentNullException'>Name is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.GetHeaderArray(System.String)'>
    <summary>Gets an array with the values of all header fields with the specified
      name, using a basic case-insensitive comparison. (Two strings are equal in
      such a comparison, if they match after converting the basic upper-case
      letters A to Z (U+0041 to U+005A) in both strings to lower case.).
    </summary>
    <param name='name'>The name of a header field.
    </param>
    <returns>An array containing the values of all header fields with the given name,
      in the order they appear in the message. The array will be empty if no
      header field has that name.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Message.HeaderFields'>
    <summary>Gets a snapshot of the header fields of this message, in the order in
      which they appear in the message. For each item in the list, the key is
      the header field's name (where any basic upper-case letters [U+0041 to
      U+005A] are converted to lower case) and the value is the header field's
      value.
    </summary>
    <value>A snapshot of the header fields of this message.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.MakeMultilingualMessage(System.Collections.Generic.IList{PeterO.Mail.Message},System.Collections.Generic.IList{System.String})'>
    <summary>Generates a multilingual message (see RFC 8255) from a list of messages
      and a list of language strings.
    </summary>
    <param name='messages'>A list of messages forming the parts of the multilingual message object.
      Each message should have the same content, but be in a different language.
      Each message must have a From header field and use the same email address
      in that field as the other messages. The messages should be ordered in
      descending preference of language.
    </param>
    <param name='languages'>A list of language strings corresponding to the messages given in the
      "messages" parameter. A language string at a given index corresponds to
      the message at the same index. Each language string must follow the syntax
      of the Content-Language header field (see LanguageTags.GetLanguageList).
    </param>
    <returns>A Message object with the content type "multipart/multilingual". It will
      begin with an explanatory body part and be followed by the messages given
      in the "messages" parameter in the order given.
    </returns>
    <exception cref='T:System.ArgumentNullException'>messages" or "languages" is null.
    </exception>
    <exception cref='T:System.ArgumentException'>messages" or "languages" is empty, their lengths don't match, at least one
      message is "null", each message doesn't contain the same email addresses
      in their From header fields, "languages" contains a syntactically invalid
      language tag list, "languages" contains the language tag "zzx" not
      appearing alone or at the end of the language tag list, or the first
      message contains no From header field.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Message.MessageStackEntry.Boundary'>
    <summary>This is an internal API.
    </summary>
    <value>This is an internal API.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.MessageStackEntry.Message'>
    <summary>This is an internal API.
    </summary>
    <value>This is an internal API.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.NewBodyPart'>
    <summary>Creates a message object with no header fields.
    </summary>
    <returns>A message object with no header fields.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Message.Parts'>
    <summary>Gets a list of all the parts of this message. This list is editable. This
      will only be used if the message is a multipart message.
    </summary>
    <value>A list of all the parts of this message. This list is editable. This will
      only be used if the message is a multipart message.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Message.RemoveHeader(System.Int32)'>
    <summary>Removes a header field by index.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='index'>Zero-based index of the header field to set.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.RemoveHeader(System.String)'>
    <summary>Removes all instances of the given header field from this message. If this
      is a multipart message, the header field is not removed from its body part
      headers. A basic case-insensitive comparison is used. (Two strings are
      equal in such a comparison, if they match after converting the basic
      upper-case letters A to Z (U+0041 to U+005A) in both strings to lower
      case.).
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='name'>The name of the header field to remove.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SelectLanguageMessage(System.Collections.Generic.IList{System.String})'>
    <summary>Not documented yet.
    </summary>
    <param name='languages'>The parameter
      <paramref name='languages'/>
       is not documented yet.
    </param>
    <returns>A Message object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SelectLanguageMessage(System.Collections.Generic.IList{System.String},System.Boolean)'>
    <summary>Not documented yet.
    </summary>
    <param name='languages'>The parameter
      <paramref name='languages'/>
       is not documented yet.
    </param>
    <param name='preferOriginals'>The parameter
      <paramref name='preferOriginals'/>
       is not documented yet.
    </param>
    <returns>A Message object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetBody(System.Byte[])'>
    <summary>Sets the body of this message to the given byte array. This method doesn't
      make a copy of that byte array.
    </summary>
    <param name='bytes'>A byte array.
    </param>
    <returns>This object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetCurrentDate'>
    <summary>Sets this message's Date header field to the current time as its value.
      <para>This method can be used when the message is considered complete and
        ready to be generated, for example, using the "Generate()" method.
      </para>
    </summary>
    <returns>This object.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetDate(System.Int32[])'>
    <summary>Sets this message's Date header field to the given date and time.
    </summary>
    <param name='dateTime'>An array containing eight elements. Each element of the array (starting
      from 0) is as follows:
      <list>
        <item>0 - The year. For example, the value 2000 means 2000 C.E.
        </item>
        <item>1 - Month of the year, from 1 (January) through 12 (December).
        </item>
        <item>2 - Day of the month, from 1 through 31.
        </item>
        <item>3 - Hour of the day, from 0 through 23.
        </item>
        <item>4 - Minute of the hour, from 0 through 59.
        </item>
        <item>5 - Second of the minute, from 0 through 60 (this value can go up to
          60 to accommodate leap seconds). (Leap seconds are additional seconds
          added to adjust international atomic time, or TAI, to an approximation
          of astronomical time known as coordinated universal time, or UTC.)
        </item>
        <item>6 - Milliseconds of the second, from 0 through 999. This value is not
          used to generate the date string, but must still be valid.
        </item>
        <item>7 - Number of minutes to subtract from this date and time to get
          global time. This number can be positive or negative.
        </item>
      </list>
       .
    </param>
    <returns>This object.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='dateTime'/>
       contains fewer than eight elements, contains invalid values, or contains
      a year less than 0.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dateTime'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHeader(System.Int32,System.Collections.Generic.KeyValuePair{System.String,System.String})'>
    <summary>Sets the name and value of a header field by index.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='index'>Zero-based index of the header field to set.
    </param>
    <param name='header'>A key/value pair. The key is the name of the header field, such as "From"
      or "Content-ID". The value is the header field's value.
    </param>
    <returns>A Message object.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='index'/>
       is 0 or at least as high as the number of header fields; or, the header
      field name is too long or contains an invalid character, or the header
      field's value is syntactically invalid.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHeader(System.Int32,System.String)'>
    <summary>Sets the value of a header field by index without changing its name.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='index'>Zero-based index of the header field to set.
    </param>
    <param name='value'>Value of the header field.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='value'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHeader(System.Int32,System.String,System.String)'>
    <summary>Sets the name and value of a header field by index.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='index'>Zero-based index of the header field to set.
    </param>
    <param name='name'>Name of a header field, such as "From" or "Content-ID".
    </param>
    <param name='value'>Value of the header field.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHeader(System.String,System.String)'>
    <summary>Sets the value of this message's header field. If a header field with the
      same name exists, its value is replaced. If the header field's name occurs
      more than once, only the first instance of the header field is replaced.
      <para>Updates the ContentType and ContentDisposition properties if those
        header fields have been modified by this method.
      </para>
    </summary>
    <param name='name'>The name of a header field, such as "from" or "subject".
    </param>
    <param name='value'>The header field's value.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetHtmlBody(System.String)'>
    <summary>Sets the body of this message to the specified string in HTML format. The
      character sequences CR (carriage return, "\r", U+000D), LF (line feed,
      "\n", U+000A), and CR/LF will be converted to CR/LF line breaks. Unpaired
      surrogate code points will be replaced with replacement characters.
    </summary>
    <param name='str'>A string consisting of the message in HTML format.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetTextAndHtml(System.String,System.String)'>
    <summary>Sets the body of this message to a multipart body with plain text and HTML
      versions of the same message. The character sequences CR (carriage return,
      "\r" , U+000D), LF (line feed, "\n", U+000A), and CR/LF will be converted
      to CR/LF line breaks. Unpaired surrogate code points will be replaced with
      replacement characters.
    </summary>
    <param name='text'>A string consisting of the plain text version of the message.
    </param>
    <param name='html'>A string consisting of the HTML version of the message.
    </param>
    <returns>This instance.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='text'/>
       or
      <paramref name='html'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.Message.SetTextBody(System.String)'>
    <summary>Sets the body of this message to the specified plain text string. The
      character sequences CR (carriage return, "\r", U+000D), LF (line feed,
      "\n", U+000A), and CR/LF will be converted to CR/LF line breaks. Unpaired
      surrogate code points will be replaced with replacement characters. This
      method changes this message's media type to plain text.
    </summary>
    <param name='str'>A string consisting of the message in plain text format.
    </param>
    <returns>This instance.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.Message.Subject'>
    <summary>Gets or sets this message's subject.
    </summary>
    <value>This message's subject.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.Message.ToAddresses'>
    <summary>Gets a list of addresses found in the To header field or fields.
    </summary>
    <value>A list of addresses found in the To header field or fields.
    </value>
  </doc>
  <doc name='T:PeterO.Mail.MessageDataException'>
    <summary>Exception thrown when a message has invalid syntax.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MessageDataException.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.MessageDataException'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.MessageDataException.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.MessageDataException'/>
       class.
    </summary>
    <param name='message'>A string to use as the exception message.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.MessageDataException.#ctor(System.String,System.Exception)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.MessageDataException'/>
       class.
    </summary>
    <param name='message'>A string to use as the exception message.
    </param>
    <param name='innerException'>The parameter
      <paramref name='innerException'/>
       is an Exception object.
    </param>
  </doc>
  <doc name='T:PeterO.Mail.NamedAddress'>
    <summary>Represents an email address and a name for that address. Can represent a
      group of email addresses instead.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.NamedAddress'/>
       class. Examples:
      <list>
        <item><c>john@example.com</c> </item>
        <item><c>"John Doe" &lt;john@example.com&gt;</c> </item>
        <item><c>=?utf-8?q?John</c> <c>=</c> <c>27s_Office?= &lt;john@example.com&gt;</c> </item>
        <item><c>John &lt;john@example.com&gt;</c> </item>
        <item><c>"Group" : Tom &lt;tom@example.com&gt;, Jane
            &lt;jane@example.com&gt;;</c> </item>
      </list>
    </summary>
    <param name='address'>A text string identifying a single email address or a group of email
      addresses. Comments, or text within parentheses, can appear. Multiple
      email addresses are not allowed unless they appear in the group syntax
      given above. Encoded words under RFC 2047 that appear within comments or
      display names will be decoded.
      <para>An RFC 2047 encoded word consists of "=?", a character encoding name,
        such as
        <c>utf-8</c> , either "?B?" or "?Q?" (in upper or lower case), a series of bytes in
        the character encoding, further encoded using B or Q encoding, and
        finally "?=". B encoding uses Base64, while in Q encoding, spaces are
        changed to "_", equals are changed to "=3D", and most bytes other than
        the basic digits 0 to 9 (0x30 to 0x39) and the basic letters A/a to Z/z
        (0x41 to 0x5a, 0x61 to 0x7a) are changed to "=" followed by their
        2-digit hexadecimal form. An encoded word's maximum length is 75
        characters. See the third example.
      </para>
       .
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='address'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The named address has an invalid syntax.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String,PeterO.Mail.Address)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.NamedAddress'/>
       class using the given display name and email address.
    </summary>
    <param name='displayName'>The display name of the email address. Can be null or empty. Encoded words
      under RFC 2047 will not be decoded.
    </param>
    <param name='address'>An email address.
    </param>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String,System.Collections.Generic.IList{PeterO.Mail.NamedAddress})'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.NamedAddress'/>
       class. Takes a group name and several named email addresses as
      parameters, and forms a group with them.
    </summary>
    <param name='groupName'>The group's name.
    </param>
    <param name='mailboxes'>A list of named addresses that make up the group.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='groupName'/>
       or
      <paramref name='mailboxes'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='groupName'/>
       is empty, or an item in the list is itself a group.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.NamedAddress'/>
       class using the given display name and email address.
    </summary>
    <param name='displayName'>The display name of the email address. Can be null or empty. Encoded words
      under RFC 2047 will not be decoded.
    </param>
    <param name='address'>An email address.
    </param>
    <exception cref='T:System.ArgumentException'>The display name or address has an invalid syntax.
    </exception>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.#ctor(System.String,System.String,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.NamedAddress'/>
       class using the given name and an email address made up of its local part
      and domain.
    </summary>
    <param name='displayName'>The display name of the email address. Can be null or empty.
    </param>
    <param name='localPart'>The local part of the email address (before the "@").
    </param>
    <param name='domain'>The domain of the email address (before the "@").
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='localPart'/>
       or
      <paramref name='domain'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.Address'>
    <summary>Gets the email address associated with this object.
    </summary>
    <value>The email address associated with this object. This value is null if this
      object represents a group of addresses instead.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.AddressesEqual(PeterO.Mail.NamedAddress)'>
    <param name='na'>A named address object to compare with this one. Can be null.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.DisplayName'>
    <summary>Gets the display name for this email address. Returns null if the display
      name is absent.
    </summary>
    <value>The display name for this email address.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.GetHashCode'>
    <summary>Calculates the hash code of this object. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.GroupAddresses'>
    <summary>Gets a read-only list of addresses that make up the group, if this object
      represents a group, or an empty list otherwise.
    </summary>
    <value>A list of addresses that make up the group, if this object represents a
      group, or an empty list otherwise.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.IsGroup'>
    <summary>Gets a value indicating whether this represents a group of addresses
      rather than a single address.
    </summary>
    <value><c>true</c> If this represents a group of addresses; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Mail.NamedAddress.Name'>
    <summary>Gets the display name for this email address, or the email address's value
      if the display name is null. Returns an empty string if the address and
      display name are null.
    </summary>
    <value>The name for this email address.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.NamedAddress.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='T:PeterO.Mail.QuotedPrintableEncoder'>
    <summary>Encodes binary data into Quoted Printable.
    </summary>
  </doc>
  <doc name='T:PeterO.Mail.StringAndQuality'>
    <summary>Stores an arbitrary string and a "quality value" for that string. For
      instance, the string can be a language tag, and the "quality value" can be
      the degree of preference for that language.
    </summary>
  </doc>
  <doc name='M:PeterO.Mail.StringAndQuality.#ctor(System.String,System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Mail.StringAndQuality'/>
       class.
    </summary>
    <param name='value'>An arbitrary text string.
    </param>
    <param name='quality'>A 32-bit signed integer serving as the "quality" value.
    </param>
  </doc>
  <doc name='P:PeterO.Mail.StringAndQuality.Quality'>
    <summary>Gets the quality value stored by this object.
    </summary>
    <value>The quality value stored by this object.
    </value>
  </doc>
  <doc name='P:PeterO.Mail.StringAndQuality.Value'>
    <summary>Gets the arbitrary string stored by this object.
    </summary>
    <value>The arbitrary string stored by this object.
    </value>
  </doc>
  <doc name='M:PeterO.Mail.Tokener.Compare(System.Int32[],System.Int32[])'>
    <summary>Compares one integer array with another.
    </summary>
    <param name='x'>An integer array.
    </param>
    <param name='y'>An integer array.
    </param>
    <returns>Zero if both values are equal; a negative number if
      <paramref name='x'/>
       is less than
      <paramref name='y'/>
       , or a positive number if
      <paramref name='x'/>
       is greater than
      <paramref name='y'/>
       .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='x'/>
       or
      <paramref name='y'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Mail.Transforms.BoundaryCheckerTransform.HasNewBodyPart'>
    <summary>Gets a value indicating whether a new body part was detected.
    </summary>
    <value><c>true</c> If a new body part was detected; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='T:PeterO.Numbers.EContext'>
    <summary>Contains parameters for controlling the precision, rounding, and exponent
      range of arbitrary-precision numbers. (The "E" stands for "extended", and
      has this prefix to group it with the other classes common to this library,
      particularly EDecimal, EFloat, and ERational.).
      <para><b>Thread safety:</b> With one exception, instances of this class are immutable and are safe
        to use among multiple threads. The one exception involves the
        <c>Flags</c> property. If the context's
        <c>HasFlags</c> property (a read-only property) is
        <c>true</c> , the
        <c>Flags</c> property is mutable, thus making the context mutable. This class
        doesn't synchronize access to such mutable contexts, so applications
        should provide their own synchronization if a context with the
        <c>HasFlags</c> property set to
        <c>true</c> will be shared among multiple threads and at least one of those threads
        needs to write the
        <c>Flags</c> property (which can happen, for example, by passing the context to most
        methods of
        <c>EDecimal</c> such as
        <c>Add</c> ).
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.#ctor(System.Int32,PeterO.Numbers.ERounding,System.Int32,System.Int32,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Numbers.EContext'/>
       class.
      <c>HasFlags</c> will be set to false.
    </summary>
    <param name='precision'>The maximum number of digits a number can have, or 0 for an unlimited
      number of digits.
    </param>
    <param name='rounding'>The rounding mode to use when a number can't fit the given precision.
    </param>
    <param name='exponentMinSmall'>The minimum exponent.
    </param>
    <param name='exponentMaxSmall'>The maximum exponent.
    </param>
    <param name='clampNormalExponents'>Whether to clamp a number's significand to the given maximum precision (if
      it isn't zero) while remaining within the exponent range.
    </param>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.AdjustExponent'>
    <summary>Gets a value indicating whether the EMax and EMin properties refer to the
      number's Exponent property adjusted to the number's precision, or just the
      number's Exponent property. The default value is true, meaning that EMax
      and EMin refer to the adjusted exponent. Setting this value to false
      (using WithAdjustExponent) is useful for modeling floating point
      representations with an integer mantissa (significand) and an integer
      exponent, such as Java's BigDecimal.
    </summary>
    <value><c>true</c> if the EMax and EMin properties refer to the number's Exponent property
      adjusted to the number's precision, or false if they refer to just the
      number's Exponent property.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Basic'>
    <summary>A basic arithmetic context, 9 digits precision, rounding mode half-up,
      unlimited exponent range. The default rounding mode is HalfUp.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.BigDecimalJava'>
    <summary>An arithmetic context for Java's BigDecimal format. The default rounding
      mode is HalfUp.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Binary128'>
    <summary>An arithmetic context for the IEEE-754-2008 binary128 format, 113 bits
      precision. The default rounding mode is HalfEven.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Binary16'>
    <summary>An arithmetic context for the IEEE-754-2008 binary16 format, 11 bits
      precision. The default rounding mode is HalfEven.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Binary32'>
    <summary>An arithmetic context for the IEEE-754-2008 binary32 format, 24 bits
      precision. The default rounding mode is HalfEven.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Binary64'>
    <summary>An arithmetic context for the IEEE-754-2008 binary64 format, 53 bits
      precision. The default rounding mode is HalfEven.
    </summary>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.ClampNormalExponents'>
    <summary>Gets a value indicating whether a converted number's Exponent property
      will not be higher than EMax + 1 - Precision. If a number's exponent is
      higher than that value, but not high enough to cause overflow, the
      exponent is clamped to that value and enough zeros are added to the
      number's mantissa (significand) to account for the adjustment. If
      HasExponentRange is false, this value is always false.
    </summary>
    <value>If true, a converted number's Exponent property will not be higher than
      EMax + 1 - Precision.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.CliDecimal'>
    <summary>An arithmetic context for the .NET Framework decimal format (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), 96 bits precision, and a valid exponent range of -28 to 0. The default
      rounding mode is HalfEven. (The
      <c>"Cli"</c> stands for "Common Language Infrastructure", which defined this format as
      the .NET Framework decimal format in version 1, but leaves it unspecified
      in later versions.).
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.Copy'>
    <summary>Initializes a new EContext that is a copy of another EContext.
    </summary>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Decimal128'>
    <summary>An arithmetic context for the IEEE-754-2008 decimal128 format. The default
      rounding mode is HalfEven.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Decimal32'>
    <summary>An arithmetic context for the IEEE-754-2008 decimal32 format. The default
      rounding mode is HalfEven.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Decimal64'>
    <summary>An arithmetic context for the IEEE-754-2008 decimal64 format. The default
      rounding mode is HalfEven.
    </summary>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.EMax'>
    <summary>Gets the highest exponent possible when a converted number is expressed in
      scientific notation with one digit before the radix point. For example,
      with a precision of 3 and an EMax of 100, the maximum value possible is
      9.99E + 100. (This is not the same as the highest possible Exponent
      property.) If HasExponentRange is false, this value will be 0.
    </summary>
    <value>The highest exponent possible when a converted number is expressed in
      scientific notation with one digit before the decimal point. For example,
      with a precision of 3 and an EMax of 100, the maximum value possible is
      9.99E + 100. (This is not the same as the highest possible Exponent
      property.) If HasExponentRange is false, this value will be 0.
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.EMin'>
    <summary>Gets the lowest exponent possible when a converted number is expressed in
      scientific notation with one digit before the radix point. For example,
      with a precision of 3 and an EMin of -100, the next value that comes after
      0 is 0.001E-100. (If AdjustExponent is false, this property specifies the
      lowest possible Exponent property instead.) If HasExponentRange is false,
      this value will be 0.
    </summary>
    <value>The lowest exponent possible when a converted number is expressed in
      scientific notation with one digit before the decimal point.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.ExponentWithinRange(PeterO.Numbers.EInteger)'>
    <summary>Determines whether a number can have the given Exponent property under
      this arithmetic context.
    </summary>
    <param name='exponent'>An arbitrary-precision integer indicating the desired exponent.
    </param>
    <returns><c>true</c> if a number can have the given Exponent property under this arithmetic
      context; otherwise,
      <c>false</c> . If this context allows unlimited precision, returns true for the
      exponent EMax and any exponent less than EMax.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='exponent'/>
       is null.
    </exception>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagClamped'>
    <summary>Signals that the exponent was adjusted to fit the exponent range.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagDivideByZero'>
    <summary>Signals a division of a nonzero number by zero.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagInexact'>
    <summary>Signals that the result was rounded to a different mathematical value, but
      as close as possible to the original.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagInvalid'>
    <summary>Signals an invalid operation.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagLostDigits'>
    <summary>Signals that an operand was rounded to a different mathematical value
      before an operation.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagOverflow'>
    <summary>Signals that the result is non-zero and the exponent is higher than the
      highest exponent allowed.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagRounded'>
    <summary>Signals that the result was rounded to fit the precision; either the value
      or the exponent may have changed from the original.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagSubnormal'>
    <summary>Signals that the result's exponent, before rounding, is lower than the
      lowest exponent allowed.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.FlagUnderflow'>
    <summary>Signals that the result's exponent, before rounding, is lower than the
      lowest exponent allowed, and the result was rounded to a different
      mathematical value, but as close as possible to the original.
    </summary>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.Flags'>
    <summary>Gets or sets the flags that are set from converting numbers according to
      this arithmetic context. If
      <c>HasFlags</c> is false, this value will be 0. This value is a combination of bit
      fields. To retrieve a particular flag, use the AND operation on the return
      value of this method. For example:
      <c>(this.Flags &amp; EContext.FlagInexact) != 0</c> returns
      <c>true</c> if the Inexact flag is set.
    </summary>
    <value>The flags that are set from converting numbers according to this
      arithmetic context. If.
      <c>HasFlags</c> is false, this value will be 0.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.ForPrecision(System.Int32)'>
    <summary>Creates a new arithmetic context using the given maximum number of digits,
      an unlimited exponent range, and the HalfUp rounding mode.
    </summary>
    <param name='precision'>Maximum number of digits (precision).
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.ForPrecisionAndRounding(System.Int32,PeterO.Numbers.ERounding)'>
    <summary>Creates a new EContext object initialized with an unlimited exponent
      range, and the given rounding mode and maximum precision.
    </summary>
    <param name='precision'>Maximum number of digits (precision).
    </param>
    <param name='rounding'>The parameter
      <paramref name='rounding'/>
       is an ERounding object.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.ForRounding(PeterO.Numbers.ERounding)'>
    <summary>Creates a new EContext object initialized with an unlimited precision, an
      unlimited exponent range, and the given rounding mode.
    </summary>
    <param name='rounding'>The rounding mode for the new precision context.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.HasExponentRange'>
    <summary>Gets a value indicating whether this context defines a minimum and maximum
      exponent. If false, converted exponents can have any exponent and
      operations can't cause overflow or underflow.
    </summary>
    <value><c>true</c> if this context defines a minimum and maximum exponent; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.HasFlags'>
    <summary>Gets a value indicating whether this context has a mutable Flags field.
    </summary>
    <value><c>true</c> if this context has a mutable Flags field; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.HasMaxPrecision'>
    <summary>Gets a value indicating whether this context defines a maximum precision.
    </summary>
    <value><c>true</c> if this context defines a maximum precision; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.IsPrecisionInBits'>
    <summary>Gets a value indicating whether this context's Precision property is in
      bits, rather than digits. The default is false.
    </summary>
    <value><c>true</c> if this context's Precision property is in bits, rather than digits;
      otherwise,
      <c>false</c> . The default is false.
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.IsSimplified'>
    <summary>Gets a value indicating whether to use a "simplified" arithmetic. In the
      simplified arithmetic, infinity, not-a-number, and subnormal numbers are
      not allowed, and negative zero is treated the same as positive zero. For
      further details, see
      <a href='http://speleotrove.com/decimal/dax3274.html'>
        <c>http://speleotrove.com/decimal/dax3274.html</c> </a>
    </summary>
    <value><c>true</c> if a "simplified" arithmetic will be used; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.Precision'>
    <summary>Gets the maximum length of a converted number in digits, ignoring the
      radix point and exponent. For example, if precision is 3, a converted
      number's mantissa (significand) can range from 0 to 999 (up to three
      digits long). If 0, converted numbers can have any precision.
    </summary>
    <value>The maximum length of a converted number in digits, ignoring the radix
      point and exponent.
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.Rounding'>
    <summary>Gets the desired rounding mode when converting numbers that can't be
      represented in the given precision and exponent range.
    </summary>
    <value>The desired rounding mode when converting numbers that can't be
      represented in the given precision and exponent range.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.ToString'>
    <summary>Gets a string representation of this object. Note that the string's format
      is not intended to be parsed and may change at any time.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EContext.Traps'>
    <summary>Gets the traps that are set for each flag in the context. Whenever a flag
      is signaled, even if
      <c>HasFlags</c> is false, and the flag's trap is enabled, the operation will throw a
      TrapException.
      <para>For example, if Traps equals
        <c>FlagInexact</c> and FlagSubnormal, a TrapException will be thrown if an operation's
        return value is not the same as the exact result (FlagInexact) or if the
        return value's exponent is lower than the lowest allowed
        (FlagSubnormal).
      </para>
    </summary>
    <value>The traps that are set for each flag in the context.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.Unlimited'>
    <summary>No specific (theoretical) limit on precision. Rounding mode HalfUp.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EContext.UnlimitedHalfEven'>
    <summary>No specific (theoretical) limit on precision. Rounding mode HalfEven.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithAdjustExponent(System.Boolean)'>
    <summary>Copies this EContext and sets the copy's "AdjustExponent" property to the
      given value.
    </summary>
    <param name='adjustExponent'>The new value of the "AdjustExponent" property for the copy.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithBigExponentRange(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Copies this arithmetic context and sets the copy's exponent range.
    </summary>
    <param name='exponentMin'>Desired minimum exponent (EMin).
    </param>
    <param name='exponentMax'>Desired maximum exponent (EMax).
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='exponentMin'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='exponentMax'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithBigPrecision(PeterO.Numbers.EInteger)'>
    <summary>Copies this EContext and gives it a particular precision value.
    </summary>
    <param name='bigintPrecision'>Desired precision. 0 means unlimited precision.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintPrecision'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithBlankFlags'>
    <summary>Copies this EContext with
      <c>HasFlags</c> set to true and a Flags value of 0.
    </summary>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithExponentClamp(System.Boolean)'>
    <summary>Copies this arithmetic context and sets the copy's "ClampNormalExponents"
      flag to the given value.
    </summary>
    <param name='clamp'>The desired value of the "ClampNormalExponents" flag.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithExponentRange(System.Int32,System.Int32)'>
    <summary>Copies this arithmetic context and sets the copy's exponent range.
    </summary>
    <param name='exponentMinSmall'>Desired minimum exponent (EMin).
    </param>
    <param name='exponentMaxSmall'>Desired maximum exponent (EMax).
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithNoFlags'>
    <summary>Copies this EContext with
      <c>HasFlags</c> set to false and a Flags value of 0.
    </summary>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithPrecision(System.Int32)'>
    <summary>Copies this EContext and gives it a particular precision value.
    </summary>
    <param name='precision'>Desired precision. 0 means unlimited precision.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithPrecisionInBits(System.Boolean)'>
    <summary>Copies this EContext and sets the copy's "IsPrecisionInBits" property to
      the given value.
    </summary>
    <param name='isPrecisionBits'>The new value of the "IsPrecisionInBits" property for the copy.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithRounding(PeterO.Numbers.ERounding)'>
    <summary>Copies this EContext with the specified rounding mode.
    </summary>
    <param name='rounding'>Desired value of the Rounding property.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithSimplified(System.Boolean)'>
    <summary>Copies this EContext and sets the copy's "IsSimplified" property to the
      given value.
    </summary>
    <param name='simplified'>Desired value of the IsSimplified property.
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithTraps(System.Int32)'>
    <summary>Copies this EContext with Traps set to the given value.
    </summary>
    <param name='traps'>Flags representing the traps to enable. See the property "Traps".
    </param>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EContext.WithUnlimitedExponents'>
    <summary>Copies this EContext with an unlimited exponent range.
    </summary>
    <returns>A context object for arbitrary-precision arithmetic settings.
    </returns>
  </doc>
  <doc name='T:PeterO.Numbers.EDecimal'>
    <summary>Represents an arbitrary-precision decimal floating-point number. (The "E"
      stands for "extended", meaning that instances of this class can be values
      other than numbers proper, such as infinity and not-a-number.)
      <para><b>About decimal arithmetic</b> </para>
      <para>Decimal (base-10) arithmetic, such as that provided by this class, is
        appropriate for calculations involving such real-world data as prices
        and other sums of money, tax rates, and measurements. These calculations
        often involve multiplying or dividing one decimal with another decimal,
        or performing other operations on decimal numbers. Many of these
        calculations also rely on rounding behavior in which the result after
        rounding is a decimal number (for example, multiplying a price by a
        premium rate, then rounding, should result in a decimal amount of
        money).
      </para>
      <para>On the other hand, most implementations of
        <c>float</c> and
        <c>double</c> , including in C# and Java, store numbers in a binary (base-2)
        floating-point format and use binary floating-point arithmetic. Many
        decimal numbers can't be represented exactly in binary floating-point
        format (regardless of its length). Applying binary arithmetic to numbers
        intended to be decimals can sometimes lead to unintuitive results, as is
        shown in the description for the FromDouble() method of this class.
      </para>
      <para><b>About EDecimal instances</b> </para>
      <para>Each instance of this class consists of an integer mantissa
        (significand) and an integer exponent, both arbitrary-precision. The
        value of the number equals mantissa (significand) * 10^exponent.
      </para>
      <para>The mantissa (significand) is the value of the digits that make up a
        number, ignoring the decimal point and exponent. For example, in the
        number 2356.78, the mantissa (significand) is 235678. The exponent is
        where the "floating" decimal point of the number is located. A positive
        exponent means "move it to the right", and a negative exponent means
        "move it to the left." In the example 2, 356.78, the exponent is -2,
        since it has 2 decimal places and the decimal point is "moved to the
        left by 2." Therefore, in the arbitrary-precision decimal
        representation, this number would be stored as 235678 * 10^-2.
      </para>
      <para>The mantissa (significand) and exponent format preserves trailing zeros
        in the number's value. This may give rise to multiple ways to store the
        same value. For example, 1.00 and 1 would be stored differently, even
        though they have the same value. In the first case, 100 * 10^-2 (100
        with decimal point moved left by 2), and in the second case, 1 * 10^0 (1
        with decimal point moved 0).
      </para>
      <para>This class also supports values for negative zero, not-a-number (NaN)
        values, and infinity.
        <b>Negative zero</b> is generally used when a negative number is rounded to 0; it has the
        same mathematical value as positive zero.
        <b>Infinity</b> is generally used when a non-zero number is divided by zero, or when a
        very high or very low number can't be represented in a given exponent
        range.
        <b>Not-a-number</b> is generally used to signal errors.
      </para>
      <para>This class implements the General Decimal Arithmetic Specification
        version 1.70 (except part of chapter 6):
        <c>http://speleotrove.com/decimal/decarith.html</c> </para>
      <para><b>Errors and Exceptions</b> </para>
      <para>Passing a signaling NaN to any arithmetic operation shown here will
        signal the flag FlagInvalid and return a quiet NaN, even if another
        operand to that operation is a quiet NaN, unless noted otherwise.
      </para>
      <para>Passing a quiet NaN to any arithmetic operation shown here will return a
        quiet NaN, unless noted otherwise. Invalid operations will also return a
        quiet NaN, as stated in the individual methods.
      </para>
      <para>Unless noted otherwise,passing a null arbitrary-precision decimal
        argument to any method here will throw an exception.
      </para>
      <para>When an arithmetic operation signals the flag FlagInvalid, FlagOverflow,
        or FlagDivideByZero, it will not throw an exception too, unless the
        flag's trap is enabled in the arithmetic context (see EContext's Traps
        property).
      </para>
      <para>If an operation requires creating an intermediate value that might be
        too big to fit in memory (or might require more than 2 gigabytes of
        memory to store -- due to the current use of a 32-bit integer internally
        as a length), the operation may signal an invalid-operation flag and
        return not-a-number (NaN). In certain rare cases, the CompareTo method
        may throw OutOfMemoryException (called OutOfMemoryError in Java) in the
        same circumstances.
      </para>
      <para><b>Serialization</b> </para>
      <para>An arbitrary-precision decimal value can be serialized (converted to a
        stable format) in one of the following ways:
      </para>
      <list>
        <item>By calling the toString() method, which will always return distinct
          strings for distinct arbitrary-precision decimal values.
        </item>
        <item>By calling the UnsignedMantissa, Exponent, and IsNegative properties,
          and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods.
          The return values combined will uniquely identify a particular
          arbitrary-precision decimal value.
        </item>
      </list>
      <para><b>Thread safety</b> </para>
      <para>Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
      <para><b>Comparison considerations</b> </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. The CompareTo method compares the mathematical values of
        the two instances passed to it (and considers two different NaN values
        as equal), while two instances with the same mathematical value, but
        different exponents, will be considered unequal under the Equals method.

      </para>
      <para><b>Forms of numbers</b> </para>
      <para>There are several other types of numbers that are mentioned in this
        class and elsewhere in this documentation. For reference, they are
        specified here.
      </para>
      <para><b>Unsigned integer</b> : An integer that's always 0 or greater, with the following maximum
        values:
      </para>
      <list>
        <item>8-bit unsigned integer, or
          <i>
             byte
          </i>
           : 255.
        </item>
        <item>16-bit unsigned integer: 65535.
        </item>
        <item>32-bit unsigned integer: (2
          <sup>
             32
          </sup>
           -1).
        </item>
        <item>64-bit unsigned integer: (2
          <sup>
             64
          </sup>
           -1).
        </item>
      </list>
      <para><b>Signed integer</b> : An integer in
        <i>
           two's-complement form
        </i>
         , with the following ranges:
      </para>
      <list>
        <item>8-bit signed integer: -128 to 127.
        </item>
        <item>16-bit signed integer: -32768 to 32767.
        </item>
        <item>32-bit signed integer: -2
          <sup>
             31
          </sup>
           to (2
          <sup>
             31
          </sup>
           - 1).
        </item>
        <item>64-bit signed integer: -2
          <sup>
             63
          </sup>
           to (2
          <sup>
             63
          </sup>
           - 1).
        </item>
      </list>
      <para><b>Two's complement form</b> : In
        <i>
           two' s-complement form
        </i>
         , nonnegative numbers have the highest (most significant) bit set to
        zero, and negative numbers have that bit (and all bits beyond) set to
        one, and a negative number is stored in such form by decreasing its
        absolute value by 1 and swapping the bits of the resulting number.
      </para>
      <para><b>64-bit floating-point number</b> : A 64-bit binary floating-point number, in the form
        <i>
           significand
        </i>
         * 2
        <sup>
          <i>
             exponent
          </i>
        </sup>
         . The significand is 53 bits long (Precision) and the exponent ranges
        from -1074 (EMin) to 971 (EMax). The number is stored in the following
        format (commonly called the IEEE 754 format):
      </para>
      <code>|C|BBB...BBB|AAAAAA...AAAAAA|</code> <list>
        <item>A. Low 52 bits (Precision minus 1 bits): Lowest bits of the
          significand.
        </item>
        <item>B. Next 11 bits: Exponent area:
          <list>
            <item>If all bits are ones, this value is infinity if all bits in area A
              are zeros, or not-a-number (NaN) otherwise.
            </item>
            <item>If all bits are zeros, this is a subnormal number. The exponent is
              EMin and the highest bit of the significand is zero.
            </item>
            <item>If any other number, the exponent is this value reduced by 1, then
              raised by EMin, and the highest bit of the significand is one.
            </item>
          </list>
        </item>
        <item>C. Highest bit: If one, this is a negative number.
        </item>
      </list>
      <para>The elements described above are in the same order as the order of each
        bit of each element, that is, either most significant first or least
        significant first.
      </para>
      <para><b>32-bit binary floating-point number</b> : A 32-bit binary number which is stored similarly to a
        <i>
           64-bit floating-point number
        </i>
         , except that:
      </para>
      <list>
        <item>Precision is 24 bits.
        </item>
        <item>EMin is -149.
        </item>
        <item>EMax is 104.
        </item>
        <item>A. The low 23 bits (Precision minus 1 bits) are the lowest bits of the
          significand.
        </item>
        <item>B. The next 8 bits are the exponent area.
        </item>
        <item>C. If the highest bit is one, this is a negative number.
        </item>
      </list>
      <para><b>.NET Framework decimal</b> : A 128-bit decimal floating-point number, in the form
        <i>
           significand
        </i>
         * 10
        <sup>
           -
          <i>
             scale
          </i>
        </sup>
         , where the scale ranges from 0 to 28. The number is stored in the
        following format:
      </para>
      <list>
        <item>Low 96 bits are the significand, as a 96-bit unsigned integer (all
          96-bit values are allowed, up to (2
          <sup>
             96
          </sup>
           -1)).
        </item>
        <item>Next 16 bits are unused.
        </item>
        <item>Next 8 bits are the scale, stored as an 8-bit unsigned integer.
        </item>
        <item>Next 7 bits are unused.
        </item>
        <item>If the highest bit is one, it's a negative number.
        </item>
      </list>
      <para>The elements described above are in the same order as the order of each
        bit of each element, that is, either most significant first or least
        significant first.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Abs'>
    <summary>Finds the absolute value of this object (if it's negative, it becomes
      positive).
    </summary>
    <returns>An arbitrary-precision decimal number. Returns signaling NaN if this value
      is signaling NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Abs(PeterO.Numbers.EContext)'>
    <summary>Finds the absolute value of this object (if it's negative, it becomes
      positive).
    </summary>
    <param name='context'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The absolute value of this object. Signals FlagInvalid and returns quiet
      NaN if this value is signaling NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal)'>
    <summary>Adds this object and another decimal number and returns the result.
    </summary>
    <param name='otherValue'>An arbitrary-precision decimal number.
    </param>
    <returns>The sum of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Add(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Finds the sum of this object and another object. The result's exponent is
      set to the lower of the exponents of the two operands.
    </summary>
    <param name='otherValue'>The number to add to.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The sum of thisValue and the other object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CompareTo(PeterO.Numbers.EDecimal)'>
    <summary>Compares the mathematical values of this object and another object,
      accepting NaN values.
      <para>This method is not consistent with the Equals method because two
        different numbers with the same mathematical value, but different
        exponents, will compare as equal.
      </para>
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN, this
        method will not trigger an error. Instead, NaN will compare greater than
        any other number, including infinity. Two different NaN values will be
        considered equal.
      </para>
    </summary>
    <param name='other'>An arbitrary-precision decimal number.
    </param>
    <returns>Less than 0 if this object's value is less than the other value, or
      greater than 0 if this object's value is greater than the other value or
      if
      <paramref name='other'/>
       is null, or 0 if both values are equal.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CompareToBinary(PeterO.Numbers.EFloat)'>
    <summary>Compares an arbitrary-precision binary float with this instance.
    </summary>
    <param name='other'>The other object to compare. Can be null.
    </param>
    <returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater. Returns 0 if both values
      are NaN (even signaling NaN) and 1 if this value is NaN (even signaling
      NaN) and the other isn't, or if the other value is null.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CompareToSignal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Compares the mathematical values of this object and another object,
      treating quiet NaN as signaling.
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN, this
        method will return a quiet NaN and will signal a FlagInvalid flag.
      </para>
    </summary>
    <param name='other'>An arbitrary-precision decimal number.
    </param>
    <param name='ctx'>An arithmetic context. The precision, rounding, and exponent range are
      ignored. If
      <c>HasFlags</c> of the context is true, will store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null.
    </param>
    <returns>Quiet NaN if this object or the other object is NaN, or 0 if both objects
      have the same value, or -1 if this object is less than the other value, or
      1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal)'>
    <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision decimal number to compare with this one.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CompareToTotal(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision decimal number to compare with this one.
    </param>
    <param name='ctx'>An arithmetic context. Flags will be set in this context only if
      <c>HasFlags</c> and
      <c>IsSimplified</c> of the context are true and only if an operand needed to be rounded
      before carrying out the operation. Can be null.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater. Does not signal
      flags if either value is signaling NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CompareToTotalMagnitude(PeterO.Numbers.EDecimal)'>
    <summary>Compares the absolute values of this object and another object, imposing a
      total ordering on all possible values (ignoring their signs). In this
      method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero and positive zero are considered equal.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision decimal number to compare with this one.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CompareToWithContext(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Compares the mathematical values of this object and another object.
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN, this
        method returns a quiet NaN, and will signal a FlagInvalid flag if either
        is a signaling NaN.
      </para>
    </summary>
    <param name='other'>An arbitrary-precision decimal number.
    </param>
    <param name='ctx'>An arithmetic context. The precision, rounding, and exponent range are
      ignored. If
      <c>HasFlags</c> of the context is true, will store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null.
    </param>
    <returns>Quiet NaN if this object or the other object is NaN, or 0 if both objects
      have the same value, or -1 if this object is less than the other value, or
      1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CopySign(PeterO.Numbers.EDecimal)'>
    <summary>Returns a number with the same value as this one, but copying the sign
      (positive or negative) of another number.
    </summary>
    <param name='other'>A number whose sign will be copied.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Creates a number with the value
      <c>exponent*10^mantissa</c> .
    </summary>
    <param name='mantissa'>Desired value for the mantissa.
    </param>
    <param name='exponent'>Desired value for the exponent.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Create(System.Int32,System.Int32)'>
    <summary>Creates a number with the value
      <c>exponent*10^mantissa</c> .
    </summary>
    <param name='mantissaSmall'>Desired value for the mantissa.
    </param>
    <param name='exponentSmall'>Desired value for the exponent.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger)'>
    <summary>Creates a not-a-number arbitrary-precision decimal number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <returns>A quiet not-a-number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='diag'/>
       is null or is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)'>
    <summary>Creates a not-a-number arbitrary-precision decimal number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <param name='signaling'>Whether the return value will be signaling (true) or quiet (false).
    </param>
    <param name='negative'>Whether the return value is negative.
    </param>
    <param name='ctx'>An arithmetic context to control the precision (in decimal digits) of the
      diagnostic information. The rounding and exponent range of this context
      will be ignored. Can be null. The only flag that can be signaled in this
      context is FlagInvalid, which happens if diagnostic information needs to
      be truncated and too much memory is required to do so.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='mantissa'>The parameter
      <paramref name='mantissa'/>
       is an internal parameter.
    </param>
    <param name='exponent'>The parameter
      <paramref name='exponent'/>
       is an internal parameter.
    </param>
    <param name='flags'>The parameter
      <paramref name='flags'/>
       is an internal parameter.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.CreateShiftAccumulator(PeterO.Numbers.EInteger)'>
    <summary>This is an internal method.
    </summary>
    <param name='bigint'>An arbitrary-precision integer.
    </param>
    <returns>An IShiftAccumulator object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetArithmeticSupport'>
    <summary>This is an internal method.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetExponent(PeterO.Numbers.EDecimal)'>
    <summary>This is an internal method.
    </summary>
    <param name='value'>An arbitrary-precision decimal number.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetFlags(PeterO.Numbers.EDecimal)'>
    <summary>This is an internal method.
    </summary>
    <param name='value'>An arbitrary-precision decimal number.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetMantissa(PeterO.Numbers.EDecimal)'>
    <summary>This is an internal method.
    </summary>
    <param name='value'>An arbitrary-precision decimal number.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetRadix'>
    <summary>This is an internal method.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.GetSign(PeterO.Numbers.EDecimal)'>
    <summary>This is an internal method.
    </summary>
    <param name='value'>An arbitrary-precision decimal number.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DecimalMathHelper.ValueOf(System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is a 32-bit signed integer.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal)'>
    <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <returns>A 2 element array consisting of the quotient and remainder in that order.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivRemNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the remainder to have a higher precision than given in this context.
      Flags will be set on the given context only if the context's
      <c>HasFlags</c> is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param>
    <returns>A 2 element array consisting of the quotient and remainder in that order.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal)'>
    <summary>Divides this object by another decimal number and returns the result. When
      possible, the result will be exact.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <returns>The quotient of the two numbers. Returns infinity if the divisor is 0 and
      the dividend is nonzero. Returns not-a-number (NaN) if the divisor and the
      dividend are 0. Returns NaN if the result can't be exact because it would
      have a nonterminating decimal expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Divide(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Divides this arbitrary-precision decimal number by another
      arbitrary-precision decimal number. The preferred exponent for the result
      is this object's exponent minus the divisor's exponent.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0; or, either
      <paramref name='ctx'/>
       is null or
      <paramref name='ctx'/>
       's precision is 0, and the result would have a nonterminating decimal
      expansion; or, the rounding mode is ERounding.None and the result is not
      exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal)'>
    <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <returns>A 2 element array consisting of the quotient and remainder in that order.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideAndRemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the remainder to have a higher precision than given in this context.
      Flags will be set on the given context only if the context's
      <c>HasFlags</c> is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param>
    <returns>A 2 element array consisting of the quotient and remainder in that order.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result, using the half-even rounding mode.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='exponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='exponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='desiredExponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Returns
      not-a-number (NaN) if the divisor and the dividend are 0. Returns NaN if
      the rounding mode is ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent (expressed as a 32-bit signed integer) to the result, using the
      half-even rounding mode.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='desiredExponentInt'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.EContext)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent (expressed as a 32-bit signed integer) to the result, using the
      half-even rounding mode.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='desiredExponentInt'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int32,PeterO.Numbers.ERounding)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent (expressed as a 32-bit signed integer) to the result, using the
      half-even rounding mode.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='desiredExponentInt'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent (expressed as a 64-bit signed integer) to the result, using the
      half-even rounding mode.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.EContext)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToExponent(PeterO.Numbers.EDecimal,System.Int64,PeterO.Numbers.ERounding)'>
    <summary>Divides two arbitrary-precision decimal numbers, and gives a particular
      exponent to the result.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual decimal point (so a negative number means the number of
      decimal places to round to). A positive number places the cutoff point to
      the left of the usual decimal point.
    </param>
    <param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal)'>
    <summary>Divides two arbitrary-precision decimal numbers, and returns the integer
      part of the result, rounded down, with the preferred exponent set to this
      value's exponent minus the divisor's exponent.
    </summary>
    <param name='divisor'>An arbitrary-precision decimal number to divide by.
    </param>
    <returns>The integer part of the quotient of the two objects. Signals
      FlagDivideByZero and returns infinity if the divisor is 0 and the dividend
      is nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
      divisor and the dividend are 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToIntegerNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Divides this object by another object, and returns the integer part of the
      result (which is initially rounded down), with the preferred exponent set
      to this value's exponent minus the divisor's exponent.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the integer part of the result. Flags will be set on the
      given context only if the context's
      <c>HasFlags</c> is true and the integer part of the result doesn't fit the precision and
      exponent range without rounding. Can be null, in which the precision is
      unlimited and no additional rounding, other than the rounding down to an
      integer after division, is needed.
    </param>
    <returns>The integer part of the quotient of the two objects. Signals FlagInvalid
      and returns not-a-number (NaN) if the return value would overflow the
      exponent range. Signals FlagDivideByZero and returns infinity if the
      divisor is 0 and the dividend is nonzero. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor and the dividend are 0. Signals
      FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToIntegerZeroScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Divides this object by another object, and returns the integer part of the
      result, with the exponent set to 0.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision. The rounding and
      exponent range settings of this context are ignored. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited.
    </param>
    <returns>The integer part of the quotient of the two objects. The exponent will be
      set to 0. Signals FlagDivideByZero and returns infinity if the divisor is
      0 and the dividend is nonzero. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor and the dividend are 0, or if the result
      doesn't fit the given precision.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.DivideToSameExponent(PeterO.Numbers.EDecimal,PeterO.Numbers.ERounding)'>
    <summary>Divides this object by another decimal number and returns a result with
      the same exponent as this object (the dividend).
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param>
    <returns>The quotient of the two numbers. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Equals(PeterO.Numbers.EDecimal)'>
    <summary>Determines whether this object's mantissa (significand), exponent, and
      properties are equal to those of another object. Not-a-number values are
      considered equal if the rest of their properties are equal.
    </summary>
    <param name='other'>An arbitrary-precision decimal number.
    </param>
    <returns><c>true</c> if this object's mantissa (significand) and exponent are equal to those
      of another object; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Equals(System.Object)'>
    <summary>Determines whether this object's mantissa (significand), exponent, and
      properties are equal to those of another object and that other object is
      an arbitrary-precision decimal number. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Exp(PeterO.Numbers.EContext)'>
    <summary>Finds e (the base of natural logarithms) raised to the power of this
      object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the exponential function's results are
        generally not exact.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>Exponential of this object. If this object's value is 1, returns an
      approximation to " e" within the given precision. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EDecimal.Exponent'>
    <summary>Gets this object's exponent. This object's value will be an integer if the
      exponent is positive or zero.
    </summary>
    <value>This object's exponent. This object's value will be an integer if the
      exponent is positive or zero.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromByte(System.Byte)'>
    <summary>Converts a byte (from 0 to 255) to an arbitrary-precision decimal number.
    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>This number's value as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromDecimal(System.Decimal)'>
    <summary>Converts a
      <c>decimal</c> under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) to an arbitrary-precision decimal.
    </summary>
    <param name='dec'>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </param>
    <returns>An arbitrary-precision decimal floating-point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromDouble(System.Double)'>
    <summary>Creates a decimal number from a 64-bit binary floating-point number. This
      method computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first. Remember, though, that the exact value of a
      64-bit binary floating-point number is not always the value that results
      when passing a literal decimal number (for example, calling
      <c>ExtendedDecimal.FromDouble(0.1f)</c> ), since not all decimal numbers can be converted to exact binary numbers
      (in the example given, the resulting arbitrary-precision decimal will be
      the value of the closest "double" to 0.1, not 0.1 exactly). To create an
      arbitrary-precision decimal number from a decimal number, use FromString
      instead in most cases (for example:
      <c>ExtendedDecimal.FromString("0.1")</c> ).
    </summary>
    <param name='dbl'>The parameter
      <paramref name='dbl'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A decimal number with the same value as
      <paramref name='dbl'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromEFloat(PeterO.Numbers.EFloat)'>
    <summary>Creates a decimal number from an arbitrary-precision binary floating-point
      number.
    </summary>
    <param name='bigfloat'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigfloat'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromEInteger(PeterO.Numbers.EInteger)'>
    <summary>Converts an arbitrary-precision integer to an arbitrary precision decimal.

    </summary>
    <param name='bigint'>An arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision decimal number with the exponent set to 0.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigint'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromExtendedFloat(PeterO.Numbers.EFloat)'>
    <summary>Converts an arbitrary-precision binary floating-point number to an
      arbitrary precision decimal.
    </summary>
    <param name='ef'>An arbitrary-precision binary floating-point number.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='ef'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromInt16(System.Int16)'>
    <summary>Converts a 16-bit signed integer to an arbitrary-precision decimal number.

    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromInt32(System.Int32)'>
    <summary>Creates a decimal number from a 32-bit signed integer.
    </summary>
    <param name='valueSmaller'>The parameter
      <paramref name='valueSmaller'/>
       is a 32-bit signed integer.
    </param>
    <returns>An arbitrary-precision decimal number with the exponent set to 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromInt64(System.Int64)'>
    <summary>Creates a decimal number from a 64-bit signed integer.
    </summary>
    <param name='valueSmall'>The parameter
      <paramref name='valueSmall'/>
       is a 64-bit signed integer.
    </param>
    <returns>An arbitrary-precision decimal number with the exponent set to 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromSByte(System.SByte)'>
    <summary>Converts an 8-bit signed integer to an arbitrary-precision decimal number.

    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromSingle(System.Single)'>
    <summary>Creates a decimal number from a 32-bit binary floating-point number. This
      method computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first. Remember, though, that the exact value of a
      32-bit binary floating-point number is not always the value that results
      when passing a literal decimal number (for example, calling
      <c>ExtendedDecimal.FromSingle(0.1f)</c> ), since not all decimal numbers can be converted to exact binary numbers
      (in the example given, the resulting arbitrary-precision decimal will be
      the the value of the closest "float" to 0.1, not 0.1 exactly). To create
      an arbitrary-precision decimal number from a decimal number, use
      FromString instead in most cases (for example:
      <c>ExtendedDecimal.FromString("0.1")</c> ).
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>A decimal number with the same value as
      <paramref name='flt'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromString(System.String)'>
    <summary>Creates a decimal number from a text string that represents a number. See
      <c>FromString(String, int, int, EContext)</c> for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromString(System.String,PeterO.Numbers.EContext)'>
    <summary>Creates a decimal number from a text string that represents a number. See
      <c>FromString(String, int, int, EContext)</c> for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32)'>
    <summary>Creates a decimal number from a text string that represents a number. See
      <c>FromString(String, int, int, EContext)</c> for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)'>
    <summary><para>Creates a decimal number from a text string that represents a number.
      </para>
      <para>The format of the string generally consists of:
      </para>
      <list type=''>
        <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if
          the minus sign, the value is negative.)
        </item>
        <item>One or more digits, with a single optional decimal point after the
          first digit and before the last digit.
        </item>
        <item>Optionally, "E"/"e" followed by an optional (positive exponent) or "-"
          (negative exponent) and followed by one or more digits specifying the
          exponent.
        </item>
      </list>
      <para>The string can also be "-INF", "-Infinity", "Infinity", "INF", quiet NaN
        ("NaN" /"-NaN") followed by any number of digits, or signaling NaN
        ("sNaN" /"-sNaN") followed by any number of digits, all in any
        combination of upper and lower case.
      </para>
      <para>All characters mentioned above are the corresponding characters in the
        Basic Latin range. In particular, the digits must be the basic digits 0
        to 9 (U+0030 to U+0039). The string is not allowed to contain white
        space characters, including spaces.
      </para>
    </summary>
    <param name='str'>A text string, a portion of which represents a number.
    </param>
    <param name='offset'>A zero-based index that identifies the start of the number.
    </param>
    <param name='length'>The length of the number within the string.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision decimal number with the same value as the given
      string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromUInt16(System.UInt16)'>
    <summary>Converts a 16-bit unsigned integer to an arbitrary-precision decimal
      number.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromUInt32(System.UInt32)'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal number.

    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.FromUInt64(System.UInt64)'>
    <summary>Converts a 64-bit unsigned integer to an arbitrary-precision decimal
      number.
    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.GetHashCode'>
    <summary>Calculates this object's hash code. No application or process IDs are used
      in the hash code calculation.
    </summary>
    <returns>This object's hash code.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EDecimal.IsFinite'>
    <summary>Gets a value indicating whether this object is finite (not infinity or
      NaN).
    </summary>
    <value><c>true</c> if this object is finite (not infinity or not-a-number (NaN)); otherwise,

      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.IsInfinity'>
    <summary>Gets a value indicating whether this object is positive or negative
      infinity.
    </summary>
    <returns><c>true</c> if this object is positive or negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.IsNaN'>
    <summary>Gets a value indicating whether this object is not a number (NaN).
    </summary>
    <returns><c>true</c> if this object is not a number (NaN); otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EDecimal.IsNegative'>
    <summary>Gets a value indicating whether this object is negative, including
      negative zero.
    </summary>
    <value><c>true</c> if this object is negative, including negative zero; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.IsNegativeInfinity'>
    <summary>Returns whether this object is negative infinity.
    </summary>
    <returns><c>true</c> if this object is negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.IsPositiveInfinity'>
    <summary>Returns whether this object is positive infinity.
    </summary>
    <returns><c>true</c> if this object is positive infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.IsQuietNaN'>
    <summary>Gets a value indicating whether this object is a quiet not-a-number value.

    </summary>
    <returns><c>true</c> if this object is a quiet not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.IsSignalingNaN'>
    <summary>Gets a value indicating whether this object is a signaling not-a-number
      value.
    </summary>
    <returns><c>true</c> if this object is a signaling not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EDecimal.IsZero'>
    <summary>Gets a value indicating whether this object's value equals 0.
    </summary>
    <value><c>true</c> if this object's value equals 0; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Log(PeterO.Numbers.EContext)'>
    <summary>Finds the natural logarithm of this object, that is, the power (exponent)
      that e (the base of natural logarithms) must be raised to in order to
      equal this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the ln function's results are
        generally not exact.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>Ln(this object). Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the result would be a complex number with a real
      part equal to Ln of this object's absolute value and an imaginary part
      equal to pi, but the return value is still NaN.). Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0). Signals no flags and returns negative infinity if this object's
      value is 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Log10(PeterO.Numbers.EContext)'>
    <summary>Finds the base-10 logarithm of this object, that is, the power (exponent)
      that the number 10 must be raised to in order to equal this object's
      value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the ln function's results are
        generally not exact.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and returns
      not-a-number (NaN) if this object is less than 0. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EDecimal.Mantissa'>
    <summary>Gets this object's unscaled value.
    </summary>
    <value>This object's unscaled value. Will be negative if this object's value is
      negative (including a negative NaN).
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Gets the greater value between two decimal numbers.
    </summary>
    <param name='first'>An arbitrary-precision decimal number.
    </param>
    <param name='second'>Another arbitrary-precision decimal number.
    </param>
    <returns>The larger value of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Max(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Gets the greater value between two decimal numbers.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>The larger value of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Gets the greater value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Max.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MaxMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Gets the greater value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Max.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Gets the lesser value between two decimal numbers.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <returns>The smaller value of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Min(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Gets the lesser value between two decimal numbers.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>The smaller value of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Gets the lesser value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Min.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MinMagnitude(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Gets the lesser value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Min.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger)'>
    <summary>Returns a number similar to this number but with the decimal point moved
      to the left.
    </summary>
    <param name='bigPlaces'>The number of decimal places to move the decimal point to the left. If
      this number is negative, instead moves the decimal point to the right by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is decreased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the decimal point moved
      to the left.
    </summary>
    <param name='bigPlaces'>The number of decimal places to move the decimal point to the left. If
      this number is negative, instead moves the decimal point to the right by
      this number's absolute value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>A number whose exponent is decreased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32)'>
    <summary>Returns a number similar to this number but with the decimal point moved
      to the left.
    </summary>
    <param name='places'>The number of decimal places to move the decimal point to the left. If
      this number is negative, instead moves the decimal point to the right by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is decreased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MovePointLeft(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the decimal point moved
      to the left.
    </summary>
    <param name='places'>The number of decimal places to move the decimal point to the left. If
      this number is negative, instead moves the decimal point to the right by
      this number's absolute value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>A number whose exponent is decreased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger)'>
    <summary>Returns a number similar to this number but with the decimal point moved
      to the right.
    </summary>
    <param name='bigPlaces'>The number of decimal places to move the decimal point to the right. If
      this number is negative, instead moves the decimal point to the left by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the decimal point moved
      to the right.
    </summary>
    <param name='bigPlaces'>The number of decimal places to move the decimal point to the right. If
      this number is negative, instead moves the decimal point to the left by
      this number's absolute value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32)'>
    <summary>Returns a number similar to this number but with the decimal point moved
      to the right.
    </summary>
    <param name='places'>The number of decimal places to move the decimal point to the right. If
      this number is negative, instead moves the decimal point to the left by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MovePointRight(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the decimal point moved
      to the right.
    </summary>
    <param name='places'>The number of decimal places to move the decimal point to the right. If
      this number is negative, instead moves the decimal point to the left by
      this number's absolute value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal)'>
    <summary>Multiplies two decimal numbers. The resulting exponent will be the sum of
      the exponents of the two decimal numbers.
    </summary>
    <param name='otherValue'>Another decimal number.
    </param>
    <returns>The product of the two decimal numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Multiplies two decimal numbers. The resulting scale will be the sum of the
      scales of the two decimal numbers. The result's sign is positive if both
      operands have the same sign, and negative if they have different signs.
    </summary>
    <param name='op'>Another decimal number.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>The product of the two decimal numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Multiplies by one decimal number, and then adds another decimal number.
    </summary>
    <param name='multiplicand'>The value to multiply.
    </param>
    <param name='augend'>The value to add.
    </param>
    <returns>The result this *
      <paramref name='multiplicand'/>
       +
      <paramref name='augend'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MultiplyAndAdd(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Multiplies by one value, and then adds another value.
    </summary>
    <param name='op'>The value to multiply.
    </param>
    <param name='augend'>The value to add.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
      If the precision doesn't indicate a simplified arithmetic, rounding and
      precision/exponent adjustment is done only once, namely, after multiplying
      and adding.
    </param>
    <returns>The result thisValue * multiplicand + augend.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.MultiplyAndSubtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Multiplies by one value, and then subtracts another value.
    </summary>
    <param name='op'>The value to multiply.
    </param>
    <param name='subtrahend'>The value to subtract.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
      If the precision doesn't indicate a simplified arithmetic, rounding and
      precision/exponent adjustment is done only once, namely, after multiplying
      and subtracting.
    </param>
    <returns>The result thisValue * multiplicand - subtrahend.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='op'/>
       or
      <paramref name='subtrahend'/>
       is null.
    </exception>
  </doc>
  <doc name='F:PeterO.Numbers.EDecimal.NaN'>
    <summary>A not-a-number value.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Negate'>
    <summary>Gets an object with the same value as this one, but with the sign
      reversed.
    </summary>
    <returns>An arbitrary-precision decimal number. If this value is positive zero,
      returns negative zero. Returns signaling NaN if this value is signaling
      NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Negate(PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but with the
      sign reversed.
    </summary>
    <param name='context'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision decimal number. If this value is positive zero,
      returns positive zero. Signals FlagInvalid and returns quiet NaN if this
      value is signaling NaN.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EDecimal.NegativeInfinity'>
    <summary>Negative infinity, less than any other number.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EDecimal.NegativeZero'>
    <summary>Represents the number negative zero.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.NextMinus(PeterO.Numbers.EContext)'>
    <summary>Finds the largest value that's smaller than the given value.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the largest value that's less than the given value. Returns
      negative infinity if the result is negative infinity. Signals FlagInvalid
      and returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null, the precision is 0, or
      <paramref name='ctx'/>
       has an unlimited exponent range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.NextPlus(PeterO.Numbers.EContext)'>
    <summary>Finds the smallest value that's greater than the given value.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the smallest value that's greater than the given value.Signals
      FlagInvalid and returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null, the precision is 0, or
      <paramref name='ctx'/>
       has an unlimited exponent range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.NextToward(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Finds the next value that is closer to the other object's value than this
      object's value. Returns a copy of this value with the same sign as the
      other value if both values are equal.
    </summary>
    <param name='otherValue'>An arbitrary-precision decimal number that the return value will approach.

    </param>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the next value that is closer to the other object' s value than
      this object's value. Signals FlagInvalid and returns NaN if the parameter
      <paramref name='ctx'/>
       is null, the precision is 0, or
      <paramref name='ctx'/>
       has an unlimited exponent range.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EDecimal.One'>
    <summary>Represents the number 1.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.PI(PeterO.Numbers.EContext)'>
    <summary>Finds the constant π, the circumference of a circle divided by its
      diameter.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as π can never be represented exactly.
      </i>
       .
    </param>
    <returns>The constant π rounded to the given precision. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Plus(PeterO.Numbers.EContext)'>
    <summary>Rounds this object's value to a given precision, using the given rounding
      mode and range of exponent, and also converts negative zero to positive
      zero.
    </summary>
    <param name='ctx'>A context for controlling the precision, rounding mode, and exponent
      range. Can be null, in which case the precision is unlimited and rounding
      isn't needed.
    </param>
    <returns>The closest value to this object's value, rounded to the specified
      precision. Returns the same value as this object if
      <paramref name='ctx'/>
       is null or the precision and exponent range are unlimited.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EDecimal.PositiveInfinity'>
    <summary>Positive infinity, greater than any other number.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Pow(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Raises this object's value to the given exponent.
    </summary>
    <param name='exponent'>An arbitrary-precision decimal number expressing the exponent to raise
      this object's value to.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>This^exponent. Signals the flag FlagInvalid and returns NaN if this object
      and exponent are both 0; or if this value is less than 0 and the exponent
      either has a fractional part or is infinity. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0), and the exponent has a fractional part.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Pow(System.Int32)'>
    <summary>Raises this object's value to the given exponent.
    </summary>
    <param name='exponentSmall'>The exponent to raise this object's value to.
    </param>
    <returns>This^exponent. Returns not-a-number (NaN) if this object and exponent are
      both 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Pow(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Raises this object's value to the given exponent.
    </summary>
    <param name='exponentSmall'>The exponent to raise this object's value to.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>This^exponent. Signals the flag FlagInvalid and returns NaN if this object
      and exponent are both 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Precision'>
    <summary>Finds the number of digits in this number's mantissa (significand).
      Returns 1 if this value is 0, and 0 if this value is infinity or
      not-a-number (NaN).
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but with the
      same exponent as another decimal number.
      <para>Note that this is not always the same as rounding to a given number of
        decimal places, since it can fail if the difference between this value's
        exponent and the desired exponent is too big, depending on the maximum
        precision. If rounding to a number of decimal places is desired, it's
        better to use the RoundToExponent and RoundToIntegral methods instead.
      </para>
      <para><b>Remark:</b> This method can be used to implement fixed-point decimal arithmetic, in
        which a fixed number of digits come after the decimal point. A
        fixed-point decimal arithmetic in which no digits come after the decimal
        point (a desired exponent of 0) is considered an "integer arithmetic".
      </para>
    </summary>
    <param name='otherValue'>A decimal number containing the desired exponent of the result. The
      mantissa (significand) is ignored. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the sixteenth (10b^-3, 0.0001b), and 3 means
      round to the sixteen-place (10b^3, 1000b). A value of 0 rounds the number
      to an integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if the result
      can't fit the given precision without rounding, or if the arithmetic
      context defines an exponent range and the given exponent is outside that
      range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value but a new exponent.
      <para>Note that this is not always the same as rounding to a given number of
        decimal places, since it can fail if the difference between this value's
        exponent and the desired exponent is too big, depending on the maximum
        precision. If rounding to a number of decimal places is desired, it's
        better to use the RoundToExponent and RoundToIntegral methods instead.
      </para>
      <para><b>Remark:</b> This method can be used to implement fixed-point decimal arithmetic, in
        which each decimal number has a fixed number of digits after the decimal
        point. The following code example returns a fixed-point number with up
        to 20 digits before and exactly 5 digits after the decimal point:
      </para>
      <code>// After performing arithmetic operations, adjust // the number to 5 //
        digits after the decimal point number = number.Quantize(
        EInteger.FromInt32(-5), // five digits after the decimal point
        EContext.ForPrecision(25) // 25-digit precision);</code> <para>A fixed-point decimal arithmetic in which no digits come after the
        decimal point (a desired exponent of 0) is considered an "integer
        arithmetic".
      </para>
    </summary>
    <param name='desiredExponent'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if this object
      is infinity, if the rounded result can't fit the given precision, or if
      the context defines an exponent range and the given exponent is outside
      that range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value but a new exponent.
      <para>Note that this is not always the same as rounding to a given number of
        decimal places, since it can fail if the difference between this value's
        exponent and the desired exponent is too big, depending on the maximum
        precision. If rounding to a number of decimal places is desired, it's
        better to use the RoundToExponent and RoundToIntegral methods instead.
      </para>
      <para><b>Remark:</b> This method can be used to implement fixed-point decimal arithmetic, in
        which each decimal number has a fixed number of digits after the decimal
        point. The following code example returns a fixed-point number with up
        to 20 digits before and exactly 5 digits after the decimal point:
      </para>
      <code>// After performing arithmetic operations, adjust // the number to 5
        digits after the decimal point number = number.Quantize(-5, // five
        digits after the decimal point EContext.ForPrecision(25) // 25-digit
        precision);</code> <para>A fixed-point decimal arithmetic in which no digits come after the
        decimal point (a desired exponent of 0) is considered an "integer
        arithmetic".
      </para>
    </summary>
    <param name='desiredExponentInt'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if this object
      is infinity, if the rounded result can't fit the given precision, or if
      the context defines an exponent range and the given exponent is outside
      that range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Quantize(System.Int32,PeterO.Numbers.ERounding)'>
    <summary>Returns a decimal number with the same value as this one but a new
      exponent.
      <para><b>Remark:</b> This method can be used to implement fixed-point decimal arithmetic, in
        which a fixed number of digits come after the decimal point. A
        fixed-point decimal arithmetic in which no digits come after the decimal
        point (a desired exponent of 0) is considered an "integer arithmetic".
      </para>
    </summary>
    <param name='desiredExponentInt'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='rounding'>A rounding mode to use in case the result needs to be rounded to fit the
      given exponent.
    </param>
    <returns>A decimal number with the same value as this object but with the exponent
      changed. Returns not-a-number (NaN) if this object is infinity, or if the
      rounding mode is ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Reduce(PeterO.Numbers.EContext)'>
    <summary>Removes trailing zeros from this object's mantissa (significand). For
      example, 1.00 becomes 1.
      <para>If this object's value is 0, changes the exponent to 0.
      </para>
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>This value with trailing zeros removed. Note that if the result has a very
      high exponent and the context says to clamp high exponents, there may
      still be some trailing zeros in the mantissa (significand).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Remainder(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Finds the remainder that results when dividing two arbitrary-precision
      decimal numbers. The remainder is the value that remains when the absolute
      value of this object is divided by the absolute value of the other object;
      the remainder has the same sign (positive or negative) as this object's
      value.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used both in the
      division portion and in the remainder portion of the remainder
      calculation. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no additional rounding
      (other than the rounding from integer division) is needed.
    </param>
    <returns>The remainder of the two numbers. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor is 0, or if the result doesn't fit the
      given precision.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal)'>
    <summary>Calculates the remainder of a number by the formula
      <c>"this" - (("this" / "divisor") * "divisor")</c> .
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RemainderNaturalScale(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Calculates the remainder of a number by the formula "this" - (("this" /
      "divisor") * "divisor").
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the return value to have a higher precision than given in this
      context. Flags will be set on the given context only if the context's
      <c>HasFlags</c> is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RemainderNear(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Finds the distance to the closest multiple of the given divisor, based on
      the result of dividing this object's value by another object's value.
      <list type=''>
        <item>If this and the other object divide evenly, the result is 0.
        </item>
        <item>If the remainder's absolute value is less than half of the divisor's
          absolute value, the result has the same sign as this object and will
          be the distance to the closest multiple.
        </item>
        <item>If the remainder's absolute value is more than half of the divisor' s
          absolute value, the result has the opposite sign of this object and
          will be the distance to the closest multiple.
        </item>
        <item>If the remainder's absolute value is exactly half of the divisor's
          absolute value, the result has the opposite sign of this object if the
          quotient, rounded down, is odd, and has the same sign as this object
          if the quotient, rounded down, is even, and the result's absolute
          value is half of the divisor's absolute value.
        </item>
      </list>
       This function is also known as the "IEEE Remainder" function.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision. The rounding and
      exponent range settings of this context are ignored (the rounding mode is
      always treated as HalfEven). If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which the precision is unlimited.
    </param>
    <returns>The distance of the closest multiple. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor is 0, or either the result of integer
      division (the quotient) or the remainder wouldn't fit the given precision.

    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      a new exponent if necessary, using the HalfEven rounding mode.
    </summary>
    <param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <returns>A decimal number rounded to the closest value representable for the given
      exponent.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      a new exponent if necessary.
    </summary>
    <param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number rounded to the closest value representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to the given exponent when rounding, and the given
      exponent is outside of the valid range of the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      a new exponent if necessary, using the given rounding mode.
    </summary>
    <param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='rounding'>Desired mode for rounding this number's value.
    </param>
    <returns>A decimal number rounded to the closest value representable for the given
      exponent.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      a new exponent if necessary, using the HalfEven rounding mode.
    </summary>
    <param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <returns>A decimal number rounded to the closest value representable for the given
      exponent.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      a new exponent if necessary.
    </summary>
    <param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number rounded to the closest value representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to the given exponent when rounding, and the given
      exponent is outside of the valid range of the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponent(System.Int32,PeterO.Numbers.ERounding)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      a new exponent if necessary.
    </summary>
    <param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='rounding'>The desired mode to use to round the given number to the given exponent.
    </param>
    <returns>A decimal number rounded to the given negative number of decimal places.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      the given exponent, and signals an inexact flag if the result would be
      inexact.
    </summary>
    <param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number rounded to the closest value representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to the given exponent
      when rounding, and the given exponent is outside of the valid range of the
      arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary>
    <param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number rounded to the closest value representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to the given exponent
      when rounding, and the given exponent is outside of the valid range of the
      arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToExponentExact(System.Int32,PeterO.Numbers.ERounding)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary>
    <param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='rounding'>Desired mode for rounding this object's value.
    </param>
    <returns>A decimal number rounded to the closest value representable using the
      given exponent.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToIntegerExact(PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number rounded to the closest integer representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to 0 when rounding, and 0
      is outside of the valid range of the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      an integer, without adding the
      <c>FlagInexact</c> or
      <c>FlagRounded</c> flags.
    </summary>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags), except
      that this function will never add the
      <c>FlagRounded</c> and
      <c>FlagInexact</c> flags (the only difference between this and RoundToExponentExact). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number rounded to the closest integer representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to 0 when rounding, and 0 is outside of the valid range of
      the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToIntegralExact(PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number rounded to the closest integer representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to 0 when rounding, and 0
      is outside of the valid range of the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)'>
    <summary>Returns a decimal number with the same value as this object but rounded to
      an integer, without adding the
      <c>FlagInexact</c> or
      <c>FlagRounded</c> flags.
    </summary>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags), except
      that this function will never add the
      <c>FlagRounded</c> and
      <c>FlagInexact</c> flags (the only difference between this and RoundToExponentExact). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A decimal number rounded to the closest integer representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to 0 when rounding, and 0 is outside of the valid range of
      the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.RoundToPrecision(PeterO.Numbers.EContext)'>
    <summary>Rounds this object's value to a given precision, using the given rounding
      mode and range of exponent.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The closest value to this object's value, rounded to the specified
      precision. Returns the same value as this object if
      <paramref name='ctx'/>
       is null or the precision and exponent range are unlimited.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger)'>
    <summary>Returns a number similar to this number but with the scale adjusted.
    </summary>
    <param name='bigPlaces'>The power of 10 to scale by.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with its scale adjusted.
    </summary>
    <param name='bigPlaces'>The power of 10 to scale by.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32)'>
    <summary>Returns a number similar to this number but with the scale adjusted.
    </summary>
    <param name='places'>The power of 10 to scale by.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ScaleByPowerOfTen(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the scale adjusted.
    </summary>
    <param name='places'>The power of 10 to scale by.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EDecimal.Sign'>
    <summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary>
    <value>This value's sign: -1 if negative; 1 if positive; 0 if zero.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.EDecimal.SignalingNaN'>
    <summary>A not-a-number value that signals an invalid operation flag when it's
      passed as an argument to any arithmetic operation in arbitrary-precision
      decimal.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Sqrt(PeterO.Numbers.EContext)'>
    <summary>Finds the square root of this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the square root function's results are
        generally not exact for many inputs.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>The square root. Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the square root would be a complex number, but the
      return value is still NaN). Signals FlagInvalid and returns not-a-number
      (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.SquareRoot(PeterO.Numbers.EContext)'>
    <summary>Finds the square root of this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the square root function's results are
        generally not exact for many inputs.
      </i>
       (Unlike in the General Decimal Arithmetic Specification, any rounding
      mode is allowed.).
    </param>
    <returns>The square root. Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the square root would be a complex number, but the
      return value is still NaN). Signals FlagInvalid and returns not-a-number
      (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal)'>
    <summary>Subtracts an arbitrary-precision decimal number from this instance and
      returns the result.
    </summary>
    <param name='otherValue'>The number to subtract from this instance's value.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Subtract(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)'>
    <summary>Subtracts an arbitrary-precision decimal number from this instance.
    </summary>
    <param name='otherValue'>The number to subtract from this instance's value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EDecimal.Ten'>
    <summary>Represents the number 10.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToByteChecked'>
    <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a byte (from 0 to 255).
    </returns>
    <exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 255.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToByteIfExact'>
    <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a byte (from 0 to 255).
    </returns>
    <exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 255.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToByteUnchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a byte (from 0 to
      255).
    </summary>
    <returns>This number, converted to a byte (from 0 to 255). Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToDecimal'>
    <summary>Converts this value to a
      <c>decimal</c> under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), using the half-even rounding mode.
    </summary>
    <returns>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToDouble'>
    <summary>Converts this value to its closest equivalent as a 64-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 64-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary>
    <returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToEFloat'>
    <summary>Creates a binary floating-point number from this object's value. Note that
      if the binary floating-point number contains a negative exponent, the
      resulting value might not be exact, in which case the resulting binary
      float will be an approximation of this decimal number's value.
    </summary>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToEFloat(PeterO.Numbers.EContext)'>
    <summary>Creates a binary floating-point number from this object's value. Note that
      if the binary floating-point number contains a negative exponent, the
      resulting value might not be exact, in which case the resulting binary
      float will be an approximation of this decimal number's value.
    </summary>
    <param name='ec'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>An arbitrary-precision float floating-point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToEInteger'>
    <summary>Converts this value to an arbitrary-precision integer. Any fractional part
      in this value will be discarded when converting to an arbitrary-precision
      integer.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToEIntegerExact'>
    <summary>Converts this value to an arbitrary-precision integer, checking whether
      the fractional part of the value would be lost.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>This object's value is not an exact integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToEIntegerIfExact'>
    <summary>Converts this value to an arbitrary-precision integer, checking whether
      the fractional part of the value would be lost.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToEngineeringString'>
    <summary>Same as ToString(), except that when an exponent is used it will be a
      multiple of 3.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToExtendedFloat'>
    <summary>Creates a binary floating-point number from this object's value. Note that
      if the binary floating-point number contains a negative exponent, the
      resulting value might not be exact, in which case the resulting binary
      float will be an approximation of this decimal number's value.
    </summary>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt16Checked'>
    <summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 16-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -32768 or greater than 32767.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt16IfExact'>
    <summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 16-bit signed integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -32768 or greater than 32767.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt16Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 16-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt32Checked'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 32-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -2147483648 or greater than 2147483647.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt32IfExact'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -2147483648 or greater than 2147483647.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt32Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 32-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt64Checked'>
    <summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 64-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -9223372036854775808 or greater than 9223372036854775807.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt64IfExact'>
    <summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 64-bit signed integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -9223372036854775808 or greater than 9223372036854775807.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToInt64Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 64-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToPlainString'>
    <summary>Converts this value to a string, but without using exponential notation.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToSByteChecked'>
    <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to an 8-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than -128 or greater than 127.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToSByteIfExact'>
    <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as an 8-bit signed integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than -128 or greater than 127.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToSByteUnchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as an 8-bit signed
      integer.
    </summary>
    <returns>This number, converted to an 8-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToSingle'>
    <summary>Converts this value to its closest equivalent as a 32-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary>
    <returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToString'>
    <summary>Converts this value to a string. Returns a value compatible with this
      class's FromString method.
    </summary>
    <returns>A string representation of this object. The text string will be in
      exponential notation if the exponent is greater than 0 or if the number's
      first nonzero digit is more than five digits after the decimal point.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt16Checked'>
    <summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 16-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 65535.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt16IfExact'>
    <summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer without rounding to a different numerical value.

    </summary>
    <returns>This number's value as a 16-bit unsigned integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 65535.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt16Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit unsigned
      integer.
    </summary>
    <returns>This number, converted to a 16-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt32Checked'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 32-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 4294967295.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt32IfExact'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 4294967295.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt32Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 32-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt64Checked'>
    <summary>Converts this number's value to a 64-bit unsigned integer if it can fit in
      a 64-bit unsigned integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 64-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is infinity or not-a-number, or the truncated integer is less
      than 0 or greater than 18446744073709551615.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt64IfExact'>
    <summary>Converts this number's value to a 64-bit unsigned integer if it can fit in
      a 64-bit unsigned integer without rounding to a different numerical value.

    </summary>
    <returns>This number's value as a 64-bit unsigned integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>This value is infinity or not-a-number, is not an exact integer, or is
      less than 0 or greater than 18446744073709551615.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.ToUInt64Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit unsigned
      integer.
    </summary>
    <returns>This number, converted to a 64-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.Ulp'>
    <summary>Returns the unit in the last place. The mantissa (significand) will be 1
      and the exponent will be this number's exponent. Returns 1 with an
      exponent of 0 if this number is infinity or not-a-number (NaN).
    </summary>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EDecimal.UnsignedMantissa'>
    <summary>Gets the absolute value of this object's unscaled value.
    </summary>
    <value>The absolute value of this object's unscaled value.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.EDecimal.Zero'>
    <summary>Represents the number 0.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Addition(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Adds two arbitrary-precision decimal floating-point numbers and returns
      the result.
    </summary>
    <param name='bthis'>The first arbitrary-precision decimal floating-point number.
    </param>
    <param name='otherValue'>The second decimal binary floating-point number.
    </param>
    <returns>The sum of the two objects.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       or
      <paramref name='otherValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Division(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Divides this object by another decimal number and returns the result. When
      possible, the result will be exact.
    </summary>
    <param name='dividend'>The number that will be divided by the divisor.
    </param>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>The quotient of the two numbers. Returns infinity if the divisor is 0 and
      the dividend is nonzero. Returns not-a-number (NaN) if the divisor and the
      dividend are 0. Returns NaN if the result can't be exact because it would
      have a nonterminating decimal expansion.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.EInteger'>
    <summary>Converts an arbitrary-precision decimal floating-point number to an
      arbitrary-precision integer. Any fractional part in this value will be
      discarded when converting to an arbitrary-precision integer.
    </summary>
    <param name='bigValue'>The number to convert as an arbitrary-precision decimal.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Byte'>
    <summary>Converts an arbitrary-precision decimal number to a byte (from 0 to 255)
      if it can fit in a byte (from 0 to 255) after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a byte (from 0 to 255).
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 255.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Decimal'>
    <summary>Converts an arbitrary-precision decimal's value to a
      <c>decimal</c> under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), using the half-even rounding mode.
    </summary>
    <param name='bigValue'>The parameter
      <paramref name='bigValue'/>
       is an arbitrary-precision decimal floating-point number.
    </param>
    <returns>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Double'>
    <summary>Converts this value to its closest equivalent as a 64-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 64-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary>
    <param name='bigValue'>The value to convert to a 64-bit floating-point number.
    </param>
    <returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int16'>
    <summary>Converts an arbitrary-precision decimal number to a 16-bit signed integer
      if it can fit in a 16-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than -32768
      or greater than 32767.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int32'>
    <summary>Converts an arbitrary-precision decimal number to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than
      -2147483648 or greater than 2147483647.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Int64'>
    <summary>Converts an arbitrary-precision decimal number to a 64-bit signed integer
      if it can fit in a 64-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than
      -9223372036854775808 or greater than 9223372036854775807.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.SByte'>
    <summary>Converts an arbitrary-precision decimal number to an 8-bit signed integer
      if it can fit in an 8-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to an 8-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than -128
      or greater than 127.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.Single'>
    <summary>Converts this value to its closest equivalent as a 32-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary>
    <param name='bigValue'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt16'>
    <summary>Converts an arbitrary-precision decimal number to a 16-bit unsigned
      integer if it can fit in a 16-bit unsigned integer after truncating to an
      integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 65535.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt32'>
    <summary>Converts an arbitrary-precision decimal number to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 4294967295.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Explicit(PeterO.Numbers.EDecimal)~System.UInt64'>
    <summary>Converts an arbitrary-precision decimal number to a 64-bit unsigned
      integer if it can fit in a 64-bit unsigned integer after truncating to an
      integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is infinity or not-a-number, or the truncated integer is less than 0 or
      greater than 18446744073709551615.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EDecimal'>
    <summary>Converts an arbitrary-precision integer to an arbitrary precision decimal.

    </summary>
    <param name='eint'>An arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision decimal number with the exponent set to 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.Byte)~PeterO.Numbers.EDecimal'>
    <summary>Converts a byte (from 0 to 255) to an arbitrary-precision decimal number.
    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.Decimal)~PeterO.Numbers.EDecimal'>
    <summary>Converts an arbitrary-precision decimal number to a
      <c>decimal</c> under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), using the half-even rounding mode.
    </summary>
    <param name='dec'>The number to convert as an arbitrary-precision decimal floating-point
      number.
    </param>
    <returns>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.Int16)~PeterO.Numbers.EDecimal'>
    <summary>Converts a 16-bit signed integer to an arbitrary-precision decimal number.

    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.Int32)~PeterO.Numbers.EDecimal'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal number.

    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.Int64)~PeterO.Numbers.EDecimal'>
    <summary>Converts a 64-bit signed integer to an arbitrary-precision decimal number.

    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.SByte)~PeterO.Numbers.EDecimal'>
    <summary>Converts an 8-bit signed integer to an arbitrary-precision decimal number.

    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt16)~PeterO.Numbers.EDecimal'>
    <summary>Converts a 16-bit unsigned integer to an arbitrary-precision decimal
      number.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt32)~PeterO.Numbers.EDecimal'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision decimal number.

    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Implicit(System.UInt64)~PeterO.Numbers.EDecimal'>
    <summary>Converts a 64-bit unsigned integer to an arbitrary-precision decimal
      number.
    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Modulus(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Finds the remainder when dividing one arbitrary-precision decimal number
      by another.
    </summary>
    <param name='dividend'>The number that will be divided by the divisor.
    </param>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>The result of the operation.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Multiply(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Multiplies two decimal numbers. The resulting exponent will be the sum of
      the exponents of the two decimal numbers.
    </summary>
    <param name='operand1'>The first operand.
    </param>
    <param name='operand2'>The second operand.
    </param>
    <returns>The product of the two decimal numbers.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='operand1'/>
       or
      <paramref name='operand2'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_Subtraction(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)'>
    <summary>Subtracts one arbitrary-precision decimal number from another and returns
      the result.
    </summary>
    <param name='bthis'>The first operand.
    </param>
    <param name='subtrahend'>The second operand.
    </param>
    <returns>The difference of the two decimal numbers.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       or
      <paramref name='subtrahend'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EDecimal.op_UnaryNegation(PeterO.Numbers.EDecimal)'>
    <summary>Gets an arbitrary-precision decimal number with the same value as the
      given one, but with the sign reversed.
    </summary>
    <param name='bigValue'>An arbitrary-precision decimal number to negate.
    </param>
    <returns>An arbitrary-precision decimal number. If this value is positive zero,
      returns negative zero. Returns signaling NaN if this value is signaling
      NaN.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigValue'/>
       is null.
    </exception>
  </doc>
  <doc name='T:PeterO.Numbers.EFloat'>
    <summary>Represents an arbitrary-precision binary floating-point number. (The "E"
      stands for "extended", meaning that instances of this class can be values
      other than numbers proper, such as infinity and not-a-number.) Each number
      consists of an integer mantissa (significand) and an integer exponent,
      both arbitrary-precision. The value of the number equals mantissa
      (significand) * 2^exponent. This class also supports values for negative
      zero, not-a-number (NaN) values, and infinity.
      <para>Passing a signaling NaN to any arithmetic operation shown here will
        signal the flag FlagInvalid and return a quiet NaN, even if another
        operand to that operation is a quiet NaN, unless noted otherwise.
      </para>
      <para>Passing a quiet NaN to any arithmetic operation shown here will return a
        quiet NaN, unless noted otherwise.
      </para>
      <para>Unless noted otherwise,passing a null arbitrary-precision binary float
        argument to any method here will throw an exception.
      </para>
      <para>When an arithmetic operation signals the flag FlagInvalid, FlagOverflow,
        or FlagDivideByZero, it will not throw an exception too, unless the
        operation's trap is enabled in the precision context (see EContext's
        Traps property).
      </para>
      <para>An arbitrary-precision binary float value can be serialized in one of
        the following ways:
      </para>
      <list>
        <item>By calling the toString() method. However, not all strings can be
          converted back to an arbitrary-precision binary float without loss,
          especially if the string has a fractional part.
        </item>
        <item>By calling the UnsignedMantissa, Exponent, and IsNegative properties,
          and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods.
          The return values combined will uniquely identify a particular
          arbitrary-precision binary float value.
        </item>
      </list>
      <para>If an operation requires creating an intermediate value that might be
        too big to fit in memory (or might require more than 2 gigabytes of
        memory to store -- due to the current use of a 32-bit integer internally
        as a length), the operation may signal an invalid-operation flag and
        return not-a-number (NaN). In certain rare cases, the CompareTo method
        may throw OutOfMemoryException (called OutOfMemoryError in Java) in the
        same circumstances.
      </para>
      <para><b>Thread safety</b> </para>
      <para>Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
      <para><b>Comparison considerations</b> </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. The CompareTo method compares the mathematical values of
        the two instances passed to it (and considers two different NaN values
        as equal), while two instances with the same mathematical value, but
        different exponents, will be considered unequal under the Equals method.

      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Abs'>
    <summary>Finds the absolute value of this object (if it's negative, it becomes
      positive).
    </summary>
    <returns>An arbitrary-precision binary float. Returns signaling NaN if this value
      is signaling NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Abs(PeterO.Numbers.EContext)'>
    <summary>Finds the absolute value of this object (if it's negative, it becomes
      positive).
    </summary>
    <param name='context'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The absolute value of this object. Signals FlagInvalid and returns quiet
      NaN if this value is signaling NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat)'>
    <summary>Adds this object and another binary float and returns the result.
    </summary>
    <param name='otherValue'>An arbitrary-precision binary float.
    </param>
    <returns>The sum of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Add(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Finds the sum of this object and another object. The result's exponent is
      set to the lower of the exponents of the two operands.
    </summary>
    <param name='otherValue'>The number to add to.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The sum of thisValue and the other object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateNewWithFlags(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='mantissa'>The parameter
      <paramref name='mantissa'/>
       is an internal parameter.
    </param>
    <param name='exponent'>The parameter
      <paramref name='exponent'/>
       is an internal parameter.
    </param>
    <param name='flags'>The parameter
      <paramref name='flags'/>
       is an internal parameter.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulator(PeterO.Numbers.EInteger)'>
    <summary>This is an internal method.
    </summary>
    <param name='bigint'>An arbitrary-precision integer.
    </param>
    <returns>An IShiftAccumulator object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.CreateShiftAccumulatorWithDigits(PeterO.Numbers.EInteger,System.Int32,System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='bigint'>An arbitrary-precision integer.
    </param>
    <param name='lastDigit'>The parameter
      <paramref name='lastDigit'/>
       is a 32-bit signed integer.
    </param>
    <param name='olderDigits'>The parameter
      <paramref name='olderDigits'/>
       is a 32-bit signed integer.
    </param>
    <returns>An IShiftAccumulator object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.DivisionShift(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>This is an internal method.
    </summary>
    <param name='num'>An arbitrary-precision integer.
    </param>
    <param name='den'>Another arbitrary-precision integer.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.GetArithmeticSupport'>
    <summary>This is an internal method.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.GetExponent(PeterO.Numbers.EFloat)'>
    <summary>This is an internal method.
    </summary>
    <param name='value'>An arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.GetFlags(PeterO.Numbers.EFloat)'>
    <summary>This is an internal method.
    </summary>
    <param name='value'>An arbitrary-precision binary float.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.GetMantissa(PeterO.Numbers.EFloat)'>
    <summary>This is an internal method.
    </summary>
    <param name='value'>An arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.GetRadix'>
    <summary>This is an internal method.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.GetSign(PeterO.Numbers.EFloat)'>
    <summary>This is an internal method.
    </summary>
    <param name='value'>An arbitrary-precision binary float.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.MultiplyByRadixPower(PeterO.Numbers.EInteger,PeterO.Numbers.FastInteger)'>
    <summary>This is an internal method.
    </summary>
    <param name='bigint'>Another arbitrary-precision integer.
    </param>
    <param name='power'>A fast integer.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.BinaryMathHelper.ValueOf(System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is a 32-bit signed integer.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CompareTo(PeterO.Numbers.EFloat)'>
    <summary>Compares the mathematical values of this object and another object,
      accepting NaN values.
      <para>This method is not consistent with the Equals method because two
        different numbers with the same mathematical value, but different
        exponents, will compare as equal.
      </para>
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN, this
        method will not trigger an error. Instead, NaN will compare greater than
        any other number, including infinity. Two different NaN values will be
        considered equal.
      </para>
    </summary>
    <param name='other'>An arbitrary-precision binary float.
    </param>
    <returns>Less than 0 if this object's value is less than the other value, or
      greater than 0 if this object's value is greater than the other value or
      if
      <paramref name='other'/>
       is null, or 0 if both values are equal.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CompareToSignal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Compares the mathematical values of this object and another object,
      treating quiet NaN as signaling.
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN, this
        method will return a quiet NaN and will signal a FlagInvalid flag.
      </para>
    </summary>
    <param name='other'>An arbitrary-precision binary float.
    </param>
    <param name='ctx'>An arithmetic context. The precision, rounding, and exponent range are
      ignored. If
      <c>HasFlags</c> of the context is true, will store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null.
    </param>
    <returns>Quiet NaN if this object or the other object is NaN, or 0 if both objects
      have the same value, or -1 if this object is less than the other value, or
      1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat)'>
    <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision binary float to compare with this one.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CompareToTotal(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision binary float to compare with this one.
    </param>
    <param name='ctx'>An arithmetic context. Flags will be set in this context only if
      <c>HasFlags</c> and
      <c>IsSimplified</c> of the context are true and only if an operand needed to be rounded
      before carrying out the operation. Can be null.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater. Does not signal
      flags if either value is signaling NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CompareToTotalMagnitude(PeterO.Numbers.EFloat)'>
    <summary>Compares the absolute values of this object and another object, imposing a
      total ordering on all possible values (ignoring their signs). In this
      method:
      <list>
        <item>For objects with the same value, the one with the higher exponent has
          a greater "absolute value".
        </item>
        <item>Negative zero and positive zero are considered equal.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision binary float to compare with this one.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CompareToWithContext(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Compares the mathematical values of this object and another object.
      <para>In this method, negative zero and positive zero are considered equal.
      </para>
      <para>If this object or the other object is a quiet NaN or signaling NaN, this
        method returns a quiet NaN, and will signal a FlagInvalid flag if either
        is a signaling NaN.
      </para>
    </summary>
    <param name='other'>An arbitrary-precision binary float.
    </param>
    <param name='ctx'>An arithmetic context. The precision, rounding, and exponent range are
      ignored. If
      <c>HasFlags</c> of the context is true, will store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null.
    </param>
    <returns>Quiet NaN if this object or the other object is NaN, or 0 if both objects
      have the same value, or -1 if this object is less than the other value, or
      1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CopySign(PeterO.Numbers.EFloat)'>
    <summary>Returns a number with the same value as this one, but copying the sign
      (positive or negative) of another number.
    </summary>
    <param name='other'>A number whose sign will be copied.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Creates a number with the value exponent*2^mantissa (significand).
    </summary>
    <param name='mantissa'>Desired value for the mantissa.
    </param>
    <param name='exponent'>Desired value for the exponent.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "mantissa (significand)" or
      <paramref name='exponent'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Create(System.Int32,System.Int32)'>
    <summary>Creates a number with the value exponent*2^mantissa (significand).
    </summary>
    <param name='mantissaSmall'>Desired value for the mantissa.
    </param>
    <param name='exponentSmall'>Desired value for the exponent.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger)'>
    <summary>Creates a not-a-number arbitrary-precision binary float.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <returns>A quiet not-a-number.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='diag'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='diag'/>
       is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean,PeterO.Numbers.EContext)'>
    <summary>Creates a not-a-number arbitrary-precision binary float.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <param name='signaling'>Whether the return value will be signaling (true) or quiet (false).
    </param>
    <param name='negative'>Whether the return value is negative.
    </param>
    <param name='ctx'>An arithmetic context to control the precision (in bits) of the diagnostic
      information. The rounding and exponent range of this context will be
      ignored. Can be null. The only flag that can be signaled in this context
      is FlagInvalid, which happens if diagnostic information needs to be
      truncated and too much memory is required to do so.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat)'>
    <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <returns>A 2 element array consisting of the quotient and remainder in that order.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivRemNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the remainder to have a higher precision than given in this context.
      Flags will be set on the given context only if the context's
      <c>HasFlags</c> is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param>
    <returns>A 2 element array consisting of the quotient and remainder in that order.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat)'>
    <summary>Divides this object by another binary float and returns the result. When
      possible, the result will be exact.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <returns>The quotient of the two numbers. Returns infinity if the divisor is 0 and
      the dividend is nonzero. Returns not-a-number (NaN) if the divisor and the
      dividend are 0. Returns NaN if the result can't be exact because it would
      have a nonterminating binary expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Divide(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Divides this arbitrary-precision binary float by another
      arbitrary-precision binary float. The preferred exponent for the result is
      this object's exponent minus the divisor's exponent.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0; or, either
      <paramref name='ctx'/>
       is null or
      <paramref name='ctx'/>
       's precision is 0, and the result would have a nonterminating binary
      expansion; or, the rounding mode is ERounding.None and the result is not
      exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat)'>
    <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <returns>A 2 element array consisting of the quotient and remainder in that order.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideAndRemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Calculates the quotient and remainder using the
      DivideToIntegerNaturalScale and the formula in RemainderNaturalScale.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the remainder to have a higher precision than given in this context.
      Flags will be set on the given context only if the context's
      <c>HasFlags</c> is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param>
    <returns>A 2 element array consisting of the quotient and remainder in that order.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Divides two arbitrary-precision binary floats, and gives a particular
      exponent to the result.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <param name='exponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual radix point (so a negative number means the number of
      binary digit places to round to). A positive number places the cutoff
      point to the left of the usual radix point.
    </param>
    <param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)'>
    <summary>Divides two arbitrary-precision binary floats, and gives a particular
      exponent to the result.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <param name='desiredExponent'>The desired exponent. A negative number places the cutoff point to the
      right of the usual radix point (so a negative number means the number of
      binary digit places to round to). A positive number places the cutoff
      point to the left of the usual radix point.
    </param>
    <param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Returns
      not-a-number (NaN) if the divisor and the dividend are 0. Returns NaN if
      the rounding mode is ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.EContext)'>
    <summary>Divides two arbitrary-precision binary floats, and gives a particular
      exponent to the result.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual radix point (so a negative number means the number of
      binary digit places to round to). A positive number places the cutoff
      point to the left of the usual radix point.
    </param>
    <param name='ctx'>An arithmetic context object to control the rounding mode to use if the
      result must be scaled down to have the same exponent as this value. If the
      precision given in the context is other than 0, calls the Quantize method
      with both arguments equal to the result of the operation (and can signal
      FlagInvalid and return NaN if the result doesn't fit the given precision).
      If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the context
      defines an exponent range and the desired exponent is outside that range.
      Signals FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideToExponent(PeterO.Numbers.EFloat,System.Int64,PeterO.Numbers.ERounding)'>
    <summary>Divides two arbitrary-precision binary floats, and gives a particular
      exponent to the result.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <param name='desiredExponentSmall'>The desired exponent. A negative number places the cutoff point to the
      right of the usual radix point (so a negative number means the number of
      binary digit places to round to). A positive number places the cutoff
      point to the left of the usual radix point.
    </param>
    <param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param>
    <returns>The quotient of the two objects. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat)'>
    <summary>Divides two arbitrary-precision binary floats, and returns the integer
      part of the result, rounded down, with the preferred exponent set to this
      value's exponent minus the divisor's exponent.
    </summary>
    <param name='divisor'>An arbitrary-precision binary float to divide by.
    </param>
    <returns>The integer part of the quotient of the two objects. Signals
      FlagDivideByZero and returns infinity if the divisor is 0 and the dividend
      is nonzero. Signals FlagInvalid and returns not-a-number (NaN) if the
      divisor and the dividend are 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideToIntegerNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Divides this object by another object, and returns the integer part of the
      result (which is initially rounded down), with the preferred exponent set
      to this value's exponent minus the divisor's exponent.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the integer part of the result. Flags will be set on the
      given context only if the context's
      <c>HasFlags</c> is true and the integer part of the result doesn't fit the precision and
      exponent range without rounding. Can be null, in which the precision is
      unlimited and no additional rounding, other than the rounding down to an
      integer after division, is needed.
    </param>
    <returns>The integer part of the quotient of the two objects. Signals FlagInvalid
      and returns not-a-number (NaN) if the return value would overflow the
      exponent range. Signals FlagDivideByZero and returns infinity if the
      divisor is 0 and the dividend is nonzero. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor and the dividend are 0. Signals
      FlagInvalid and returns not-a-number (NaN) if the rounding mode is
      ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideToIntegerZeroScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Divides this object by another object, and returns the integer part of the
      result, with the exponent set to 0.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision. The rounding and
      exponent range settings of this context are ignored. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited.
    </param>
    <returns>The integer part of the quotient of the two objects. The exponent will be
      set to 0. Signals FlagDivideByZero and returns infinity if the divisor is
      0 and the dividend is nonzero. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor and the dividend are 0, or if the result
      doesn't fit the given precision.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.DivideToSameExponent(PeterO.Numbers.EFloat,PeterO.Numbers.ERounding)'>
    <summary>Divides this object by another binary float and returns a result with the
      same exponent as this object (the dividend).
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='rounding'>The rounding mode to use if the result must be scaled down to have the
      same exponent as this value.
    </param>
    <returns>The quotient of the two numbers. Signals FlagDivideByZero and returns
      infinity if the divisor is 0 and the dividend is nonzero. Signals
      FlagInvalid and returns not-a-number (NaN) if the divisor and the dividend
      are 0. Signals FlagInvalid and returns not-a-number (NaN) if the rounding
      mode is ERounding.None and the result is not exact.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Equals(PeterO.Numbers.EFloat)'>
    <summary>Determines whether this object's mantissa (significand), exponent, and
      properties are equal to those of another object. Not-a-number values are
      considered equal if the rest of their properties are equal.
    </summary>
    <param name='other'>An arbitrary-precision binary float.
    </param>
    <returns><c>true</c> if this object's mantissa (significand) and exponent are equal to those
      of another object; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Equals(System.Object)'>
    <summary>Determines whether this object's mantissa (significand), exponent, and
      properties are equal to those of another object and that other object is
      an arbitrary-precision binary float. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.EqualsInternal(PeterO.Numbers.EFloat)'>
    <summary>Determines whether this object's mantissa (significand) and exponent are
      equal to those of another object.
    </summary>
    <param name='otherValue'>An arbitrary-precision binary float.
    </param>
    <returns><c>true</c> if this object's mantissa (significand) and exponent are equal to those
      of another object; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Exp(PeterO.Numbers.EContext)'>
    <summary>Finds e (the base of natural logarithms) raised to the power of this
      object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the exponential function's results are
        generally not exact.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>Exponential of this object. If this object's value is 1, returns an
      approximation to " e" within the given precision. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EFloat.Exponent'>
    <summary>Gets this object's exponent. This object's value will be an integer if the
      exponent is positive or zero.
    </summary>
    <value>This object's exponent. This object's value will be an integer if the
      exponent is positive or zero.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromByte(System.Byte)'>
    <summary>Converts a byte (from 0 to 255) to an arbitrary-precision binary float.
    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>This number's value as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromDouble(System.Double)'>
    <summary>Creates a binary float from a 64-bit floating-point number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first.
    </summary>
    <param name='dbl'>The parameter
      <paramref name='dbl'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A binary float with the same value as
      <paramref name='dbl'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromEInteger(PeterO.Numbers.EInteger)'>
    <summary>Converts an arbitrary-precision integer to the same value as a binary
      float.
    </summary>
    <param name='bigint'>An arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromInt16(System.Int16)'>
    <summary>Converts a 16-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromInt32(System.Int32)'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromInt64(System.Int64)'>
    <summary>Converts a 64-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromSByte(System.SByte)'>
    <summary>Converts an 8-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromSingle(System.Single)'>
    <summary>Creates a binary float from a 32-bit floating-point number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>A binary float with the same value as
      <paramref name='flt'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromString(System.String)'>
    <summary>Creates a binary float from a text string that represents a number, using
      an unlimited precision context. For more information, see the
      <c>FromString(String, int, int, EContext)</c> method.
    </summary>
    <param name='str'>A text string to convert to a binary float.
    </param>
    <returns>The parsed number, converted to arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromString(System.String,PeterO.Numbers.EContext)'>
    <summary>Creates a binary float from a text string that represents a number. For
      more information, see the
      <c>FromString(String, int, int, EContext)</c> method.
    </summary>
    <param name='str'>A text string to convert to a binary float.
    </param>
    <param name='ctx'>A precision context specifying the precision, rounding, and exponent range
      to apply to the parsed number. Can be null.
    </param>
    <returns>The parsed number, converted to arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32)'>
    <summary>Creates a binary float from a text string that represents a number. For
      more information, see the
      <c>FromString(String, int, int, EContext)</c> method.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromString(System.String,System.Int32,System.Int32,PeterO.Numbers.EContext)'>
    <summary>Creates a binary float from a text string that represents a number. Note
      that if the string contains a negative exponent, the resulting value might
      not be exact, in which case the resulting binary float will be an
      approximation of this decimal number's value.
      <para>The format of the string generally consists of:
      </para>
      <list type=''>
        <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if
          '-' , the value is negative.)
        </item>
        <item>One or more digits, with a single optional decimal point after the
          first digit and before the last digit.
        </item>
        <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-" (negative
          exponent) plus one or more digits specifying the exponent.
        </item>
      </list>
      <para>The string can also be "-INF", "-Infinity", "Infinity", "INF", quiet NaN
        ("NaN") followed by any number of digits, or signaling NaN ("sNaN")
        followed by any number of digits, all in any combination of upper and
        lower case.
      </para>
      <para>All characters mentioned above are the corresponding characters in the
        Basic Latin range. In particular, the digits must be the basic digits 0
        to 9 (U+0030 to U+0039). The string is not allowed to contain white
        space characters, including spaces.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <param name='ctx'>A precision context specifying the precision, rounding, and exponent range
      (in bits) to apply to the parsed number. Can be null.
    </param>
    <returns>The parsed number, converted to arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromUInt16(System.UInt16)'>
    <summary>Converts a 16-bit unsigned integer to an arbitrary-precision binary float.

    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromUInt32(System.UInt32)'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.FromUInt64(System.UInt64)'>
    <summary>Converts a 64-bit unsigned integer to an arbitrary-precision binary float.

    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.GetHashCode'>
    <summary>Calculates this object's hash code. No application or process IDs are used
      in the hash code calculation.
    </summary>
    <returns>This object's hash code.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EFloat.IsFinite'>
    <summary>Gets a value indicating whether this object is finite (not infinity or
      NaN).
    </summary>
    <value><c>true</c> if this object is finite (not infinity or not-a-number (NaN)); otherwise,

      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.IsInfinity'>
    <summary>Gets a value indicating whether this object is positive or negative
      infinity.
    </summary>
    <returns><c>true</c> if this object is positive or negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.IsNaN'>
    <summary>Gets a value indicating whether this object is not a number (NaN).
    </summary>
    <returns><c>true</c> if this object is not a number (NaN); otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EFloat.IsNegative'>
    <summary>Gets a value indicating whether this object is negative, including
      negative zero.
    </summary>
    <value><c>true</c> if this object is negative, including negative zero; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.IsNegativeInfinity'>
    <summary>Returns whether this object is negative infinity.
    </summary>
    <returns><c>true</c> if this object is negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.IsPositiveInfinity'>
    <summary>Returns whether this object is positive infinity.
    </summary>
    <returns><c>true</c> if this object is positive infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.IsQuietNaN'>
    <summary>Gets a value indicating whether this object is a quiet not-a-number value.

    </summary>
    <returns><c>true</c> if this object is a quiet not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.IsSignalingNaN'>
    <summary>Gets a value indicating whether this object is a signaling not-a-number
      value.
    </summary>
    <returns><c>true</c> if this object is a signaling not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EFloat.IsZero'>
    <summary>Gets a value indicating whether this object's value equals 0.
    </summary>
    <value><c>true</c> if this object's value equals 0; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Log(PeterO.Numbers.EContext)'>
    <summary>Finds the natural logarithm of this object, that is, the power (exponent)
      that e (the base of natural logarithms) must be raised to in order to
      equal this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the ln function's results are
        generally not exact.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>Ln(this object). Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the result would be a complex number with a real
      part equal to Ln of this object's absolute value and an imaginary part
      equal to pi, but the return value is still NaN.). Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0). Signals no flags and returns negative infinity if this object's
      value is 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Log10(PeterO.Numbers.EContext)'>
    <summary>Finds the base-10 logarithm of this object, that is, the power (exponent)
      that the number 10 must be raised to in order to equal this object's
      value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the ln function's results are
        generally not exact.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>Ln(this object)/Ln(10). Signals the flag FlagInvalid and returns
      not-a-number (NaN) if this object is less than 0. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EFloat.Mantissa'>
    <summary>Gets this object's unscaled value.
    </summary>
    <value>This object's unscaled value. Will be negative if this object's value is
      negative (including a negative NaN).
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Gets the greater value between two binary floats.
    </summary>
    <param name='first'>An arbitrary-precision binary float.
    </param>
    <param name='second'>Another arbitrary-precision binary float.
    </param>
    <returns>The larger value of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Max(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Gets the greater value between two binary floats.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>The larger value of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Gets the greater value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Max.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MaxMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Gets the greater value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Max.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Gets the lesser value between two binary floats.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <returns>The smaller value of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Min(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Gets the lesser value between two binary floats.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>The smaller value of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Gets the lesser value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Min.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MinMagnitude(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Gets the lesser value between two values, ignoring their signs. If the
      absolute values are equal, has the same effect as Min.
    </summary>
    <param name='first'>The first value to compare.
    </param>
    <param name='second'>The second value to compare.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger)'>
    <summary>Returns a number similar to this number but with the radix point moved to
      the left.
    </summary>
    <param name='bigPlaces'>The number of binary digit places to move the radix point to the left. If
      this number is negative, instead moves the radix point to the right by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is decreased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MovePointLeft(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the radix point moved to
      the left.
    </summary>
    <param name='bigPlaces'>The number of binary digit places to move the radix point to the left. If
      this number is negative, instead moves the radix point to the right by
      this number's absolute value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>A number whose exponent is decreased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32)'>
    <summary>Returns a number similar to this number but with the radix point moved to
      the left.
    </summary>
    <param name='places'>The number of binary digit places to move the radix point to the left. If
      this number is negative, instead moves the radix point to the right by
      this number's absolute value.
    </param>
    <returns>A number whose exponent is decreased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MovePointLeft(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the radix point moved to
      the left.
    </summary>
    <param name='places'>The number of binary digit places to move the radix point to the left. If
      this number is negative, instead moves the radix point to the right by
      this number's absolute value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>A number whose exponent is decreased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger)'>
    <summary>Returns a number similar to this number but with the radix point moved to
      the right.
    </summary>
    <param name='bigPlaces'>The number of binary digit places to move the radix point to the right. If
      this number is negative, instead moves the radix point to the left by this
      number's absolute value.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MovePointRight(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the radix point moved to
      the right.
    </summary>
    <param name='bigPlaces'>The number of binary digit places to move the radix point to the right. If
      this number is negative, instead moves the radix point to the left by this
      number's absolute value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MovePointRight(System.Int32)'>
    <summary>Returns a number similar to this number but with the radix point moved to
      the right.
    </summary>
    <param name='places'>The number of binary digit places to move the radix point to the right. If
      this number is negative, instead moves the radix point to the left by this
      number's absolute value.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MovePointRight(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the radix point moved to
      the right.
    </summary>
    <param name='places'>The number of binary digit places to move the radix point to the right. If
      this number is negative, instead moves the radix point to the left by this
      number's absolute value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='places'/>
       , but not to more than 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat)'>
    <summary>Multiplies two binary floats. The resulting exponent will be the sum of
      the exponents of the two binary floats.
    </summary>
    <param name='otherValue'>Another binary float.
    </param>
    <returns>The product of the two binary floats.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Multiplies two binary floats. The resulting scale will be the sum of the
      scales of the two binary floats. The result's sign is positive if both
      operands have the same sign, and negative if they have different signs.
    </summary>
    <param name='op'>Another binary float.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>The product of the two binary floats.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Multiplies by one binary float, and then adds another binary float.
    </summary>
    <param name='multiplicand'>The value to multiply.
    </param>
    <param name='augend'>The value to add.
    </param>
    <returns>The result this *
      <paramref name='multiplicand'/>
       +
      <paramref name='augend'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MultiplyAndAdd(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Multiplies by one value, and then adds another value.
    </summary>
    <param name='op'>The value to multiply.
    </param>
    <param name='augend'>The value to add.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
      If the precision doesn't indicate a simplified arithmetic, rounding and
      precision/exponent adjustment is done only once, namely, after multiplying
      and adding.
    </param>
    <returns>The result thisValue * multiplicand + augend.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.MultiplyAndSubtract(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Multiplies by one value, and then subtracts another value.
    </summary>
    <param name='op'>The value to multiply.
    </param>
    <param name='subtrahend'>The value to subtract.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
      If the precision doesn't indicate a simplified arithmetic, rounding and
      precision/exponent adjustment is done only once, namely, after multiplying
      and subtracting.
    </param>
    <returns>The result thisValue * multiplicand - subtrahend.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EFloat.NaN'>
    <summary>A not-a-number value.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Negate'>
    <summary>Gets an object with the same value as this one, but with the sign
      reversed.
    </summary>
    <returns>An arbitrary-precision binary float. If this value is positive zero,
      returns negative zero. Returns signaling NaN if this value is signaling
      NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Negate(PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but with the
      sign reversed.
    </summary>
    <param name='context'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>An arbitrary-precision binary float. If this value is positive zero,
      returns positive zero. Signals FlagInvalid and returns quiet NaN if this
      value is signaling NaN.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EFloat.NegativeInfinity'>
    <summary>Negative infinity, less than any other number.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.EFloat.NegativeZero'>
    <summary>Represents the number negative zero.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.NextMinus(PeterO.Numbers.EContext)'>
    <summary>Finds the largest value that's smaller than the given value.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the largest value that's less than the given value. Returns
      negative infinity if the result is negative infinity. Signals FlagInvalid
      and returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null, the precision is 0, or
      <paramref name='ctx'/>
       has an unlimited exponent range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.NextPlus(PeterO.Numbers.EContext)'>
    <summary>Finds the smallest value that's greater than the given value.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the smallest value that's greater than the given value.Signals
      FlagInvalid and returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null, the precision is 0, or
      <paramref name='ctx'/>
       has an unlimited exponent range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.NextToward(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Finds the next value that is closer to the other object's value than this
      object's value. Returns a copy of this value with the same sign as the
      other value if both values are equal.
    </summary>
    <param name='otherValue'>An arbitrary-precision binary float that the return value will approach.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision and exponent range
      of the result. The rounding mode from this context is ignored. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
    </param>
    <returns>Returns the next value that is closer to the other object' s value than
      this object's value. Signals FlagInvalid and returns NaN if the parameter
      <paramref name='ctx'/>
       is null, the precision is 0, or
      <paramref name='ctx'/>
       has an unlimited exponent range.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EFloat.One'>
    <summary>Represents the number 1.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.PI(PeterO.Numbers.EContext)'>
    <summary>Finds the constant π, the circumference of a circle divided by its
      diameter.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as π can never be represented exactly.
      </i>
       .
    </param>
    <returns>The constant π rounded to the given precision. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Plus(PeterO.Numbers.EContext)'>
    <summary>Rounds this object's value to a given precision, using the given rounding
      mode and range of exponent, and also converts negative zero to positive
      zero.
    </summary>
    <param name='ctx'>A context for controlling the precision, rounding mode, and exponent
      range. Can be null, in which case the precision is unlimited and rounding
      isn't needed.
    </param>
    <returns>The closest value to this object's value, rounded to the specified
      precision. Returns the same value as this object if
      <paramref name='ctx'/>
       is null or the precision and exponent range are unlimited.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EFloat.PositiveInfinity'>
    <summary>Positive infinity, greater than any other number.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Pow(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Raises this object's value to the given exponent.
    </summary>
    <param name='exponent'>An arbitrary-precision binary float expressing the exponent to raise this
      object's value to.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>This^exponent. Signals the flag FlagInvalid and returns NaN if this object
      and exponent are both 0; or if this value is less than 0 and the exponent
      either has a fractional part or is infinity. Signals FlagInvalid and
      returns not-a-number (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0), and the exponent has a fractional part.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Pow(System.Int32)'>
    <summary>Raises this object's value to the given exponent.
    </summary>
    <param name='exponentSmall'>The exponent to raise this object's value to.
    </param>
    <returns>This^exponent. Returns not-a-number (NaN) if this object and exponent are
      both 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Pow(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Raises this object's value to the given exponent.
    </summary>
    <param name='exponentSmall'>The exponent to raise this object's value to.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>This^exponent. Signals the flag FlagInvalid and returns NaN if this object
      and exponent are both 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Precision'>
    <summary>Finds the number of digits in this number's mantissa (significand).
      Returns 1 if this value is 0, and 0 if this value is infinity or
      not-a-number (NaN).
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but with the
      same exponent as another binary float.
      <para>Note that this is not always the same as rounding to a given number of
        binary digit places, since it can fail if the difference between this
        value's exponent and the desired exponent is too big, depending on the
        maximum precision. If rounding to a number of binary digit places is
        desired, it's better to use the RoundToExponent and RoundToIntegral
        methods instead.
      </para>
      <para><b>Remark:</b> This method can be used to implement fixed-point binary arithmetic, in
        which a fixed number of digits come after the radix point. A fixed-point
        binary arithmetic in which no digits come after the radix point (a
        desired exponent of 0) is considered an "integer arithmetic".
      </para>
    </summary>
    <param name='otherValue'>A binary float containing the desired exponent of the result. The mantissa
      (significand) is ignored. The exponent is the number of fractional digits
      in the result, expressed as a negative number. Can also be positive, which
      eliminates lower-order places from the number. For example, -3 means round
      to the sixteenth (10b^-3, 0.0001b), and 3 means round to the sixteen-place
      (10b^3, 1000b). A value of 0 rounds the number to an integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if the result
      can't fit the given precision without rounding, or if the arithmetic
      context defines an exponent range and the given exponent is outside that
      range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Quantize(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value but a new exponent.
      <para>Note that this is not always the same as rounding to a given number of
        binary digit places, since it can fail if the difference between this
        value's exponent and the desired exponent is too big, depending on the
        maximum precision. If rounding to a number of binary digit places is
        desired, it's better to use the RoundToExponent and RoundToIntegral
        methods instead.
      </para>
      <para><b>Remark:</b> This method can be used to implement fixed-point binary arithmetic, in
        which each binary float has a fixed number of digits after the radix
        point. The following code example returns a fixed-point number with up
        to 20 digits before and exactly 5 digits after the radix point:
      </para>
      <code>// After performing arithmetic operations, adjust // the number to 5 //
        digits after the radix point number = number.Quantize(
        EInteger.FromInt32(-5), // five digits after the radix point
        EContext.ForPrecision(25) // 25-digit precision);</code> <para>A fixed-point binary arithmetic in which no digits come after the radix
        point (a desired exponent of 0) is considered an "integer arithmetic".
      </para>
    </summary>
    <param name='desiredExponent'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if this object
      is infinity, if the rounded result can't fit the given precision, or if
      the context defines an exponent range and the given exponent is outside
      that range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Quantize(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value but a new exponent.
      <para>Note that this is not always the same as rounding to a given number of
        binary digit places, since it can fail if the difference between this
        value's exponent and the desired exponent is too big, depending on the
        maximum precision. If rounding to a number of binary digit places is
        desired, it's better to use the RoundToExponent and RoundToIntegral
        methods instead.
      </para>
      <para><b>Remark:</b> This method can be used to implement fixed-point binary arithmetic, in
        which each binary float has a fixed number of digits after the radix
        point. The following code example returns a fixed-point number with up
        to 20 digits before and exactly 5 digits after the radix point:
      </para>
      <code>// After performing arithmetic operations, adjust // the number to 5
        digits after the radix point number = number.Quantize(-5, // five digits
        after the radix point EContext.ForPrecision(25) // 25-digit precision);</code> <para>A fixed-point binary arithmetic in which no digits come after the radix
        point (a desired exponent of 0) is considered an "integer arithmetic".
      </para>
    </summary>
    <param name='desiredExponentInt'>The desired exponent for the result. The exponent is the number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float with the same value as this object but with the exponent
      changed. Signals FlagInvalid and returns not-a-number (NaN) if this object
      is infinity, if the rounded result can't fit the given precision, or if
      the context defines an exponent range and the given exponent is outside
      that range.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Reduce(PeterO.Numbers.EContext)'>
    <summary>Removes trailing zeros from this object's mantissa (significand). For
      example, 1.00 becomes 1.
      <para>If this object's value is 0, changes the exponent to 0.
      </para>
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and rounding isn't needed.
    </param>
    <returns>This value with trailing zeros removed. Note that if the result has a very
      high exponent and the context says to clamp high exponents, there may
      still be some trailing zeros in the mantissa (significand).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Remainder(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Finds the remainder that results when dividing two arbitrary-precision
      binary floats. The remainder is the value that remains when the absolute
      value of this object is divided by the absolute value of the other object;
      the remainder has the same sign (positive or negative) as this object's
      value.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used both in the
      division portion and in the remainder portion of the remainder
      calculation. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no additional rounding
      (other than the rounding from integer division) is needed.
    </param>
    <returns>The remainder of the two numbers. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor is 0, or if the result doesn't fit the
      given precision.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat)'>
    <summary>Calculates the remainder of a number by the formula
      <c>"this" - (("this" / "divisor") * "divisor")</c> .
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RemainderNaturalScale(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Calculates the remainder of a number by the formula "this" - (("this" /
      "divisor") * "divisor").
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only in the
      division portion of the remainder calculation; as a result, it's possible
      for the return value to have a higher precision than given in this
      context. Flags will be set on the given context only if the context's
      <c>HasFlags</c> is true and the integer part of the division result doesn't fit the
      precision and exponent range without rounding. Can be null, in which the
      precision is unlimited and no additional rounding, other than the rounding
      down to an integer after division, is needed.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RemainderNear(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Finds the distance to the closest multiple of the given divisor, based on
      the result of dividing this object's value by another object's value.
      <list type=''>
        <item>If this and the other object divide evenly, the result is 0.
        </item>
        <item>If the remainder's absolute value is less than half of the divisor's
          absolute value, the result has the same sign as this object and will
          be the distance to the closest multiple.
        </item>
        <item>If the remainder's absolute value is more than half of the divisor' s
          absolute value, the result has the opposite sign of this object and
          will be the distance to the closest multiple.
        </item>
        <item>If the remainder's absolute value is exactly half of the divisor's
          absolute value, the result has the opposite sign of this object if the
          quotient, rounded down, is odd, and has the same sign as this object
          if the quotient, rounded down, is even, and the result's absolute
          value is half of the divisor's absolute value.
        </item>
      </list>
       This function is also known as the "IEEE Remainder" function.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <param name='ctx'>An arithmetic context object to control the precision. The rounding and
      exponent range settings of this context are ignored (the rounding mode is
      always treated as HalfEven). If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which the precision is unlimited.
    </param>
    <returns>The distance of the closest multiple. Signals FlagInvalid and returns
      not-a-number (NaN) if the divisor is 0, or either the result of integer
      division (the quotient) or the remainder wouldn't fit the given precision.

    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToExponent(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but rounded to a
      new exponent if necessary.
    </summary>
    <param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float rounded to the closest value representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to the given exponent when rounding, and the given
      exponent is outside of the valid range of the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToExponent(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but rounded to a
      new exponent if necessary.
    </summary>
    <param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float rounded to the closest value representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to the given exponent when rounding, and the given
      exponent is outside of the valid range of the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but rounded to
      the given exponent, and signals an inexact flag if the result would be
      inexact.
    </summary>
    <param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float rounded to the closest value representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to the given exponent
      when rounding, and the given exponent is outside of the valid range of the
      arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToExponentExact(PeterO.Numbers.EInteger,PeterO.Numbers.ERounding)'>
    <summary>Returns a binary number with the same value as this object but rounded to
      the given exponent.
    </summary>
    <param name='exponent'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the eighth (10^-1, 1/8), and 3 means round to
      the eight (2^3, 8). A value of 0 rounds the number to an integer.
    </param>
    <param name='rounding'>Desired mode for rounding this object's value.
    </param>
    <returns>A binary number rounded to the closest value representable in the given
      precision.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToExponentExact(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary>
    <param name='exponentSmall'>The minimum exponent the result can have. This is the maximum number of
      fractional digits in the result, expressed as a negative number. Can also
      be positive, which eliminates lower-order places from the number. For
      example, -3 means round to the thousandth (10^-3, 0.0001), and 3 means
      round to the thousand (10^3, 1000). A value of 0 rounds the number to an
      integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float rounded to the closest value representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to the given exponent
      when rounding, and the given exponent is outside of the valid range of the
      arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToIntegerExact(PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float rounded to the closest integer representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to 0 when rounding, and 0
      is outside of the valid range of the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToIntegerNoRoundedFlag(PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but rounded to
      an integer, without adding the
      <c>FlagInexact</c> or
      <c>FlagRounded</c> flags.
    </summary>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags), except
      that this function will never add the
      <c>FlagRounded</c> and
      <c>FlagInexact</c> flags (the only difference between this and RoundToExponentExact). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float rounded to the closest integer representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to 0 when rounding, and 0 is outside of the valid range of
      the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToIntegralExact(PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but rounded to
      an integer, and signals an inexact flag if the result would be inexact.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float rounded to the closest integer representable in the given
      precision. Signals FlagInvalid and returns not-a-number (NaN) if the
      result can't fit the given precision without rounding. Signals FlagInvalid
      and returns not-a-number (NaN) if the arithmetic context defines an
      exponent range, the new exponent must be changed to 0 when rounding, and 0
      is outside of the valid range of the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToIntegralNoRoundedFlag(PeterO.Numbers.EContext)'>
    <summary>Returns a binary float with the same value as this object but rounded to
      an integer, without adding the
      <c>FlagInexact</c> or
      <c>FlagRounded</c> flags.
    </summary>
    <param name='ctx'>An arithmetic context to control precision and rounding of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags), except
      that this function will never add the
      <c>FlagRounded</c> and
      <c>FlagInexact</c> flags (the only difference between this and RoundToExponentExact). Can be
      null, in which case the default rounding mode is HalfEven.
    </param>
    <returns>A binary float rounded to the closest integer representable in the given
      precision. If the result can't fit the precision, additional digits are
      discarded to make it fit. Signals FlagInvalid and returns not-a-number
      (NaN) if the precision context defines an exponent range, the new exponent
      must be changed to 0 when rounding, and 0 is outside of the valid range of
      the arithmetic context.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.RoundToPrecision(PeterO.Numbers.EContext)'>
    <summary>Rounds this object's value to a given precision, using the given rounding
      mode and range of exponent.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The closest value to this object's value, rounded to the specified
      precision. Returns the same value as this object if
      <paramref name='ctx'/>
       is null or the precision and exponent range are unlimited.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger)'>
    <summary>Returns a number similar to this number but with the scale adjusted.
    </summary>
    <param name='bigPlaces'>An arbitrary-precision integer.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(PeterO.Numbers.EInteger,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with its scale adjusted.
    </summary>
    <param name='bigPlaces'>An arbitrary-precision integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null.
    </param>
    <returns>A number whose exponent is increased by
      <paramref name='bigPlaces'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32)'>
    <summary>Returns a number similar to this number but with the scale adjusted.
    </summary>
    <param name='places'>The parameter
      <paramref name='places'/>
       is a 32-bit signed integer.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ScaleByPowerOfTwo(System.Int32,PeterO.Numbers.EContext)'>
    <summary>Returns a number similar to this number but with the scale adjusted.
    </summary>
    <param name='places'>The parameter
      <paramref name='places'/>
       is a 32-bit signed integer.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null.
    </param>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EFloat.Sign'>
    <summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary>
    <value>This value's sign: -1 if negative; 1 if positive; 0 if zero.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.EFloat.SignalingNaN'>
    <summary>A not-a-number value that signals an invalid operation flag when it's
      passed as an argument to any arithmetic operation in arbitrary-precision
      binary float.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Sqrt(PeterO.Numbers.EContext)'>
    <summary>Finds the square root of this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the square root function's results are
        generally not exact for many inputs.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>The square root. Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the square root would be a complex number, but the
      return value is still NaN). Signals FlagInvalid and returns not-a-number
      (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.SquareRoot(PeterO.Numbers.EContext)'>
    <summary>Finds the square root of this object's value.
    </summary>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags).
      <i>
         This parameter can't be null, as the square root function's results are
        generally not exact for many inputs.
      </i>
       (Unlike in the General Binary Arithmetic Specification, any rounding mode
      is allowed.).
    </param>
    <returns>The square root. Signals the flag FlagInvalid and returns NaN if this
      object is less than 0 (the square root would be a complex number, but the
      return value is still NaN). Signals FlagInvalid and returns not-a-number
      (NaN) if the parameter
      <paramref name='ctx'/>
       is null or the precision is unlimited (the context's Precision property
      is 0).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat)'>
    <summary>Subtracts an arbitrary-precision binary float from this instance and
      returns the result.
    </summary>
    <param name='otherValue'>The number to subtract from this instance's value.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Subtract(PeterO.Numbers.EFloat,PeterO.Numbers.EContext)'>
    <summary>Subtracts an arbitrary-precision binary float from this instance.
    </summary>
    <param name='otherValue'>The number to subtract from this instance's value.
    </param>
    <param name='ctx'>An arithmetic context to control precision, rounding, and exponent range
      of the result. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null, in which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.EFloat.Ten'>
    <summary>Represents the number 10.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToByteChecked'>
    <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToByteIfExact'>
    <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToByteUnchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a byte (from 0 to
      255).
    </summary>
    <returns>This number, converted to a byte (from 0 to 255). Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToDouble'>
    <summary>Converts this value to a 64-bit floating-point number.
    </summary>
    <returns>This number, converted to a 64-bit floating-point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToEDecimal'>
    <summary>Converts this value to an arbitrary-precision decimal number.
    </summary>
    <returns>This number, converted to an arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToEInteger'>
    <summary>Converts this value to an arbitrary-precision integer. Any fractional part
      of this value will be discarded when converting to an arbitrary-precision
      integer.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToEIntegerExact'>
    <summary>Converts this value to an arbitrary-precision integer, checking whether
      the value contains a fractional part.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToEIntegerIfExact'>
    <summary>Converts this value to an arbitrary-precision integer, checking whether
      the value contains a fractional part.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToEngineeringString'>
    <summary>Converts this value to an arbitrary-precision decimal number, then returns
      the value of that decimal's ToEngineeringString method.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToExtendedDecimal'>
    <summary>Converts this value to an arbitrary-precision decimal number.
    </summary>
    <returns>An arbitrary-precision decimal number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt16Checked'>
    <summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt16IfExact'>
    <summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt16Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 16-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt32Checked'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt32IfExact'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt32Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 32-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt64Checked'>
    <summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt64IfExact'>
    <summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToInt64Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 64-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToPlainString'>
    <summary>Converts this value to a string, but without exponential notation.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToSByteChecked'>
    <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to an 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToSByteIfExact'>
    <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as an 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToSByteUnchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as an 8-bit signed
      integer.
    </summary>
    <returns>This number, converted to an 8-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToShortestString(PeterO.Numbers.EContext)'>
    <summary>Returns a string representation of this number's value after rounding to
      the given precision (using the given arithmetic context). If the number
      after rounding is neither infinity nor not-a-number (NaN), returns the
      shortest decimal form (in terms of nonzero decimal digits) of this
      number's value that results in the rounded number after the decimal form
      is converted to binary floating-point format (using the given arithmetic
      context).
    </summary>
    <param name='ctx'>An arithmetic context to control precision (in bits), rounding, and
      exponent range of the rounded number. If
      <c>HasFlags</c> of the context is true, will also store the flags resulting from the
      operation (the flags are in addition to the pre-existing flags). Can be
      null. If this parameter is null or defines no maximum precision, returns
      the same value as the ToString() method.
    </param>
    <returns>Shortest decimal form of this number's value for the given arithmetic
      context. The text string will be in exponential notation if the number's
      first nonzero decimal digit is more than five digits after the decimal
      point, or if the number's exponent is greater than 0 and its value is 10,
      000, 000 or greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToSingle'>
    <summary>Converts this value to its closest equivalent as 32-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary>
    <returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToString'>
    <summary>Converts this number's value to a text string.
    </summary>
    <returns>A string representation of this object. The value is converted to decimal
      and the decimal form of this number's value is returned. The text string
      will be in exponential notation if the converted number's scale is
      positive or if the number's first nonzero decimal digit is more than five
      digits after the decimal point.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt16Checked'>
    <summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 16-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt16IfExact'>
    <summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer without rounding to a different numerical value.

    </summary>
    <returns>This number's value as a 16-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt16Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit unsigned
      integer.
    </summary>
    <returns>This number, converted to a 16-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt32Checked'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt32IfExact'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt32Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 32-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt64Checked'>
    <summary>Converts this number's value to a 64-bit unsigned integer if it can fit in
      a 64-bit unsigned integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 64-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt64IfExact'>
    <summary>Converts this number's value to a 64-bit unsigned integer if it can fit in
      a 64-bit unsigned integer without rounding to a different numerical value.

    </summary>
    <returns>This number's value as a 64-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.ToUInt64Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit unsigned
      integer.
    </summary>
    <returns>This number, converted to a 64-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.Ulp'>
    <summary>Returns the unit in the last place. The mantissa (significand) will be 1
      and the exponent will be this number's exponent. Returns 1 with an
      exponent of 0 if this number is infinity or not-a-number (NaN).
    </summary>
    <returns>An arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EFloat.UnsignedMantissa'>
    <summary>Gets the absolute value of this object's unscaled value.
    </summary>
    <value>The absolute value of this object's unscaled value.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.EFloat.Zero'>
    <summary>Represents the number 0.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Addition(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Adds two arbitrary-precision binary floating-point numbers and returns the
      result.
    </summary>
    <param name='bthis'>The first arbitrary-precision binary floating-point number.
    </param>
    <param name='otherValue'>The second arbitrary-precision binary floating-point number.
    </param>
    <returns>The sum of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Division(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Divides one binary float by another and returns the result. When possible,
      the result will be exact.
    </summary>
    <param name='dividend'>The number that will be divided by the divisor.
    </param>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>The quotient of the two numbers. Returns infinity if the divisor is 0 and
      the dividend is nonzero. Returns not-a-number (NaN) if the divisor and the
      dividend are 0. Returns NaN if the result can't be exact because it would
      have a nonterminating binary expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~PeterO.Numbers.EInteger'>
    <summary>Converts an arbitrary-precision binary float to a value to an
      arbitrary-precision integer. Any fractional part in this value will be
      discarded when converting to an arbitrary-precision integer.
    </summary>
    <param name='bigValue'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Byte'>
    <summary>Converts an arbitrary-precision binary float to a byte (from 0 to 255) if
      it can fit in a byte (from 0 to 255) after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Double'>
    <summary>Converts this value to its closest equivalent as a 64-bit floating-point
      number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 64-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary>
    <param name='bigValue'>The value to convert to a 64-bit floating-point number.
    </param>
    <returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int16'>
    <summary>Converts an arbitrary-precision binary float to a 16-bit signed integer if
      it can fit in a 16-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int32'>
    <summary>Converts an arbitrary-precision binary float to a 32-bit signed integer if
      it can fit in a 32-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Int64'>
    <summary>Converts an arbitrary-precision binary float to a 64-bit signed integer if
      it can fit in a 64-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.SByte'>
    <summary>Converts an arbitrary-precision binary float to an 8-bit signed integer if
      it can fit in an 8-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to an 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.Single'>
    <summary>Converts an arbitrary-precision binary float to its closest equivalent as
      a 32-bit floating-point number. The half-even rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's significand area for a quiet NaN, and clears it for a signaling
        NaN. Then the other bits of the significand area are set to the lowest
        bits of this object's unsigned mantissa (significand), and the
        next-highest bit of the significand area is set if those bits are all
        zeros and this is a signaling NaN. Unfortunately, in the .NET
        implementation, the return value of this method may be a quiet NaN even
        if a signaling NaN would otherwise be generated.
      </para>
    </summary>
    <param name='bigValue'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt16'>
    <summary>Converts an arbitrary-precision binary float to a 16-bit unsigned integer
      if it can fit in a 16-bit unsigned integer after truncating to an integer.

    </summary>
    <param name='input'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt32'>
    <summary>Converts an arbitrary-precision binary float to a 32-bit signed integer if
      it can fit in a 32-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Explicit(PeterO.Numbers.EFloat)~System.UInt64'>
    <summary>Converts an arbitrary-precision binary float to a 64-bit unsigned integer
      if it can fit in a 64-bit unsigned integer after truncating to an integer.

    </summary>
    <param name='input'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.EFloat'>
    <summary>Converts an arbitrary-precision integer to an arbitrary precision binary.
    </summary>
    <param name='eint'>An arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision binary float with the exponent set to 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.Byte)~PeterO.Numbers.EFloat'>
    <summary>Converts a byte (from 0 to 255) to an arbitrary-precision binary float.
    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.Double)~PeterO.Numbers.EFloat'>
    <summary>Creates a binary float from a 64-bit floating-point number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first.
    </summary>
    <param name='dbl'>The parameter
      <paramref name='dbl'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A binary float with the same value as
      <paramref name='dbl'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.Int16)~PeterO.Numbers.EFloat'>
    <summary>Converts a 16-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.Int32)~PeterO.Numbers.EFloat'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.Int64)~PeterO.Numbers.EFloat'>
    <summary>Converts a 64-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.SByte)~PeterO.Numbers.EFloat'>
    <summary>Converts an 8-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.Single)~PeterO.Numbers.EFloat'>
    <summary>Creates a binary float from a 32-bit floating-point number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the floating point
      number to a string first.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>A binary float with the same value as
      <paramref name='flt'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.UInt16)~PeterO.Numbers.EFloat'>
    <summary>Converts a 16-bit unsigned integer to an arbitrary-precision binary float.

    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.UInt32)~PeterO.Numbers.EFloat'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision binary float.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Implicit(System.UInt64)~PeterO.Numbers.EFloat'>
    <summary>Converts a 64-bit unsigned integer to an arbitrary-precision binary float.

    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision binary float.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Modulus(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Finds the remainder when dividing one arbitrary-precision binary float by
      another.
    </summary>
    <param name='dividend'>The number that will be divided by the divisor.
    </param>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>The result of the operation.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Multiply(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Multiplies two binary floats. The resulting exponent will be the sum of
      the exponents of the two binary floats.
    </summary>
    <param name='operand1'>The first operand.
    </param>
    <param name='operand2'>The second operand.
    </param>
    <returns>The product of the two binary floats.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='operand1'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_Subtraction(PeterO.Numbers.EFloat,PeterO.Numbers.EFloat)'>
    <summary>Subtracts one arbitrary-precision binary float from another.
    </summary>
    <param name='bthis'>The first operand.
    </param>
    <param name='subtrahend'>The second operand.
    </param>
    <returns>The difference of the two objects.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bthis'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EFloat.op_UnaryNegation(PeterO.Numbers.EFloat)'>
    <summary>Gets an object with the same value as this one, but with the sign
      reversed.
    </summary>
    <param name='bigValue'>An arbitrary-precision binary float.
    </param>
    <returns>The negated form of the given number. If the given number is positive
      zero, returns negative zero. Returns signaling NaN if this value is
      signaling NaN.
    </returns>
  </doc>
  <doc name='T:PeterO.Numbers.EInteger'>
    <summary>Represents an arbitrary-precision integer. (The "E" stands for "extended",
      and has this prefix to group it with the other classes common to this
      library, particularly EDecimal, EFloat, and ERational.)
      <para>Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        value are interchangeable, but they should be compared using the
        "Equals" method rather than the "==" operator.
      </para>
    </summary>
     ///
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Abs'>
    <summary>Returns the absolute value of this object's value.
    </summary>
    <returns>This object's value with the sign removed.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Add(PeterO.Numbers.EInteger)'>
    <summary>Adds this object and another object.
    </summary>
    <param name='bigintAugend'>Another arbitrary-precision integer.
    </param>
    <returns>The sum of the two objects.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintAugend'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.And(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Does an AND operation between two arbitrary-precision integer values.
    </summary>
    <param name='a'>The first arbitrary-precision integer.
    </param>
    <param name='b'>The second arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='a'/>
       or
      <paramref name='b'/>
       is null.
    </exception>
    <remarks>
       Each arbitrary-precision integer is treated as a two's-complement form
      (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) for the purposes of this operator.
    </remarks>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.AsInt32Checked'>
    <summary>Converts this object's value to a 32-bit signed integer, throwing an
      exception if it can't fit.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value is too big to fit a 32-bit signed integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.AsInt32Unchecked'>
    <summary>Converts this object's value to a 32-bit signed integer. If the value
      can't fit in a 32-bit integer, returns the lower 32 bits of this object's
      two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) (in which case the return value might have a different sign than this
      object's value).
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.AsInt64Checked'>
    <summary>Converts this object's value to a 64-bit signed integer, throwing an
      exception if it can't fit.
    </summary>
    <returns>A 64-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This object's value is too big to fit a 64-bit signed integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.AsInt64Unchecked'>
    <summary>Converts this object's value to a 64-bit signed integer. If the value
      can't fit in a 64-bit integer, returns the lower 64 bits of this object's
      two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) (in which case the return value might have a different sign than this
      object's value).
    </summary>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.CanFitInInt32'>
    <summary>Returns whether this object's value can fit in a 32-bit signed integer.
    </summary>
    <returns><c>true</c> if this object's value is from -2147483648 through 2147483647; otherwise,

      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.CanFitInInt64'>
    <summary>Returns whether this object's value can fit in a 64-bit signed integer.
    </summary>
    <returns><c>true</c> if this object's value is from -9223372036854775808 through
      9223372036854775807; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.CompareTo(PeterO.Numbers.EInteger)'>
    <summary>Compares an arbitrary-precision integer with this instance.
    </summary>
    <param name='other'>The integer to compare to this value.
    </param>
    <returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger)'>
    <summary>Divides this object by another arbitrary-precision integer and returns the
      quotient and remainder.
    </summary>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>An array with two arbitrary-precision integers: the first is the quotient,
      and the second is the remainder.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter divisor is null.
    </exception>
    <exception cref='T:System.DivideByZeroException'>The parameter divisor is 0.
    </exception>
    <exception cref='T:System.DivideByZeroException'>Attempted to divide by zero.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.DivRem(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger@)'>
    <summary>Divides one arbitrary-precision integer by another, and returns the
      quotient and sets an output parameter to the remainder.
    </summary>
    <param name='dividend'>The arbitrary-precision integer to be divided.
    </param>
    <param name='divisor'>The arbitrary-precision integer to divide by.
    </param>
    <param name='remainder'>An arbitrary-precision integer.
    </param>
    <returns>An array of two arbitrary-precision integers: the first is the quotient,
      and the second is the remainder.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dividend'/>
       or
      <paramref name='divisor'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Divide(PeterO.Numbers.EInteger)'>
    <summary>Divides this instance by the value of an arbitrary-precision integer. The
      result is rounded down (the fractional part is discarded). Except if the
      result is 0, it will be negative if this object is positive and the other
      is negative, or vice versa, and will be positive if both are positive or
      both are negative.
    </summary>
    <param name='bigintDivisor'>Another arbitrary-precision integer.
    </param>
    <returns>The quotient of the two objects.
    </returns>
    <exception cref='T:System.DivideByZeroException'>The parameter
      <paramref name='bigintDivisor'/>
       is zero.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintDivisor'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Equals(PeterO.Numbers.EInteger)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='other'>Another arbitrary-precision integer.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal and have the
      same type.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromByte(System.Byte)'>
    <summary>Converts a byte (from 0 to 255) to an arbitrary-precision integer.
    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>This number's value as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromBytes(System.Byte[],System.Boolean)'>
    <summary>Initializes an arbitrary-precision integer from an array of bytes.
    </summary>
    <param name='bytes'>A byte array consisting of the two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) of the arbitrary-precision integer to create. The byte array is encoded
      using the following rules:
      <list>
        <item>Positive numbers have the first byte's highest bit cleared, and
          negative numbers have the bit set.
        </item>
        <item>The last byte contains the lowest 8-bits, the next-to-last contains
          the next lowest 8 bits, and so on. For example, the number 300 can be
          encoded as
          <c>0x01, 0x2C</c> and 200 as
          <c>0x00, 0xC8</c> . (Note that the second example contains a set high bit in
          <c>0xC8</c> , so an additional 0 is added at the start to ensure it's interpreted
          as positive.)
        </item>
        <item>To encode negative numbers, take the absolute value of the number,
          subtract by 1, encode the number into bytes, and toggle each bit of
          each byte. Any further bits that appear beyond the most significant
          bit of the number will be all ones. For example, the number -450 can
          be encoded as
          <c>0xfe, 0x70</c> and -52869 as
          <c>0xff, 0x31, 0x7B</c> . (Note that the second example contains a cleared high bit in
          <c>0x31, 0x7B</c> , so an additional 0xff is added at the start to ensure it's
          interpreted as negative.)
        </item>
      </list>
      <para>For little-endian, the byte order is reversed from the byte order just
        discussed.
      </para>
       .
    </param>
    <param name='littleEndian'>If true, the byte order is little-endian, or least-significant-byte first.
      If false, the byte order is big-endian, or most-significant-byte first.
    </param>
    <returns>An arbitrary-precision integer. Returns 0 if the byte array's length is 0.

    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromInt16(System.Int16)'>
    <summary>Converts a 16-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromInt32(System.Int32)'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='intValue'>The parameter
      <paramref name='intValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>An arbitrary-precision integer with the same value as the 64-bit number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromInt64(System.Int64)'>
    <summary>Converts a 64-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='longerValue'>The parameter
      <paramref name='longerValue'/>
       is a 64-bit signed integer.
    </param>
    <returns>An arbitrary-precision integer with the same value as the 64-bit number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromRadixString(System.String,System.Int32)'>
    <summary>Converts a string to an arbitrary-precision integer in a given radix.
    </summary>
    <param name='str'>A string described by the FromRadixSubstring method.
    </param>
    <param name='radix'>A base from 2 to 36. Depending on the radix, the string can use the basic
      digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041
      to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </param>
    <returns>An arbitrary-precision integer with the same value as the given string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromRadixSubstring(System.String,System.Int32,System.Int32,System.Int32)'>
    <summary>Converts a portion of a string to an arbitrary-precision integer in a
      given radix.
    </summary>
    <param name='str'>A text string. The desired portion of the string must contain only
      characters allowed by the given radix, except that it may start with a
      minus sign ("-", U+002D) to indicate a negative number. The desired
      portion is not allowed to contain white space characters, including
      spaces.
    </param>
    <param name='radix'>A base from 2 to 36. Depending on the radix, the string can use the basic
      digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041
      to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </param>
    <param name='index'>The index of the string that starts the string portion.
    </param>
    <param name='endIndex'>The index of the string that ends the string portion. The length will be
      index + endIndex - 1.
    </param>
    <returns>An arbitrary-precision integer with the same value as given in the string
      portion.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='index'/>
       is less than 0,
      <paramref name='endIndex'/>
       is less than 0, or either is greater than the string's length, or
      <paramref name='endIndex'/>
       is less than
      <paramref name='index'/>
       .
    </exception>
    <exception cref='T:System.FormatException'>The string portion is empty or in an invalid format.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromSByte(System.SByte)'>
    <summary>Converts an 8-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromString(System.String)'>
    <summary>Converts a string to an arbitrary-precision integer.
    </summary>
    <param name='str'>A text string. The string must contain only basic digits 0 to 9 (U+0030 to
      U+0039), except that it may start with a minus sign ("-", U+002D) to
      indicate a negative number. The string is not allowed to contain white
      space characters, including spaces.
    </param>
    <returns>An arbitrary-precision integer with the same value as given in the string.

    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromSubstring(System.String,System.Int32,System.Int32)'>
    <summary>Converts a portion of a string to an arbitrary-precision integer.
    </summary>
    <param name='str'>A text string. The desired portion of the string must contain only basic
      digits 0 to 9 (U+0030 to U+0039), except that it may start with a minus
      sign ("-", U+002D) to indicate a negative number. The desired portion is
      not allowed to contain white space characters, including spaces.
    </param>
    <param name='index'>The index of the string that starts the string portion.
    </param>
    <param name='endIndex'>The index of the string that ends the string portion. The length will be
      index + endIndex - 1.
    </param>
    <returns>An arbitrary-precision integer with the same value as given in the string
      portion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromUInt16(System.UInt16)'>
    <summary>Converts a 16-bit unsigned integer to an arbitrary-precision integer.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromUInt32(System.UInt32)'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.FromUInt64(System.UInt64)'>
    <summary>Converts a 64-bit unsigned integer to an arbitrary-precision integer.
    </summary>
    <param name='ulongValue'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='ulongValue'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Gcd(PeterO.Numbers.EInteger)'>
    <summary>Returns the greatest common divisor of this integer and the given integer.
      The greatest common divisor (GCD) is also known as the greatest common
      factor (GCF).
    </summary>
    <param name='bigintSecond'>Another arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintSecond'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetBits(System.Int32,System.Int32)'>
    <summary>Retrieves bits from this integer's two' s-complement form.
    </summary>
    <param name='index'>Zero-based index of the first bit to retrieve, where 0 is the
      least-significant bit of the number.
    </param>
    <param name='numberBits'>The number of bits to retrieve, starting with the first. Must be from 0
      through 64.
    </param>
    <returns>A 64-bit signed integer containing the bits from this integer's two'
      s-complement form. The least significant bit is the first bit, and any
      unused bits are set to 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetDigitCount'>
    <summary>Returns the number of decimal digits used by this integer.
    </summary>
    <returns>The number of digits in the decimal form of this integer. Returns 1 if
      this number is 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetHashCode'>
    <summary>Returns the hash code for this instance. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetLowBit'>
    <summary>Gets the lowest set bit in this number's absolute value. (This will also
      be the lowest set bit in the number's two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ).).
    </summary>
    <returns>The lowest bit set in the number, starting at 0. Returns -1 if this value
      is 0 or odd.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetLowBitAsEInteger'>
    <summary>Gets the lowest set bit in this number's absolute value. (This will also
      be the lowest set bit in the number's two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ).).
    </summary>
    <returns>The lowest bit set in the number, starting at 0. Returns -1 if this value
      is 0 or odd.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetSignedBit(System.Int32)'>
    <summary>Returns whether a bit is set in the two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) of this object' s value.
    </summary>
    <param name='index'>Zero based index of the bit to test. 0 means the least significant bit.
    </param>
    <returns><c>true</c> if a bit is set in the two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) of this object' s value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetSignedBitLength'>
    <summary>Finds the minimum number of bits needed to represent this object's value,
      except for its sign. If the value is negative, finds the number of bits in
      the value equal to this object's absolute value minus 1.
    </summary>
    <returns>The number of bits in this object's value. Returns 0 if this object's
      value is 0 or negative 1.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetUnsignedBit(System.Int32)'>
    <summary>Returns whether a bit is set in this number's absolute value.
    </summary>
    <param name='index'>Zero based index of the bit to test. 0 means the least significant bit.
    </param>
    <returns><c>true</c> if a bit is set in this number's absolute value.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetUnsignedBitLength'>
    <summary>Finds the minimum number of bits needed to represent this number's
      absolute value.
    </summary>
    <returns>The number of bits in this object's value. Returns 0 if this object's
      value is 0, and returns 1 if the value is negative 1.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.GetUnsignedBitLengthAsEInteger'>
    <summary>Finds the minimum number of bits needed to represent this number's
      absolute value.
    </summary>
    <returns>The number of bits in this object's value. Returns 0 if this object's
      value is 0, and returns 1 if the value is negative 1.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EInteger.IsEven'>
    <summary>Gets a value indicating whether this value is even.
    </summary>
    <value><c>true</c> if this value is even; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EInteger.IsPowerOfTwo'>
    <summary>Gets a value indicating whether this object's value is a power of two.
    </summary>
    <value><c>true</c> if this object's value is a power of two; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.EInteger.IsZero'>
    <summary>Gets a value indicating whether this value is 0.
    </summary>
    <value><c>true</c> if this value is 0; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Mod(PeterO.Numbers.EInteger)'>
    <summary>Finds the modulus remainder that results when this instance is divided by
      the value of an arbitrary-precision integer. The modulus remainder is the
      same as the normal remainder if the normal remainder is positive, and
      equals divisor plus normal remainder if the normal remainder is negative.
    </summary>
    <param name='divisor'>A divisor greater than 0 (the modulus).
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <exception cref='T:System.ArithmeticException'>The parameter
      <paramref name='divisor'/>
       is negative.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='divisor'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Calculates the remainder when this arbitrary-precision integer raised to a
      certain power is divided by another arbitrary-precision integer.
    </summary>
    <param name='pow'>The power to raise this integer by.
    </param>
    <param name='mod'>The integer to divide the raised number by.
    </param>
    <returns>The value (
      <c>this</c> ^
      <paramref name='pow'/>
       )%
      <paramref name='mod'/>
       .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='pow'/>
       or
      <paramref name='mod'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ModPow(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Calculates the remainder when an arbitrary-precision integer raised to a
      certain power is divided by another arbitrary-precision integer.
    </summary>
    <param name='bigintValue'>The starting operand.
    </param>
    <param name='pow'>The power to raise this integer by.
    </param>
    <param name='mod'>The integer to divide the raised number by.
    </param>
    <returns>The value (
      <paramref name='bigintValue'/>
       ^
      <paramref name='pow'/>
       )%
      <paramref name='mod'/>
       .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Multiply(PeterO.Numbers.EInteger)'>
    <summary>Multiplies this instance by the value of an arbitrary-precision integer
      object.
    </summary>
    <param name='bigintMult'>Another arbitrary-precision integer.
    </param>
    <returns>The product of the two numbers.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigintMult'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Negate'>
    <summary>Gets the value of this object with the sign reversed.
    </summary>
    <returns>This object's value with the sign reversed.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Not(PeterO.Numbers.EInteger)'>
    <summary>Returns an arbitrary-precision integer with every bit flipped.
    </summary>
    <param name='valueA'>The operand as an arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='valueA'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Numbers.EInteger.One'>
    <summary>Gets the number 1 as an arbitrary-precision integer.
    </summary>
    <value>The number 1 as an arbitrary-precision integer.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Or(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Does an OR operation between two arbitrary-precision integer instances.
    </summary>
    <param name='first'>The first operand.
    </param>
    <param name='second'>The second operand.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='first'/>
       or
      <paramref name='second'/>
       is null.
    </exception>
    <remarks>
       Each arbitrary-precision integer is treated as a two's-complement form
      (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) for the purposes of this operator.
    </remarks>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Pow(System.Int32)'>
    <summary>Raises an arbitrary-precision integer to a power.
    </summary>
    <param name='powerSmall'>The exponent to raise to.
    </param>
    <returns>The result. Returns 1 if
      <paramref name='powerSmall'/>
       is 0.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='powerSmall'/>
       is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.PowBigIntVar(PeterO.Numbers.EInteger)'>
    <summary>Raises an arbitrary-precision integer to a power, which is given as
      another arbitrary-precision integer.
    </summary>
    <param name='power'>The exponent to raise to.
    </param>
    <returns>The result. Returns 1 if
      <paramref name='power'/>
       is 0.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='power'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='power'/>
       is less than 0.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Remainder(PeterO.Numbers.EInteger)'>
    <summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision integer. The remainder is the value that
      remains when the absolute value of this object is divided by the absolute
      value of the other object; the remainder has the same sign (positive or
      negative) as this object.
    </summary>
    <param name='divisor'>Another arbitrary-precision integer.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ShiftLeft(System.Int32)'>
    <summary>Returns an arbitrary-precision integer with the bits shifted to the left
      by a number of bits. A value of 1 doubles this value, a value of 2
      multiplies it by 4, a value of 3 by 8, a value of 4 by 16, and so on.
    </summary>
    <param name='numberBits'>The number of bits to shift. Can be negative, in which case this is the
      same as shiftRight with the absolute value of this parameter.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ShiftRight(System.Int32)'>
    <summary>Returns an arbitrary-precision integer with the bits shifted to the right.
      For this operation, the arbitrary-precision integer is treated as a
      two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ). Thus, for negative values, the arbitrary-precision integer is
      sign-extended.
    </summary>
    <param name='numberBits'>Number of bits to shift right.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EInteger.Sign'>
    <summary>Gets the sign of this object's value.
    </summary>
    <value>0 if this value is zero; -1 if this value is negative, or 1 if this value
      is positive.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Sqrt'>
    <summary>Finds the square root of this instance's value, rounded down.
    </summary>
    <returns>The square root of this object's value. Returns 0 if this value is 0 or
      less.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.SqrtRem'>
    <summary>Calculates the square root and the remainder.
    </summary>
    <returns>An array of two arbitrary-precision integers: the first integer is the
      square root, and the second is the difference between this value and the
      square of the first integer. Returns two zeros if this value is 0 or less,
      or one and zero if this value equals 1.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Subtract(PeterO.Numbers.EInteger)'>
    <summary>Subtracts an arbitrary-precision integer from this arbitrary-precision
      integer.
    </summary>
    <param name='subtrahend'>Another arbitrary-precision integer.
    </param>
    <returns>The difference of the two objects.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='subtrahend'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Numbers.EInteger.Ten'>
    <summary>Gets the number 10 as an arbitrary-precision integer.
    </summary>
    <value>The number 10 as an arbitrary-precision integer.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToByteChecked'>
    <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255).
    </summary>
    <returns>This number's value as a byte (from 0 to 255).
    </returns>
    <exception cref='T:System.OverflowException'>This value is less than 0 or greater than 255.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToByteUnchecked'>
    <summary>Converts this number to a byte (from 0 to 255), returning the
      least-significant bits of this number's two's-complement form.
    </summary>
    <returns>This number, converted to a byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToBytes(System.Boolean)'>
    <summary>Returns a byte array of this integer's value. The byte array will take the
      number's two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ), using the fewest bytes necessary to store its value unambiguously. If
      this value is negative, the bits that appear beyond the most significant
      bit of the number will be all ones. The resulting byte array can be passed
      to the
      <c>FromBytes()</c> method (with the same byte order) to reconstruct this integer's value.
    </summary>
    <param name='littleEndian'>If true, the byte order is little-endian, or least-significant-byte first.
      If false, the byte order is big-endian, or most-significant-byte first.
    </param>
    <returns>A byte array. If this value is 0, returns a byte array with the single
      element 0.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToInt16Checked'>
    <summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer.
    </summary>
    <returns>This number's value as a 16-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is less than -32768 or greater than 32767.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToInt16Unchecked'>
    <summary>Converts this number to a 16-bit signed integer, returning the
      least-significant bits of this number's two's-complement form.
    </summary>
    <returns>This number, converted to a 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToInt32Checked'>
    <summary>Converts this object's value to a 32-bit signed integer, throwing an
      exception if it can't fit.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToInt32Unchecked'>
    <summary>Converts this object's value to a 32-bit signed integer. If the value
      can't fit in a 32-bit integer, returns the lower 32 bits of this object's
      two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) (in which case the return value might have a different sign than this
      object's value).
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToInt64Checked'>
    <summary>Converts this object's value to a 64-bit signed integer, throwing an
      exception if it can't fit.
    </summary>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToInt64Unchecked'>
    <summary>Converts this object's value to a 64-bit signed integer. If the value
      can't fit in a 64-bit integer, returns the lower 64 bits of this object's
      two' s-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) (in which case the return value might have a different sign than this
      object's value).
    </summary>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToRadixString(System.Int32)'>
    <summary>Generates a string representing the value of this object, in the given
      radix.
    </summary>
    <param name='radix'>A radix from 2 through 36. For example, to generate a hexadecimal
      (base-16) string, specify 16. To generate a decimal (base-10) string,
      specify 10.
    </param>
    <returns>A string representing the value of this object. If this value is 0,
      returns "0". If negative, the string will begin with a minus sign ("-",
      U+002D). Depending on the radix, the string will use the basic digits 0 to
      9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041 to U+005A).
      For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToSByteChecked'>
    <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer.
    </summary>
    <returns>This number's value as an 8-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is less than -128 or greater than 127.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToSByteUnchecked'>
    <summary>Converts this number to an 8-bit signed integer, returning the
      least-significant bits of this number's two's-complement form.
    </summary>
    <returns>This number, converted to an 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToString'>
    <summary>Converts this object to a text string in base 10.
    </summary>
    <returns>A string representation of this object. If negative, the string will begin
      with a minus sign ("-", U+002D). The string will use the basic digits 0 to
      9 (U+0030 to U+0039).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToUInt16Checked'>
    <summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer.
    </summary>
    <returns>This number's value as a 16-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is less than 0 or greater than 65535.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToUInt16Unchecked'>
    <summary>Converts this number to a 16-bit unsigned integer, returning the
      least-significant bits of this number's two's-complement form.
    </summary>
    <returns>This number, converted to a 16-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToUInt32Checked'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is less than 0 or greater than 4294967295.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToUInt32Unchecked'>
    <summary>Converts this number to a 32-bit signed integer, returning the
      least-significant bits of this number's two's-complement form.
    </summary>
    <returns>This number, converted to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToUInt64Checked'>
    <summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer.
    </summary>
    <returns>This number's value as a 64-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>This value is outside the range of a 64-bit signed integer.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.ToUInt64Unchecked'>
    <summary>Converts this number to a 64-bit signed integer, returning the
      least-significant bits of this number's two' s-complement form.
    </summary>
    <returns>This number, converted to a 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.Xor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Finds the exclusive "or" of two arbitrary-precision integer objects.
      <para>Each arbitrary-precision integer is treated as a two's-complement form
        (see
        <see cref='T:PeterO.Numbers.EDecimal'>
           "Forms of numbers"
        </see>
         ) for the purposes of this operator.
      </para>
    </summary>
    <param name='a'>The first arbitrary-precision integer.
    </param>
    <param name='b'>The second arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision integer in which each bit is set if it's set in one
      input integer but not the other.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.EInteger.Zero'>
    <summary>Gets the number zero as an arbitrary-precision integer.
    </summary>
    <value>The number zero as an arbitrary-precision integer.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Addition(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Adds two arbitrary-precision integer objects and returns the result.
    </summary>
    <param name='bthis'>The first operand.
    </param>
    <param name='augend'>The second operand.
    </param>
    <returns>The sum of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_BitwiseAnd(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Does an AND operation between two arbitrary-precision integer values.
    </summary>
    <param name='thisValue'>The first operand.
    </param>
    <param name='otherValue'>The second operand.
    </param>
    <returns>The result of the operation.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "a" or "b" is null.
    </exception>
    <remarks>
       Each arbitrary-precision integer is treated as a two's-complement form
      (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) for the purposes of this operator.
    </remarks>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_BitwiseOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Does an OR operation between two arbitrary-precision integer instances.
    </summary>
    <param name='thisValue'>An arbitrary-precision integer.
    </param>
    <param name='otherValue'>Another arbitrary-precision integer.
    </param>
    <returns>The result of the operation.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "first" or "second" is null.
    </exception>
    <remarks>
       Each arbitrary-precision integer is treated as a two's-complement form
      (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ) for the purposes of this operator.
    </remarks>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Division(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Divides an arbitrary-precision integer by the value of an
      arbitrary-precision integer object.
    </summary>
    <param name='dividend'>The number that will be divided by the divisor.
    </param>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>The quotient of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_ExclusiveOr(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Finds the exclusive "or" of two arbitrary-precision integer objects.
      <para>Each arbitrary-precision integer is treated as a two's-complement form
        (see
        <see cref='T:PeterO.Numbers.EDecimal'>
           "Forms of numbers"
        </see>
         ) for the purposes of this operator.
      </para>
    </summary>
    <param name='a'>The first arbitrary-precision integer.
    </param>
    <param name='b'>The second arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision integer in which each bit is set if it's set in one
      input integer but not the other.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Byte'>
    <summary>Converts an arbitrary-precision integer to a byte (from 0 to 255) if it
      can fit in a byte (from 0 to 255).
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a byte (from 0 to 255).
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 255.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int16'>
    <summary>Converts an arbitrary-precision integer to a 16-bit signed integer if it
      can fit in a 16-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 16-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than -32768 or greater than 32767.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int32'>
    <summary>Converts an arbitrary-precision integer to a 32-bit signed integer if it
      can fit in a 32-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 32-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than -2147483648 or greater than 2147483647.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.Int64'>
    <summary>Converts an arbitrary-precision integer to a 64-bit signed integer if it
      can fit in a 64-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 64-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than -9223372036854775808 or greater than 9223372036854775807.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.SByte'>
    <summary>Converts an arbitrary-precision integer to an 8-bit signed integer if it
      can fit in an 8-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as an 8-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than -128 or greater than 127.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt16'>
    <summary>Converts an arbitrary-precision integer to a 16-bit unsigned integer if it
      can fit in a 16-bit unsigned integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 16-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 65535.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt32'>
    <summary>Converts an arbitrary-precision integer to a 32-bit signed integer if it
      can fit in a 32-bit signed integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 32-bit signed integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 4294967295.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Explicit(PeterO.Numbers.EInteger)~System.UInt64'>
    <summary>Converts an arbitrary-precision integer to a 64-bit unsigned integer if it
      can fit in a 64-bit unsigned integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The value of
      <paramref name='input'/>
       as a 64-bit unsigned integer.
    </returns>
    <exception cref='T:System.OverflowException'>The parameter
      <paramref name='input'/>
       is less than 0 or greater than 18446744073709551615.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_GreaterThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Determines whether an arbitrary-precision integer is greater than another
      arbitrary-precision integer.
    </summary>
    <param name='thisValue'>The first arbitrary-precision integer.
    </param>
    <param name='otherValue'>The second arbitrary-precision integer.
    </param>
    <returns><c>true</c> if
      <paramref name='thisValue'/>
       is greater than
      <paramref name='otherValue'/>
       ; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_GreaterThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Determines whether an arbitrary-precision integer value is greater than
      another arbitrary-precision integer.
    </summary>
    <param name='thisValue'>The first arbitrary-precision integer.
    </param>
    <param name='otherValue'>The second arbitrary-precision integer.
    </param>
    <returns><c>true</c> if
      <paramref name='thisValue'/>
       is at least
      <paramref name='otherValue'/>
       ; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Implicit(System.Byte)~PeterO.Numbers.EInteger'>
    <summary>Converts a byte (from 0 to 255) to an arbitrary-precision integer.
    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Implicit(System.Int16)~PeterO.Numbers.EInteger'>
    <summary>Converts a 16-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Implicit(System.Int32)~PeterO.Numbers.EInteger'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Implicit(System.Int64)~PeterO.Numbers.EInteger'>
    <summary>Converts a 64-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Implicit(System.SByte)~PeterO.Numbers.EInteger'>
    <summary>Converts an 8-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Implicit(System.UInt16)~PeterO.Numbers.EInteger'>
    <summary>Converts a 16-bit unsigned integer to an arbitrary-precision integer.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Implicit(System.UInt32)~PeterO.Numbers.EInteger'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision integer.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Implicit(System.UInt64)~PeterO.Numbers.EInteger'>
    <summary>Converts a 64-bit unsigned integer to an arbitrary-precision integer.
    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_LeftShift(PeterO.Numbers.EInteger,System.Int32)'>
    <summary>Returns an arbitrary-precision integer with the bits shifted to the left
      by a number of bits. A value of 1 doubles this value, a value of 2
      multiplies it by 4, a value of 3 by 8, a value of 4 by 16, and so on.
    </summary>
    <param name='bthis'>The arbitrary-precision integer to shift left.
    </param>
    <param name='bitCount'>The number of bits to shift. Can be negative, in which case this is the
      same as shiftRight with the absolute value of this parameter.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_LessThan(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Determines whether an arbitrary-precision integer is less than another
      arbitrary-precision integer.
    </summary>
    <param name='thisValue'>The first arbitrary-precision integer.
    </param>
    <param name='otherValue'>The second arbitrary-precision integer.
    </param>
    <returns><c>true</c> if
      <paramref name='thisValue'/>
       is less than
      <paramref name='otherValue'/>
       ; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_LessThanOrEqual(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Determines whether an arbitrary-precision integer is up to another
      arbitrary-precision integer.
    </summary>
    <param name='thisValue'>The first arbitrary-precision integer.
    </param>
    <param name='otherValue'>The second arbitrary-precision integer.
    </param>
    <returns><c>true</c> if
      <paramref name='thisValue'/>
       is up to
      <paramref name='otherValue'/>
       ; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Modulus(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Finds the remainder that results when an arbitrary-precision integer is
      divided by the value of another arbitrary-precision integer.
    </summary>
    <param name='dividend'>The first operand.
    </param>
    <param name='divisor'>The number to divide by.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Multiply(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Multiplies an arbitrary-precision integer by the value of an
      arbitrary-precision integer.
    </summary>
    <param name='operand1'>The first operand.
    </param>
    <param name='operand2'>The second operand.
    </param>
    <returns>The product of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_OnesComplement(PeterO.Numbers.EInteger)'>
    <summary>Returns an arbitrary-precision integer with every bit flipped.
    </summary>
    <param name='thisValue'>The operand as an arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='thisValue'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_RightShift(PeterO.Numbers.EInteger,System.Int32)'>
    <summary>Shifts the bits of an arbitrary-precision integer to the right.
    </summary>
    <param name='bthis'>Another arbitrary-precision integer.
    </param>
    <param name='smallValue'>The parameter
      <paramref name='smallValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
    <remarks>
       For this operation, the arbitrary-precision integer is treated as a
      two's-complement form (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ). Thus, for negative values, the arbitrary-precision integer is
      sign-extended.
    </remarks>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_Subtraction(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Subtracts two arbitrary-precision integer values.
    </summary>
    <param name='bthis'>An arbitrary-precision integer.
    </param>
    <param name='subtrahend'>Another arbitrary-precision integer.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.EInteger.op_UnaryNegation(PeterO.Numbers.EInteger)'>
    <summary>Negates an arbitrary-precision integer.
    </summary>
    <param name='bigValue'>An arbitrary-precision integer to negate.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='T:PeterO.Numbers.ERational'>
    <summary>Represents an arbitrary-precision rational number. This class can't be
      inherited. (The "E" stands for "extended", meaning that instances of this
      class can be values other than numbers proper, such as infinity and
      not-a-number.)
      <para><b>Thread safety:</b> Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.#ctor(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Numbers.ERational'/>
       class.
    </summary>
    <param name='numerator'>The numerator.
    </param>
    <param name='denominator'>The denominator.
    </param>
    <exception cref='T:System.ArgumentException'>The denominator is zero.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Abs'>
    <summary>Returns the absolute value of this rational number, that is, a number with
      the same value as this one but as a nonnegative number.
    </summary>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Add(PeterO.Numbers.ERational)'>
    <summary>Adds two rational numbers.
    </summary>
    <param name='otherValue'>Another arbitrary-precision rational number.
    </param>
    <returns>The sum of the two numbers. Returns not-a-number (NaN) if either operand
      is NaN.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.CompareTo(PeterO.Numbers.ERational)'>
    <summary>Compares an arbitrary-precision rational number with this instance.
    </summary>
    <param name='other'>An arbitrary-precision rational number.
    </param>
    <returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.CompareToBinary(PeterO.Numbers.EFloat)'>
    <summary>Compares an arbitrary-precision binary float with this instance.
    </summary>
    <param name='other'>An arbitrary-precision binary float.
    </param>
    <returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.CompareToDecimal(PeterO.Numbers.EDecimal)'>
    <summary>Compares an arbitrary-precision decimal number with this instance.
    </summary>
    <param name='other'>An arbitrary-precision decimal number.
    </param>
    <returns>Zero if the values are equal; a negative number if this instance is less,
      or a positive number if this instance is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.CompareToTotal(PeterO.Numbers.ERational)'>
    <summary>Compares the values of this object and another object, imposing a total
      ordering on all possible values. In this method:
      <list>
        <item>For objects with the same value, the one with the higher denominator
          has a greater "absolute value".
        </item>
        <item>Negative zero is less than positive zero.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
        <item>Negative numbers are less than positive numbers.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision rational number to compare with this one.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.CompareToTotalMagnitude(PeterO.Numbers.ERational)'>
    <summary>Compares the absolute values of this object and another object, imposing a
      total ordering on all possible values (ignoring their signs). In this
      method:
      <list>
        <item>For objects with the same value, the one with the higher denominator
          has a greater "absolute value".
        </item>
        <item>Negative zero and positive zero are considered equal.
        </item>
        <item>Quiet NaN has a higher "absolute value" than signaling NaN. If both
          objects are quiet NaN or both are signaling NaN, the one with the
          higher diagnostic information has a greater "absolute value".
        </item>
        <item>NaN has a higher "absolute value" than infinity.
        </item>
        <item>Infinity has a higher "absolute value" than any finite number.
        </item>
      </list>
    </summary>
    <param name='other'>An arbitrary-precision rational number to compare with this one.
    </param>
    <returns>The number 0 if both objects have the same value, or -1 if this object is
      less than the other value, or 1 if this object is greater.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.CopySign(PeterO.Numbers.ERational)'>
    <summary>Returns a number with the same value as this one, but copying the sign
      (positive or negative) of another number.
    </summary>
    <param name='other'>A number whose sign will be copied.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)'>
    <summary>Creates a rational number with the given numerator and denominator.
    </summary>
    <param name='numerator'>The numerator.
    </param>
    <param name='denominator'>The denominator.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Create(System.Int32,System.Int32)'>
    <summary>Creates a rational number with the given numerator and denominator.
    </summary>
    <param name='numeratorSmall'>The numerator.
    </param>
    <param name='denominatorSmall'>The denominator.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger)'>
    <summary>Creates a not-a-number arbitrary-precision rational number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.CreateNaN(PeterO.Numbers.EInteger,System.Boolean,System.Boolean)'>
    <summary>Creates a not-a-number arbitrary-precision rational number.
    </summary>
    <param name='diag'>A number to use as diagnostic information associated with this object. If
      none is needed, should be zero.
    </param>
    <param name='signaling'>Whether the return value will be signaling (true) or quiet (false).
    </param>
    <param name='negative'>Whether the return value is negative.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.ERational.Denominator'>
    <summary>Gets this object's denominator.
    </summary>
    <value>This object's denominator.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Divide(PeterO.Numbers.ERational)'>
    <summary>Divides this instance by the value of an arbitrary-precision rational
      number object.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The quotient of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Equals(PeterO.Numbers.ERational)'>
    <summary>Determines whether this object's numerator, denominator, and properties
      are equal to those of another object. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary>
    <param name='other'>An arbitrary-precision rational number to compare to.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Equals(System.Object)'>
    <summary>Determines whether this object's numerator, denominator, and properties
      are equal to those of another object and that other object is an
      arbitrary-precision rational number. Not-a-number values are considered
      equal if the rest of their properties are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if the objects are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromByte(System.Byte)'>
    <summary>Converts a byte (from 0 to 255) to an arbitrary-precision rational number.

    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromDecimal(System.Decimal)'>
    <summary>Converts a
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal) to a rational number.
    </summary>
    <param name='eint'>The number to convert as a
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromDouble(System.Double)'>
    <summary>Converts a 64-bit floating-point number to a rational number. This method
      computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the number to a string.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 64-bit floating-point number.
    </param>
    <returns>A rational number with the same value as
      <paramref name='flt'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromEDecimal(PeterO.Numbers.EDecimal)'>
    <summary>Converts an arbitrary-precision decimal number to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromEFloat(PeterO.Numbers.EFloat)'>
    <summary>Converts an arbitrary-precision binary float to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromEInteger(PeterO.Numbers.EInteger)'>
    <summary>Converts an arbitrary-precision integer to a rational number.
    </summary>
    <param name='bigint'>The number to convert as an arbitrary-precision integer.
    </param>
    <returns>The exact value of the integer as a rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromExtendedDecimal(PeterO.Numbers.EDecimal)'>
    <summary>Converts an arbitrary-precision decimal number to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision decimal number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromExtendedFloat(PeterO.Numbers.EFloat)'>
    <summary>Converts an arbitrary-precision binary float to a rational number.
    </summary>
    <param name='ef'>The number to convert as an arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromInt16(System.Int16)'>
    <summary>Converts a 16-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromInt32(System.Int32)'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromInt64(System.Int64)'>
    <summary>Converts a 64-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromSByte(System.SByte)'>
    <summary>Converts an 8-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromSingle(System.Single)'>
    <summary>Converts a 32-bit binary floating-point number to a rational number. This
      method computes the exact value of the floating point number, not an
      approximation, as is often the case by converting the number to a string.
    </summary>
    <param name='flt'>The parameter
      <paramref name='flt'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>A rational number with the same value as
      <paramref name='flt'/>
       .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromString(System.String)'>
    <summary>Creates a rational number from a text string that represents a number. See

      <c>FromString(String, int, int)</c> for more information.
    </summary>
    <param name='str'>A string that represents a number.
    </param>
    <returns>An arbitrary-precision rational number with the same value as the given
      string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromString(System.String,System.Int32,System.Int32)'>
    <summary><para>Creates a rational number from a text string that represents a number.
      </para>
      <para>The format of the string generally consists of:
      </para>
      <list type=''>
        <item>An optional plus sign ("+" , U+002B) or minus sign ("-", U+002D) (if
          '-' , the value is negative.)
        </item>
        <item>The numerator in the form of one or more digits.
        </item>
        <item>Optionally, "/" followed by the denominator in the form of one or more
          digits. If a denominator is not given, it's equal to 1.
        </item>
      </list>
      <para>The string can also be "-INF", "-Infinity", "Infinity", "INF", quiet NaN
        ("NaN" /"-NaN") followed by any number of digits, or signaling NaN
        ("sNaN" /"-sNaN") followed by any number of digits, all in any
        combination of upper and lower case.
      </para>
      <para>All characters mentioned above are the corresponding characters in the
        Basic Latin range. In particular, the digits must be the basic digits 0
        to 9 (U+0030 to U+0039). The string is not allowed to contain white
        space characters, including spaces.
      </para>
    </summary>
    <param name='str'>A text string, a portion of which represents a number.
    </param>
    <param name='offset'>A zero-based index that identifies the start of the number.
    </param>
    <param name='length'>The length of the number within the string.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromUInt16(System.UInt16)'>
    <summary>Converts a 16-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromUInt32(System.UInt32)'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.FromUInt64(System.UInt64)'>
    <summary>Converts a 64-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>This number's value as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.GetHashCode'>
    <summary>Returns the hash code for this instance. No application or process IDs are
      used in the hash code calculation.
    </summary>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.ERational.IsFinite'>
    <summary>Gets a value indicating whether this object is finite (not infinity or
      NaN).
    </summary>
    <value><c>true</c> if this object is finite (not infinity or not-a-number (NaN)); otherwise,

      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.IsInfinity'>
    <summary>Gets a value indicating whether this object's value is infinity.
    </summary>
    <returns><c>true</c> if this object's value is infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.IsNaN'>
    <summary>Returns whether this object is a not-a-number value.
    </summary>
    <returns><c>true</c> if this object is a not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.ERational.IsNegative'>
    <summary>Gets a value indicating whether this object's value is negative (including
      negative zero).
    </summary>
    <value><c>true</c> if this object's value is negative; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.IsNegativeInfinity'>
    <summary>Returns whether this object is negative infinity.
    </summary>
    <returns><c>true</c> if this object is negative infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.IsPositiveInfinity'>
    <summary>Returns whether this object is positive infinity.
    </summary>
    <returns><c>true</c> if this object is positive infinity; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.IsQuietNaN'>
    <summary>Returns whether this object is a quiet not-a-number value.
    </summary>
    <returns><c>true</c> if this object is a quiet not-a-number value; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.IsSignalingNaN'>
    <summary>Returns whether this object is a signaling not-a-number value (which
      causes an error if the value is passed to any arithmetic operation in this
      class).
    </summary>
    <returns><c>true</c> if this object is a signaling not-a-number value (which causes an error
      if the value is passed to any arithmetic operation in this class);
      otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.ERational.IsZero'>
    <summary>Gets a value indicating whether this object's value equals 0.
    </summary>
    <value><c>true</c> if this object's value equals 0; otherwise, .
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Multiply(PeterO.Numbers.ERational)'>
    <summary>Multiplies this instance by the value of an arbitrary-precision rational
      number.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The product of the two numbers.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.ERational.NaN'>
    <summary>A not-a-number value.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Negate'>
    <summary>Returns a rational number with the same value as this one but with the
      sign reversed.
    </summary>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.ERational.NegativeInfinity'>
    <summary>Negative infinity, less than any other number.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERational.NegativeZero'>
    <summary>A rational number for negative zero.
    </summary>
  </doc>
  <doc name='P:PeterO.Numbers.ERational.Numerator'>
    <summary>Gets this object's numerator.
    </summary>
    <value>This object's numerator. If this object is a not-a-number value, returns
      the diagnostic information (which will be negative if this object is
      negative).
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.ERational.One'>
    <summary>The rational number one.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERational.PositiveInfinity'>
    <summary>Positive infinity, greater than any other number.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Remainder(PeterO.Numbers.ERational)'>
    <summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision rational number.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.ERational.Sign'>
    <summary>Gets the sign of this rational number.
    </summary>
    <value>Zero if this value is zero or negative zero; -1 if this value is less than
      0; and 1 if this value is greater than 0.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.ERational.SignalingNaN'>
    <summary>A signaling not-a-number value.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.Subtract(PeterO.Numbers.ERational)'>
    <summary>Subtracts an arbitrary-precision rational number from this instance.
    </summary>
    <param name='otherValue'>An arbitrary-precision rational number.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='F:PeterO.Numbers.ERational.Ten'>
    <summary>The rational number ten.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToByteChecked'>
    <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToByteIfExact'>
    <summary>Converts this number's value to a byte (from 0 to 255) if it can fit in a
      byte (from 0 to 255) without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToByteUnchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a byte (from 0 to
      255).
    </summary>
    <returns>This number, converted to a byte (from 0 to 255). Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToDecimal'>
    <summary>Converts this value to a
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal). Currently, converts this value to the precision and range of a
      .NET Framework decimal.
    </summary>
    <returns>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToDouble'>
    <summary>Converts this value to a 64-bit floating-point number. The half-even
      rounding mode is used.
    </summary>
    <returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEDecimal'>
    <summary>Converts this rational number to a decimal number.
    </summary>
    <returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating decimal expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEDecimal(PeterO.Numbers.EContext)'>
    <summary>Converts this rational number to a decimal number and rounds the result to
      the given precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param>
    <returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating decimal expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEDecimalExactIfPossible(PeterO.Numbers.EContext)'>
    <summary>Converts this rational number to a decimal number, but if the result would
      have a nonterminating decimal expansion, rounds that result to the given
      precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating decimal expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The exact value of the rational number if possible; otherwise,the rounded
      version of the result if a context is given. Returns not-a-number (NaN) if
      the context is null and the result can't be exact because it has a
      nonterminating decimal expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEFloat'>
    <summary>Converts this rational number to a binary float.
    </summary>
    <returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating binary expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEFloat(PeterO.Numbers.EContext)'>
    <summary>Converts this rational number to a binary float and rounds that result to
      the given precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param>
    <returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating binary expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEFloatExactIfPossible(PeterO.Numbers.EContext)'>
    <summary>Converts this rational number to a binary float, but if the result would
      have a nonterminating binary expansion, rounds that result to the given
      precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating binary expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The exact value of the rational number if possible; otherwise,the rounded
      version of the result if a context is given. Returns not-a-number (NaN) if
      the context is null and the result can't be exact because it has a
      nonterminating binary expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEInteger'>
    <summary>Converts this value to an arbitrary-precision integer. Any fractional part
      in this value will be discarded when converting to an arbitrary-precision
      integer.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEIntegerExact'>
    <summary>Converts this value to an arbitrary-precision integer, checking whether
      the value is an exact integer.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToEIntegerIfExact'>
    <summary>Converts this value to an arbitrary-precision integer, checking whether
      the value is an exact integer.
    </summary>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToExtendedDecimal'>
    <summary>Converts this rational number to a decimal number.
    </summary>
    <returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating decimal expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToExtendedDecimal(PeterO.Numbers.EContext)'>
    <summary>Converts this rational number to a decimal number and rounds the result to
      the given precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param>
    <returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating decimal expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToExtendedDecimalExactIfPossible(PeterO.Numbers.EContext)'>
    <summary>Converts this rational number to a decimal number, but if the result would
      have a nonterminating decimal expansion, rounds that result to the given
      precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating decimal expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The exact value of the rational number if possible; otherwise,the rounded
      version of the result if a context is given. Returns not-a-number (NaN) if
      the context is null and the result can't be exact because it has a
      nonterminating decimal expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToExtendedFloat'>
    <summary>Converts this rational number to a binary float.
    </summary>
    <returns>The exact value of the rational number, or not-a-number (NaN) if the
      result can't be exact because it has a nonterminating binary expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToExtendedFloat(PeterO.Numbers.EContext)'>
    <summary>Converts this rational number to a binary float and rounds that result to
      the given precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. If HasFlags of the context is true, will
      also store the flags resulting from the operation (the flags are in
      addition to the pre-existing flags). Can be null, in which case the
      precision is unlimited and no rounding is needed.
    </param>
    <returns>The value of the rational number, rounded to the given precision. Returns
      not-a-number (NaN) if the context is null and the result can't be exact
      because it has a nonterminating binary expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToExtendedFloatExactIfPossible(PeterO.Numbers.EContext)'>
    <summary>Converts this rational number to a binary float, but if the result would
      have a nonterminating binary expansion, rounds that result to the given
      precision.
    </summary>
    <param name='ctx'>An arithmetic context object to control the precision, rounding, and
      exponent range of the result. This context will be used only if the exact
      result would have a nonterminating binary expansion. If HasFlags of the
      context is true, will also store the flags resulting from the operation
      (the flags are in addition to the pre-existing flags). Can be null, in
      which case the precision is unlimited and no rounding is needed.
    </param>
    <returns>The exact value of the rational number if possible; otherwise,the rounded
      version of the result if a context is given. Returns not-a-number (NaN) if
      the context is null and the result can't be exact because it has a
      nonterminating binary expansion.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt16Checked'>
    <summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt16IfExact'>
    <summary>Converts this number's value to a 16-bit signed integer if it can fit in a
      16-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt16Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 16-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt32Checked'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt32IfExact'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt32Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 32-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt64Checked'>
    <summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt64IfExact'>
    <summary>Converts this number's value to a 64-bit signed integer if it can fit in a
      64-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToInt64Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 64-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToSByteChecked'>
    <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to an 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToSByteIfExact'>
    <summary>Converts this number's value to an 8-bit signed integer if it can fit in
      an 8-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as an 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToSByteUnchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as an 8-bit signed
      integer.
    </summary>
    <returns>This number, converted to an 8-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToSingle'>
    <summary>Converts this value to a 32-bit binary floating-point number. The
      half-even rounding mode is used.
    </summary>
    <returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A string representation of this object. If this object's value is infinity
      or not-a-number, the result is the analogous return value of the
      <c>EDecimal.ToString</c> method. Otherwise, the return value has the following form:
      <c>[-]numerator/denominator</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt16Checked'>
    <summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 16-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt16IfExact'>
    <summary>Converts this number's value to a 16-bit unsigned integer if it can fit in
      a 16-bit unsigned integer without rounding to a different numerical value.

    </summary>
    <returns>This number's value as a 16-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt16Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 16-bit unsigned
      integer.
    </summary>
    <returns>This number, converted to a 16-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt32Checked'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt32IfExact'>
    <summary>Converts this number's value to a 32-bit signed integer if it can fit in a
      32-bit signed integer without rounding to a different numerical value.
    </summary>
    <returns>This number's value as a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt32Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 32-bit signed
      integer.
    </summary>
    <returns>This number, converted to a 32-bit signed integer. Returns 0 if this value
      is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt64Checked'>
    <summary>Converts this number's value to a 64-bit unsigned integer if it can fit in
      a 64-bit unsigned integer after truncating to an integer.
    </summary>
    <returns>This number's value, truncated to a 64-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt64IfExact'>
    <summary>Converts this number's value to a 64-bit unsigned integer if it can fit in
      a 64-bit unsigned integer without rounding to a different numerical value.

    </summary>
    <returns>This number's value as a 64-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.ToUInt64Unchecked'>
    <summary>Truncates this number's value to an integer and returns the
      least-significant bits of its two's-complement form as a 64-bit unsigned
      integer.
    </summary>
    <returns>This number, converted to a 64-bit unsigned integer. Returns 0 if this
      value is infinity or not-a-number.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.ERational.UnsignedNumerator'>
    <summary>Gets this object's numerator with the sign removed.
    </summary>
    <value>This object's numerator. If this object is a not-a-number value, returns
      the diagnostic information.
    </value>
  </doc>
  <doc name='F:PeterO.Numbers.ERational.Zero'>
    <summary>A rational number for zero.
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Addition(PeterO.Numbers.ERational,PeterO.Numbers.ERational)'>
    <summary>Adds two rational numbers.
    </summary>
    <param name='bthis'>The first operand.
    </param>
    <param name='augend'>The second operand.
    </param>
    <returns>The sum of the two numbers. Returns not-a-number (NaN) if either operand
      is NaN.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "otherValue" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Division(PeterO.Numbers.ERational,PeterO.Numbers.ERational)'>
    <summary>Divides an arbitrary-precision rational number by the value of another
      arbitrary-precision rational number object.
    </summary>
    <param name='dividend'>An arbitrary-precision rational number serving as the dividend.
    </param>
    <param name='divisor'>An arbitrary-precision rational number serving as the divisor.
    </param>
    <returns>The quotient of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~PeterO.Numbers.EInteger'>
    <summary>Converts an arbitrary-precision rational number to an arbitrary-precision
      integer. Any fractional part in the value will be discarded when
      converting to an arbitrary-precision integer.
    </summary>
    <param name='bigValue'>An arbitrary-precision rational number.
    </param>
    <returns>An arbitrary-precision integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Byte'>
    <summary>Converts an arbitrary-precision rational number to a byte (from 0 to 255)
      if it can fit in a byte (from 0 to 255) after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Decimal'>
    <summary>Converts an arbitrary-precision rational number to a
      <c>decimal</c> under the Common Language Infrastructure (see
      <see cref='T:PeterO.Numbers.EDecimal'>
         "Forms of numbers"
      </see>
       ).
    </summary>
    <param name='extendedNumber'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Double'>
    <summary>Converts an arbitrary-precision rational number to a 64-bit floating-point
      number. The half-even rounding mode is used.
    </summary>
    <param name='bigValue'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int16'>
    <summary>Converts an arbitrary-precision rational number to a 16-bit signed integer
      if it can fit in a 16-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int32'>
    <summary>Converts an arbitrary-precision rational number to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Int64'>
    <summary>Converts an arbitrary-precision rational number to a 64-bit signed integer
      if it can fit in a 64-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.SByte'>
    <summary>Converts an arbitrary-precision rational number to an 8-bit signed integer
      if it can fit in an 8-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to an 8-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.Single'>
    <summary>Converts an arbitrary-precision rational number to a 32-bit binary
      floating-point number. The half-even rounding mode is used.
    </summary>
    <param name='bigValue'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The closest 32-bit binary floating-point number to this value. The return
      value can be positive infinity or negative infinity if this value exceeds
      the range of a 32-bit floating point number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt16'>
    <summary>Converts an arbitrary-precision rational number to a 16-bit unsigned
      integer if it can fit in a 16-bit unsigned integer after truncating to an
      integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 16-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt32'>
    <summary>Converts an arbitrary-precision rational number to a 32-bit signed integer
      if it can fit in a 32-bit signed integer after truncating to an integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Explicit(PeterO.Numbers.ERational)~System.UInt64'>
    <summary>Converts an arbitrary-precision rational number to a 64-bit unsigned
      integer if it can fit in a 64-bit unsigned integer after truncating to an
      integer.
    </summary>
    <param name='input'>The number to convert as an arbitrary-precision rational number.
    </param>
    <returns>The value of
      <paramref name='input'/>
       , truncated to a 64-bit unsigned integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EDecimal)~PeterO.Numbers.ERational'>
    <summary>Converts an arbitrary-precision decimal floating-point number to an
      arbitrary-precision rational number.
    </summary>
    <param name='eint'>The parameter
      <paramref name='eint'/>
       is an arbitrary-precision decimal floating-point number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EFloat)~PeterO.Numbers.ERational'>
    <summary>Converts an arbitrary-precision binary float to an arbitrary-precision
      rational number.
    </summary>
    <param name='eint'>An arbitrary-precision binary float.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(PeterO.Numbers.EInteger)~PeterO.Numbers.ERational'>
    <summary>Converts an arbitrary-precision integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='eint'>An arbitrary-precision integer.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.Byte)~PeterO.Numbers.ERational'>
    <summary>Converts a byte (from 0 to 255) to an arbitrary-precision rational number.

    </summary>
    <param name='inputByte'>The number to convert as a byte (from 0 to 255).
    </param>
    <returns>The value of
      <paramref name='inputByte'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.Decimal)~PeterO.Numbers.ERational'>
    <summary>Converts a
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal). to an arbitrary-precision rational number.
    </summary>
    <param name='eint'>A
      <c>decimal</c> under the Common Language Infrastructure (usually a .NET Framework
      decimal).
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.Double)~PeterO.Numbers.ERational'>
    <summary>Converts a 64-bit floating-point number to an arbitrary-precision rational
      number.
    </summary>
    <param name='eint'>The parameter
      <paramref name='eint'/>
       is a 64-bit floating-point number.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.Int16)~PeterO.Numbers.ERational'>
    <summary>Converts a 16-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt16'>The number to convert as a 16-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt16'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.Int32)~PeterO.Numbers.ERational'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt32'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.Int64)~PeterO.Numbers.ERational'>
    <summary>Converts a 64-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputInt64'>The number to convert as a 64-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputInt64'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.SByte)~PeterO.Numbers.ERational'>
    <summary>Converts an 8-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputSByte'>The number to convert as an 8-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputSByte'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.Single)~PeterO.Numbers.ERational'>
    <summary>Converts a 32-bit binary floating-point number to a rational number.
    </summary>
    <param name='eint'>The parameter
      <paramref name='eint'/>
       is a 32-bit binary floating-point number.
    </param>
    <returns>The value of
      <paramref name='eint'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.UInt16)~PeterO.Numbers.ERational'>
    <summary>Converts a 16-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt16'>The number to convert as a 16-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt16'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.UInt32)~PeterO.Numbers.ERational'>
    <summary>Converts a 32-bit signed integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt32'>The number to convert as a 32-bit signed integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt32'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Implicit(System.UInt64)~PeterO.Numbers.ERational'>
    <summary>Converts a 64-bit unsigned integer to an arbitrary-precision rational
      number.
    </summary>
    <param name='inputUInt64'>The number to convert as a 64-bit unsigned integer.
    </param>
    <returns>The value of
      <paramref name='inputUInt64'/>
       as an arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Modulus(PeterO.Numbers.ERational,PeterO.Numbers.ERational)'>
    <summary>Finds the remainder that results when this instance is divided by the
      value of an arbitrary-precision rational number.
    </summary>
    <param name='dividend'>The dividend.
    </param>
    <param name='divisor'>The divisor.
    </param>
    <returns>The remainder of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Multiply(PeterO.Numbers.ERational,PeterO.Numbers.ERational)'>
    <summary>Multiplies this instance by the value of an arbitrary-precision rational
      number.
    </summary>
    <param name='operand1'>The first operand.
    </param>
    <param name='operand2'>The second operand.
    </param>
    <returns>The product of the two numbers.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_Subtraction(PeterO.Numbers.ERational,PeterO.Numbers.ERational)'>
    <summary>Subtracts an arbitrary-precision rational number from this instance.
    </summary>
    <param name='bthis'>The first operand.
    </param>
    <param name='subtrahend'>The second operand.
    </param>
    <returns>The difference of the two objects.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.ERational.op_UnaryNegation(PeterO.Numbers.ERational)'>
    <summary>Returns an arbitrary-precision rational number with the same value as the
      given one but with its sign reversed.
    </summary>
    <param name='bigValue'>An arbitrary-precision rational number to negate.
    </param>
    <returns>An arbitrary-precision rational number.
    </returns>
  </doc>
  <doc name='T:PeterO.Numbers.ERounding'>
    <summary>Specifies the mode to use when "shortening" numbers that otherwise can't
      fit a given number of digits, so that the shortened number has about the
      same value. This "shortening" is known as rounding. (The "E" stands for
      "extended", and has this prefix to group it with the other classes common
      to this library, particularly EDecimal, EFloat, and ERational.).
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.Ceiling'>
    <summary>If there is a fractional part, the number is rounded to the highest
      representable number that's closest to it.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.Down'>
    <summary>The fractional part is discarded (the number is truncated).
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.Floor'>
    <summary>If there is a fractional part, the number is rounded to the lowest
      representable number that's closest to it.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.HalfDown'>
    <summary>Rounded to the nearest number; if the fractional part is exactly half, it
      is discarded.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.HalfEven'>
    <summary>Rounded to the nearest number; if the fractional part is exactly half, the
      number is rounded to the closest representable number that is even. This
      is sometimes also known as "banker's rounding".
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.HalfUp'>
    <summary>Rounded to the nearest number; if the fractional part is exactly half, the
      number is rounded to the closest representable number away from zero. This
      is the most familiar rounding mode for many people.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.None'>
    <summary>Indicates that rounding will not be used. If rounding is required, the
      rounding operation will report an error.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.Odd'>
    <summary>If there is a fractional part and the whole number part is even, the
      number is rounded to the closest representable odd number away from zero.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.OddOrZeroFiveUp'>
    <summary>For binary floating point numbers, this is the same as Odd. For other
      bases (including decimal numbers), this is the same as ZeroFiveUp. This
      rounding mode is useful for rounding intermediate results at a slightly
      higher precision (at least 2 bits more for binary) than the final
      precision.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.Up'>
    <summary>If there is a fractional part, the number is rounded to the closest
      representable number away from zero.
    </summary>
  </doc>
  <doc name='F:PeterO.Numbers.ERounding.ZeroFiveUp'>
    <summary>If there is a fractional part and if the last digit before rounding is 0
      or half the radix, the number is rounded to the closest representable
      number away from zero; otherwise the fractional part is discarded. In
      overflow, the fractional part is always discarded.
    </summary>
  </doc>
  <doc name='T:PeterO.Numbers.ETrapException'>
    <summary>Exception thrown for arithmetic trap errors. (The "E" stands for
      "extended", and has this prefix to group it with the other classes common
      to this library, particularly EDecimal, EFloat, and ERational.).
    </summary>
  </doc>
  <doc name='M:PeterO.Numbers.ETrapException.#ctor(System.Int32,PeterO.Numbers.EContext,System.Object)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Numbers.ETrapException'/>
       class.
    </summary>
    <param name='flag'>A flag that specifies the kind of error (
      <c>EContext.FlagXXYY</c> ). This will only be one flag, such as
      <c>FlagInexact</c> or FlagSubnormal.
    </param>
    <param name='ctx'>A context object for arbitrary-precision arithmetic settings.
    </param>
    <param name='result'>The parameter
      <paramref name='result'/>
       is an arbitrary object.
    </param>
  </doc>
  <doc name='P:PeterO.Numbers.ETrapException.Context'>
    <summary>Gets the arithmetic context used during the operation that triggered the
      trap. May be null.
    </summary>
    <value>The arithmetic context used during the operation that triggered the trap.
      May be null.
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.ETrapException.Error'>
    <summary>Gets the flag that specifies the kind of error (EContext.FlagXXX). This
      will only be one flag, such as
      <c>FlagInexact</c> or FlagSubnormal.
    </summary>
    <value>The flag that specifies the kind of error (EContext.FlagXXX). This will
      only be one flag, such as.
      <c>FlagInexact</c> or FlagSubnormal.
    </value>
  </doc>
  <doc name='P:PeterO.Numbers.ETrapException.Result'>
    <summary>Gets the defined result of the operation that caused the trap.
    </summary>
    <value>The defined result of the operation that caused the trap.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.FastInteger.AddBig(PeterO.Numbers.EInteger)'>
    <summary>This is an internal API.
    </summary>
    <param name='bigintVal'>The parameter
      <paramref name='bigintVal'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.FastInteger.Multiply(System.Int32)'>
    <summary>This is an internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.FastInteger.Negate'>
    <summary>This is an internal API.
    </summary>
    <returns>A FastInteger object.
    </returns>
  </doc>
  <doc name='P:PeterO.Numbers.FastInteger.Sign'>
    <summary>Gets an internal value.
    </summary>
    <value>An internal value.
    </value>
  </doc>
  <doc name='M:PeterO.Numbers.FastInteger.Subtract(PeterO.Numbers.FastInteger)'>
    <summary>This is an internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.FastInteger.SubtractBig(PeterO.Numbers.EInteger)'>
    <summary>This is an internal API.
    </summary>
    <param name='bigintVal'>The parameter
      <paramref name='bigintVal'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.FastInteger.SubtractInt(System.Int32)'>
    <summary>This is an internal API.
    </summary>
    <param name='val'>The parameter
      <paramref name='val'/>
       is an internal value.
    </param>
    <returns>A FastInteger object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.FastInteger.ToString'>
    <summary>This is an internal API.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.FastIntegerFixed.Negate'>
    <summary>This is an internal API.
    </summary>
    <returns>A FastIntegerFixed object.
    </returns>
  </doc>
  <doc name='M:PeterO.Numbers.FastIntegerFixed.ToString'>
    <summary>This is an internal API.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='T:PeterO.Numbers.IShiftAccumulator'>
    <summary>Common interface for classes that shift a number of digits and record
      information on whether a non-zero digit was discarded this way.
    </summary>
  </doc>
  <doc name='T:PeterO.Numbers.RadixMath`1'>
    <summary>Encapsulates radix-independent arithmetic.
    </summary>
    <typeparam name='T'>Data type for a numeric value in a particular radix.
    </typeparam>
  </doc>
  <doc name='T:PeterO.Pair`2'>
    <summary>Stores a pair of related objects.
    </summary>
    <typeparam name='TFirst'>Object type for the first object in the pair.
    </typeparam>
    <typeparam name='TSecond'>Object type for the second object in the pair.
    </typeparam>
  </doc>
  <doc name='M:PeterO.Pair`2.#ctor(`0,`1)'>
    <summary>Initializes a new instance of the
      <see cref='!:&lt;TFirst,TSecond&gt;'/>
       class.
    </summary>
    <param name='first'>The parameter
      <paramref name='first'/>
       is a TFirst object.
    </param>
    <param name='second'>The parameter
      <paramref name='second'/>
       is a TSecond object.
    </param>
  </doc>
  <doc name='M:PeterO.Pair`2.Equals(PeterO.Pair{`0,`1})'>
    <summary>Not documented yet.
    </summary>
    <param name='other'>The parameter
      <paramref name='other'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Pair`2.Equals(System.Object)'>
    <summary>Determines whether this object and another object are equal.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param>
    <returns><c>true</c> if this object and another object are equal; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.Pair`2.First'>
    <summary>Gets the first object in the pair.
    </summary>
    <value>The first object in the pair.
    </value>
  </doc>
  <doc name='M:PeterO.Pair`2.GetHashCode'>
    <summary>Returns the hash code for this instance.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='P:PeterO.Pair`2.Second'>
    <summary>Gets the second object in the pair.
    </summary>
    <value>The second object in the pair.
    </value>
    <returns>A TSecond object.
    </returns>
  </doc>
  <doc name='M:PeterO.Pair`2.ToString'>
    <summary>Converts this object to a text string.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='T:PeterO.PartialStream'>
    <summary>Represents a portion of another data stream. For this to work, the
      underlying stream must be seekable and have a known length.
    </summary>
  </doc>
  <doc name='M:PeterO.PartialStream.#ctor(System.IO.Stream,System.Int64,System.Int64)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.PartialStream'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is a Stream object.
    </param>
    <param name='start'>The parameter
      <paramref name='start'/>
       is a 64-bit signed integer.
    </param>
    <param name='length'>The parameter
      <paramref name='length'/>
       is a 64-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.PartialStream.#ctor(System.IO.Stream,System.Int64,System.Int64,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.PartialStream'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is a Stream object.
    </param>
    <param name='start'>The start of the partial stream from the underlying stream.
    </param>
    <param name='length'>The length of the partial stream in bytes.
    </param>
    <param name='closeOnDispose'>If true, closes the underlying stream when disposing the partial stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       or
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='stream'/>
       doesn't support seeking, the length or start is less than 0 or greater
      than the underlying stream's length, or the partial stream would go beyond
      the underlying stream.
    </exception>
  </doc>
  <doc name='P:PeterO.PartialStream.CanRead'>
    <summary>Gets a value indicating whether the underlying stream supports reading.
    </summary>
    <value><c>true</c> If the underlying stream supports reading; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.PartialStream.CanSeek'>
    <summary>Gets a value indicating whether the underlying stream supports seeking.
    </summary>
    <value><c>true</c> If the underlying stream supports seeking; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='P:PeterO.PartialStream.CanWrite'>
    <summary>Gets a value indicating whether the underlying stream supports writing.
    </summary>
    <value><c>true</c> If the underlying stream supports writing; otherwise,
      <c>false</c> .
    </value>
  </doc>
  <doc name='M:PeterO.PartialStream.Dispose(System.Boolean)'>
    <summary>Not documented yet.
    </summary>
    <param name='disposing'>The parameter
      <paramref name='disposing'/>
       is either
      <c>true</c> or
      <c>false</c> .
    </param>
  </doc>
  <doc name='M:PeterO.PartialStream.Flush'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='P:PeterO.PartialStream.Length'>
    <summary>Gets the partial stream's length in bytes.
    </summary>
    <value>The partial stream's length in bytes.
    </value>
  </doc>
  <doc name='P:PeterO.PartialStream.Position'>
    <summary>Gets the partial stream's current byte position.
    </summary>
    <value>The partial stream's current byte position.
    </value>
  </doc>
  <doc name='M:PeterO.PartialStream.Read(System.Byte[],System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='buffer'>A byte array.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='buffer'/>
       begins.
    </param>
    <param name='count'>The number of elements in the desired portion of
      <paramref name='buffer'/>
       (but not more than
      <paramref name='buffer'/>
       's length).
    </param>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='buffer'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='count'/>
       is less than 0 or greater than
      <paramref name='buffer'/>
       's length, or
      <paramref name='buffer'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='count'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.PartialStream.Seek(System.Int64,System.IO.SeekOrigin)'>
    <summary>Not documented yet.
    </summary>
    <param name='offset'>The parameter
      <paramref name='offset'/>
       is a 64-bit signed integer.
    </param>
    <param name='origin'>The parameter
      <paramref name='origin'/>
       is a SeekOrigin object.
    </param>
    <returns>A 64-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.PartialStream.SetLength(System.Int64)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.PartialStream.Write(System.Byte[],System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='buffer'>A byte array.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='buffer'/>
       begins.
    </param>
    <param name='count'>The number of elements in the desired portion of
      <paramref name='buffer'/>
       (but not more than
      <paramref name='buffer'/>
       's length).
    </param>
  </doc>
  <doc name='T:PeterO.Png'>
    <summary>A simple class for encoding PNG image files.
    </summary>
  </doc>
  <doc name='M:PeterO.Png.#ctor(System.Int32,System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Png'/>
       class.
    </summary>
    <param name='width'>The parameter
      <paramref name='width'/>
       is a 32-bit signed integer.
    </param>
    <param name='height'>The parameter
      <paramref name='height'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.Png.GetFilter(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Png.GetPixel(System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='x'>X coordinate within the image.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='P:PeterO.Png.Height'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.Png.Save(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='filename'>The parameter
      <paramref name='filename'/>
       is a text string.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='filename'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Png.SetFilter(System.Int32,System.Byte)'>
    <summary>Not documented yet.
    </summary>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='filter'>The parameter
      <paramref name='filter'/>
       is a byte (from 0 to 255).
    </param>
  </doc>
  <doc name='M:PeterO.Png.SetPixel(System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)'>
    <summary>Not documented yet.
    </summary>
    <param name='x'>X coordinate within the image.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='r'>Red component of the pixel.
    </param>
    <param name='g'>Green component of the pixel.
    </param>
    <param name='b'>Blue component of the pixel.
    </param>
  </doc>
  <doc name='M:PeterO.Png.SetPixel(System.Int32,System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)'>
    <summary>Not documented yet.
    </summary>
    <param name='x'>X coordinate within the image.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='r'>Red component of the pixel.
    </param>
    <param name='g'>Green component of the pixel.
    </param>
    <param name='b'>Blue component of the pixel.
    </param>
    <param name='a'>The parameter
      <paramref name='a'/>
       is a byte (from 0 to 255).
    </param>
  </doc>
  <doc name='M:PeterO.Png.SetPixel(System.Int32,System.Int32,System.Byte[])'>
    <summary>Not documented yet.
    </summary>
    <param name='x'>X coordinate within the image.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='pixel'>A byte array.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='pixel'/>
       is null.
    </exception>
  </doc>
  <doc name='P:PeterO.Png.Width'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='T:PeterO.Png4BitIndexed'>
    <summary>A simple class for encoding PNG image files.
    </summary>
  </doc>
  <doc name='M:PeterO.Png4BitIndexed.#ctor(System.Int32,System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Png4BitIndexed'/>
       class.
    </summary>
    <param name='width'>The parameter
      <paramref name='width'/>
       is a 32-bit signed integer.
    </param>
    <param name='height'>The parameter
      <paramref name='height'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.Png4BitIndexed.GetColor(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.Png4BitIndexed.GetPixel(System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='x'>The parameter
      <paramref name='x'/>
       is a 32-bit signed integer.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='P:PeterO.Png4BitIndexed.Height'>
    <summary>Gets the height of the image.
    </summary>
    <value>The height of the image.
    </value>
  </doc>
  <doc name='M:PeterO.Png4BitIndexed.Save(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='filename'>The parameter
      <paramref name='filename'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Png4BitIndexed.SetColor(System.Int32,System.Byte[])'>
    <summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='color'>A byte array.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='color'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Png4BitIndexed.SetPixel(System.Int32,System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='x'>X coordinate within the image.
    </param>
    <param name='y'>Y coordinate within the image.
    </param>
    <param name='pixel'>The parameter
      <paramref name='pixel'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='P:PeterO.Png4BitIndexed.Transparent'>
    <summary>Gets or sets the index of the transparent color.
    </summary>
    <value>The index of the transparent color.
    </value>
  </doc>
  <doc name='P:PeterO.Png4BitIndexed.Width'>
    <summary>Gets the width of the image.
    </summary>
    <value>The width of the image.
    </value>
  </doc>
  <doc name='T:PeterO.Png8BitIndexed'>
    <summary>A simple class for encoding PNG image files.
    </summary>
  </doc>
  <doc name='M:PeterO.Png8BitIndexed.#ctor(System.Int32,System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Png8BitIndexed'/>
       class.
    </summary>
    <param name='width'>The parameter
      <paramref name='width'/>
       is a 32-bit signed integer.
    </param>
    <param name='height'>The parameter
      <paramref name='height'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.Png8BitIndexed.GetColor(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte array.
    </returns>
  </doc>
  <doc name='M:PeterO.Png8BitIndexed.GetFilter(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A byte (from 0 to 255).
    </returns>
  </doc>
  <doc name='M:PeterO.Png8BitIndexed.GetPixel(System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='x'>The parameter
      <paramref name='x'/>
       is a 32-bit signed integer.
    </param>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='P:PeterO.Png8BitIndexed.Height'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.Png8BitIndexed.Save(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='filename'>The parameter
      <paramref name='filename'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Png8BitIndexed.SetColor(System.Int32,System.Byte[])'>
    <summary>Not documented yet.
    </summary>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='color'>A byte array.
    </param>
  </doc>
  <doc name='M:PeterO.Png8BitIndexed.SetFilter(System.Int32,System.Byte)'>
    <summary>Not documented yet.
    </summary>
    <param name='y'>The parameter
      <paramref name='y'/>
       is a 32-bit signed integer.
    </param>
    <param name='filter'>The parameter
      <paramref name='filter'/>
       is a byte (from 0 to 255).
    </param>
  </doc>
  <doc name='M:PeterO.Png8BitIndexed.SetPixel(System.Int32,System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='x'>X coordinate within the image.
    </param>
    <param name='y'>Y coordinate within the image.
    </param>
    <param name='pixel'>The parameter
      <paramref name='pixel'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='P:PeterO.Png8BitIndexed.Transparent'>
    <summary>Gets or sets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='P:PeterO.Png8BitIndexed.Width'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='T:PeterO.PrecisionContext'>
    <summary>A precision context.
    </summary>
  </doc>
  <doc name='M:PeterO.PrecisionContext.#ctor(System.Int32,PeterO.Rounding,System.Int32,System.Int32,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.PrecisionContext'/>
       class. HasFlags will be set to false.
    </summary>
    <param name='precision'>The maximum number of digits a number can have, or 0 for an unlimited
      number of digits.
    </param>
    <param name='rounding'>The rounding mode to use when a number can't fit the given precision.
    </param>
    <param name='exponentMinSmall'>The minimum exponent.
    </param>
    <param name='exponentMaxSmall'>The maximum exponent.
    </param>
    <param name='clampNormalExponents'>Whether to clamp a number's significand to the given maximum precision (if
      it isn't zero) while remaining within the exponent range.
    </param>
  </doc>
  <doc name='M:PeterO.PrecisionContext.ToString'>
    <summary>Gets a string representation of this object. Note that the format is not
      intended to be parsed and may change at any time.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='T:PeterO.Rdf.IRDFParser'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.IRDFParser.Parse'>
    <summary>Not documented yet.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='T:PeterO.Rdf.NTriplesParser'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.NTriplesParser.#ctor(PeterO.IByteReader)'>
    <summary>Initializes a new instance of the
      <see cref='NTriplesParser'/>
       class.
    </summary>
    <param name='stream'>A PeterO.IByteReader object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.NTriplesParser.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='NTriplesParser'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter "stream" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.NTriplesParser.IsAsciiChar(System.Int32,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='c'>The parameter
      <paramref name='c'/>
       is not documented yet.
    </param>
    <param name='asciiChars'>The parameter
      <paramref name='asciiChars'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.NTriplesParser.Parse'>
    <summary>Not documented yet.
    </summary>
    <returns>An ISet(RDFTriple) object.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.NTriplesParser.isAsciiChar(System.Int32,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='c'>The parameter
      <paramref name='c'/>
       is not documented yet.
    </param>
    <param name='asciiChars'>The parameter
      <paramref name='asciiChars'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='T:PeterO.Rdf.ParserException'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.ParserException.#ctor'>
    <summary>Initializes a new instance of the
      <see cref='ParserException'/>
       class.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.ParserException.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='ParserException'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.RDFInternal.ReplaceBlankNodes(System.Collections.Generic.ISet{PeterO.Rdf.RDFTriple},System.Collections.Generic.IDictionary{System.String,PeterO.Rdf.RDFTerm})'>
    <summary>Not documented yet.
    </summary>
    <param name='triples'>The parameter
      <paramref name='triples'/>
       is not documented yet.
    </param>
    <param name='bnodeLabels'>The parameter
      <paramref name='bnodeLabels'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.RDFInternal.replaceBlankNodes(System.Collections.Generic.ISet{PeterO.Rdf.RDFTriple},System.Collections.Generic.IDictionary{System.String,PeterO.Rdf.RDFTerm})'>
    <summary>Not documented yet.
    </summary>
    <param name='triples'>The parameter
      <paramref name='triples'/>
       is not documented yet.
    </param>
    <param name='bnodeLabels'>The parameter
      <paramref name='bnodeLabels'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='T:PeterO.Rdf.RDFTerm'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.A'>
    <summary>Predicate for RDF types.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.BLANK'>
    <summary>Type value for a blank node.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.Equals(System.Object)'>
    <summary>Not documented yet.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is not documented yet.
    </param>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.FALSE'>
    <summary>Object for false.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.FIRST'>
    <summary>Predicate for the first object in a list.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.FromBlankNode(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='name'>The parameter
      <paramref name='name'/>
       is not documented yet.
    </param>
    <returns>A RDFTerm object.
    </returns>
    <exception cref='T:System.ArgumentException'>Name is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.FromIRI(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='iri'>The parameter
      <paramref name='iri'/>
       is not documented yet.
    </param>
    <returns>A RDFTerm object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='iri'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.FromLangString(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <param name='languageTag'>The parameter
      <paramref name='languageTag'/>
       is not documented yet.
    </param>
    <returns>A RDFTerm object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       or
      <paramref name='languageTag'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>LanguageTag is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.FromTypedString(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <returns>A RDFTerm object.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.FromTypedString(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <param name='iri'>The parameter
      <paramref name='iri'/>
       is not documented yet.
    </param>
    <returns>A RDFTerm object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       or
      <paramref name='iri'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Iri is empty.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.GetHashCode'>
    <summary>Not documented yet.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.GetKind'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.GetTypeOrLanguage'>
    <summary>Gets the language tag or data type for this RDF literal.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.GetValue'>
    <summary>Gets the IRI, blank node identifier, or lexical form of an RDF literal.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.IRI'>
    <summary>Type value for an IRI (Internationalized Resource Identifier.).
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.IsBlank'>
    <summary>Gets a value indicating whether this term is a blank node.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.IsIRI(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.IsOrdinaryString'>
    <summary>Not documented yet.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.LANGSTRING'>
    <summary>Type value for a string with a language tag.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.NIL'>
    <summary>Object for nil, the end of a list, or an empty list.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.REST'>
    <summary>Predicate for the remaining objects in a list.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.TRUE'>
    <summary>Object for true.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.RDFTerm.TYPEDSTRING'>
    <summary>Type value for a piece of data serialized to a string.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.ToString'>
    <summary>Gets a string representation of this RDF term in N-Triples format. The
      string will not end in a line break.
    </summary>
    <returns>A string representation of this object.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.getKind'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.getTypeOrLanguage'>
    <summary>Gets the language tag or data type for this RDF literal.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.getValue'>
    <summary>Gets the IRI, blank node identifier, or lexical form of an RDF literal.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.isBlank'>
    <summary>Gets whether this term is a blank node.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.isIRI(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is not documented yet.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTerm.isOrdinaryString'>
    <summary>Not documented yet.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='T:PeterO.Rdf.RDFTriple'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.#ctor(PeterO.Rdf.RDFTerm,PeterO.Rdf.RDFTerm,PeterO.Rdf.RDFTerm)'>
    <summary>Initializes a new instance of the
      <see cref='RDFTriple'/>
       class.
    </summary>
    <param name='subject'>The subject term.
    </param>
    <param name='predicate'>The predicate term.
    </param>
    <param name='objectRdf'>The object term.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.#ctor(PeterO.Rdf.RDFTriple)'>
    <summary>Initializes a new instance of the
      <see cref='RDFTriple'/>
       class.
    </summary>
    <param name='triple'>The parameter
      <paramref name='triple'/>
       is a RDFTriple object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='triple'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.Equals(System.Object)'>
    <summary>Not documented yet.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is not documented yet.
    </param>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.GetHashCode'>
    <summary>Not documented yet.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.GetObject'>
    <summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.GetPredicate'>
    <summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.GetSubject'>
    <summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.ToString'>
    <summary>Not documented yet.
    </summary>
    <returns>The return value is not documented yet.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.getObject'>
    <summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.getPredicate'>
    <summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.RDFTriple.getSubject'>
    <summary>Not documented yet.
    </summary>
    <returns>A RDFTerm object.
    </returns>
  </doc>
  <doc name='T:PeterO.Rdf.TurtleParser'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.TurtleParser.#ctor(PeterO.IByteReader)'>
    <summary>Initializes a new instance of the
      <see cref='TurtleParser'/>
       class.
    </summary>
    <param name='stream'>A PeterO.IByteReader object.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.TurtleParser.#ctor(PeterO.IByteReader,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='TurtleParser'/>
       class.
    </summary>
    <param name='stream'>A PeterO.IByteReader object.
    </param>
    <param name='baseURI'>The parameter
      <paramref name='baseURI'/>
       is a text string.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       or
      <paramref name='baseURI'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>BaseURI.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.TurtleParser.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='TurtleParser'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.TurtleParser.#ctor(System.String,System.String)'>
    <summary>Initializes a new instance of the
      <see cref='TurtleParser'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='baseURI'>The parameter
      <paramref name='baseURI'/>
       is a text string.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       or
      <paramref name='baseURI'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>BaseURI.
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.TurtleParser.Parse'>
    <summary>Not documented yet.
    </summary>
    <returns>An ISet(RDFTriple) object.
    </returns>
  </doc>
  <doc name='T:PeterO.Rdf.URIUtility'>
    <summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
  </doc>
  <doc name='T:PeterO.Rdf.URIUtility.ParseMode'>
    <summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.IRILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.IRIStrict'>
    <summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.IRISurrogateLenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.URILenient'>
    <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
  </doc>
  <doc name='F:PeterO.Rdf.URIUtility.ParseMode.URIStrict'>
    <summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.escapeURI(System.String,System.Int32)'>
    <returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
    <summary>Escapes characters that cannot appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.hasScheme(System.String)'>
    <summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid IRI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.hasSchemeForURI(System.String)'>
    <summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww</code> The following cases return false:
      <code>x@y:/z /x/y/z example.xyz</code> .
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c> if the string is a valid URI with a scheme component; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)'>
    <summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c> if the substring is a valid CURIE reference under RDFA 1; otherwise,
      <c>false</c> . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue. Example: http://example.com/my/path/dir/file.txt.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String,PeterO.Rdf.URIUtility.ParseMode)'>
    <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c> .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c> .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.splitIRI(System.String)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
      <returns>If the string is a valid IRI reference, returns an array of 10 integers.
        Each of the five pairs corresponds to the start and end index of the
        IRI's scheme, authority, path, query, or fragment component,
        respectively. If a component is absent, both indices in that pair will
        be -1. If the string is null or is not a valid IRI, returns null.
      </returns>
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.splitIRI(System.String,PeterO.Rdf.URIUtility.ParseMode)'>
    <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1. If the string
      is null or is not a valid IRI, returns null.
    </returns>
  </doc>
  <doc name='M:PeterO.Rdf.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Rdf.URIUtility.ParseMode)'>
    <summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment component, respectively. If a
      component is absent, both indices in that pair will be -1 (an index won't
      be less than 0 in any other case). If the string is null or is not a valid
      IRI, returns null.
    </returns>
  </doc>
  <doc name='T:PeterO.Rounding'>
    <summary><para><b>This class is obsolete. It will be replaced by a new version of this
          class in a different namespace/package and library, called
          <c>PeterO.Numbers.ERounding</c> in the
          <c>PeterO.ERounding</c> library (in .NET), or
          <c>com.upokecenter.numbers.EFloat</c> in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java).</b> </para>
       Specifies the mode to use when "shortening" numbers that otherwise can't
      fit a given number of digits, so that the shortened number has about the
      same value. This "shortening" is known as rounding.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.Ceiling'>
    <summary>If there is a fractional part, the number is rounded to the highest
      representable number that's closest to it.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.Down'>
    <summary>The fractional part is discarded (the number is truncated).
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.Floor'>
    <summary>If there is a fractional part, the number is rounded to the lowest
      representable number that's closest to it.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.HalfDown'>
    <summary>Rounded to the nearest number; if the fractional part is exactly half, it
      is discarded.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.HalfEven'>
    <summary>Rounded to the nearest number; if the fractional part is exactly half, the
      number is rounded to the closest representable number that is even. This
      is sometimes also known as "banker's rounding".
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.HalfUp'>
    <summary>Rounded to the nearest number; if the fractional part is exactly half, the
      number is rounded to the closest representable number away from zero. This
      is the most familiar rounding mode for many people.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.Odd'>
    <summary>If there is a fractional part and the whole number part is even, the
      number is rounded to the closest representable odd number away from zero.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.OddOrZeroFiveUp'>
    <summary>For binary floating point numbers, this is the same as Odd. For other
      bases (including decimal numbers), this is the same as ZeroFiveUp. This
      rounding mode is useful for rounding intermediate results at a slightly
      higher precision (at least 2 bits more for binary) than the final
      precision.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.Unnecessary'>
    <summary>Indicates that rounding will not be used. If rounding is required, the
      rounding operation will report an error.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.Up'>
    <summary>If there is a fractional part, the number is rounded to the closest
      representable number away from zero.
    </summary>
  </doc>
  <doc name='F:PeterO.Rounding.ZeroFiveUp'>
    <summary>If there is a fractional part and if the last digit before rounding is 0
      or half the radix, the number is rounded to the closest representable
      number away from zero; otherwise the fractional part is discarded. In
      overflow, the fractional part is always discarded.
    </summary>
  </doc>
  <doc name='M:PeterO.SingleComparer.GetHashCode(System.Single)'>
    <summary>Returns the hash code for this instance.
    </summary>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is not documented yet.
    </param>
    <returns>A 32-bit hash code.
    </returns>
  </doc>
  <doc name='T:PeterO.StackableCharacterInput'>
    <summary>A character input stream where additional inputs can be stacked on.
    </summary>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.#ctor(PeterO.Text.ICharacterInput)'>
    <summary>Initializes a new instance of the
      <see cref='StackableCharacterInput'/>
       class.
    </summary>
    <param name='source'>The parameter
      <paramref name='source'/>
       is an ICharacterInput object.
    </param>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.GetMarkPosition'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.MoveBack(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='count'>The parameter
      <paramref name='count'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.PushInput(PeterO.Text.ICharacterInput)'>
    <summary>Not documented yet.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='buf'>The parameter
      <paramref name='buf'/>
       is not documented yet.
    </param>
    <param name='offset'>The parameter
      <paramref name='offset'/>
       is not documented yet.
    </param>
    <param name='unitCount'>The parameter
      <paramref name='unitCount'/>
       is not documented yet.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='buf'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.ReadChar'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.SetHardMark'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.SetMarkPosition(System.Int32)'>
    <summary>Not documented yet.
    </summary>
    <param name='pos'>The parameter
      <paramref name='pos'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.SetSoftMark'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.getMarkPosition'>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.moveBack(System.Int32)'>
    <param name='count'>The parameter
      <paramref name='count'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.pushInput(PeterO.Text.ICharacterInput)'>
    <summary>Not documented yet.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.setHardMark'>
    <summary>Not documented yet.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.setMarkPosition(System.Int32)'>
    <param name='pos'>The parameter
      <paramref name='pos'/>
       is not documented yet.
    </param>
  </doc>
  <doc name='M:PeterO.StackableCharacterInput.setSoftMark'>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.ByteData.DecompressLz4(System.Byte[])'>
    <summary>Decompresses a byte array compressed using the LZ4 format (see "LZ4 Format
      Description" by Y Collet for more information).
    </summary>
    <param name='input'>Input byte array.
    </param>
    <returns>Decompressed output byte array.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "output" is null.
    </exception>
  </doc>
  <doc name='T:PeterO.Text.CharacterReader'>
    <summary>A general-purpose character input for reading text from byte streams and
      text strings. When reading byte streams, this class supports the UTF-8
      character encoding by default, but can be configured to support UTF-16 and
      UTF-32 as well.
    </summary>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.IO.Stream)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class; will read the stream as UTF-8, skip the byte-order mark (U+FEFF)
      if it appears first in the stream, and replace invalid byte sequences with
      replacement characters (U+FFFD).
    </summary>
    <param name='stream'>A readable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.IO.Stream,System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class; will skip the byte-order mark (U+FEFF) if it appears first in the
      stream and replace invalid byte sequences with replacement characters
      (U+FFFD).
    </summary>
    <param name='stream'>A readable byte stream.
    </param>
    <param name='mode'>The method to use when detecting encodings other than UTF-8 in the byte
      stream. This usually involves checking whether the stream begins with a
      byte-order mark (BOM, U+FEFF) or a non-zero basic code point (NZB, U+0001
      to U+007F) before reading the rest of the stream. This value can be one of
      the following:
      <list>
        <item>0: UTF-8 only.
        </item>
        <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.
        </item>
        <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8. (Tries to
          detect UTF-32 first.)
        </item>
        <item>3: Detect UTF-16 using BOM, otherwise UTF-8.
        </item>
        <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to detect
          UTF-32 first.)
        </item>
      </list>
       .
    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.IO.Stream,System.Int32,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class; will skip the byte-order mark (U+FEFF) if it appears first in the
      stream.
    </summary>
    <param name='stream'>A readable byte stream.
    </param>
    <param name='mode'>The method to use when detecting encodings other than UTF-8 in the byte
      stream. This usually involves checking whether the stream begins with a
      byte-order mark (BOM, U+FEFF) or a non-zero basic code point (NZB, U+0001
      to U+007F) before reading the rest of the stream. This value can be one of
      the following:
      <list>
        <item>0: UTF-8 only.
        </item>
        <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.
        </item>
        <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8. (Tries to
          detect UTF-32 first.)
        </item>
        <item>3: Detect UTF-16 using BOM, otherwise UTF-8.
        </item>
        <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to detect
          UTF-32 first.)
        </item>
      </list>
       .
    </param>
    <param name='errorThrow'>If true, will throw an exception if invalid byte sequences (in the
      detected encoding) are found in the byte stream. If false, replaces those
      byte sequences with replacement characters (U+FFFD) as the stream is read.

    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.IO.Stream,System.Int32,System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class.
    </summary>
    <param name='stream'>A readable byte stream.
    </param>
    <param name='mode'>The method to use when detecting encodings other than UTF-8 in the byte
      stream. This usually involves checking whether the stream begins with a
      byte-order mark (BOM, U+FEFF) or a non-zero basic code point (NZB, U+0001
      to U+007F) before reading the rest of the stream. This value can be one of
      the following:
      <list>
        <item>0: UTF-8 only.
        </item>
        <item>1: Detect UTF-16 using BOM or NZB, otherwise UTF-8.
        </item>
        <item>2: Detect UTF-16/UTF-32 using BOM or NZB, otherwise UTF-8. (Tries to
          detect UTF-32 first.)
        </item>
        <item>3: Detect UTF-16 using BOM, otherwise UTF-8.
        </item>
        <item>4: Detect UTF-16/UTF-32 using BOM, otherwise UTF-8. (Tries to detect
          UTF-32 first.)
        </item>
      </list>
       .
    </param>
    <param name='errorThrow'>If true, will throw an exception if invalid byte sequences (in the
      detected encoding) are found in the byte stream. If false, replaces those
      byte sequences with replacement characters (U+FFFD) as the stream is read.

    </param>
    <param name='dontSkipUtf8Bom'>If the stream is detected as UTF-8 and this parameter is
      <c>true</c> , won't skip the BOM character if it occurs at the start of the stream.
    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class using a Unicode 16-bit string; if the string begins with a
      byte-order mark (U+FEFF), it won't be skipped, and any unpaired surrogate
      code points (U+D800 to U+DFFF) in the string are replaced with replacement
      characters (U+FFFD).
    </summary>
    <param name='str'>The string to read.
    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.String,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class using a Unicode 16-bit string; any unpaired surrogate code points
      (U+D800 to U+DFFF) in the string are replaced with replacement characters
      (U+FFFD).
    </summary>
    <param name='str'>The string to read.
    </param>
    <param name='skipByteOrderMark'>If true and the string begins with a byte-order mark (U+FEFF), will skip
      that code point as it reads the string.
    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.String,System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class using a Unicode 16-bit string.
    </summary>
    <param name='str'>The string to read.
    </param>
    <param name='skipByteOrderMark'>If true and the string begins with a byte-order mark (U+FEFF), will skip
      that code point as it reads the string.
    </param>
    <param name='errorThrow'>If true, will throw an exception if unpaired surrogate code points (U+D800
      to U+DFFF) are found in the string. If false, replaces those byte
      sequences with replacement characters (U+FFFD) as the stream is read.
    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.String,System.Int32,System.Int32)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.#ctor(System.String,System.Int32,System.Int32,System.Boolean,System.Boolean)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.CharacterReader'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <param name='skipByteOrderMark'>If true and the string begins with a byte-order mark (U+FEFF), will skip
      that code point as it reads the string.
    </param>
    <param name='errorThrow'>If true, will throw an exception if unpaired surrogate code points (U+D800
      to U+DFFF) are found in the string. If false, replaces those byte
      sequences with replacement characters (U+FFFD) as the stream is read.
    </param>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a series of code points from a Unicode stream or a string.
    </summary>
    <param name='chars'>An array where the code points that were read will be stored.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>The number of code points read from the stream. This can be less than the
      <paramref name='length'/>
       parameter if the end of the stream is reached.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='chars'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='index'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='chars'/>
       's length, or
      <paramref name='chars'/>
       's length minus
      <paramref name='index'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.Text.CharacterReader.ReadChar'>
    <summary>Reads the next character from a Unicode stream or a string.
    </summary>
    <returns>The next character, or -1 if the end of the string or stream was reached.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.DomainUtility'>
    <summary>Utility methods for domain names.
    </summary>
  </doc>
  <doc name='M:PeterO.Text.DomainUtility.PunycodeLength(System.String,System.Int32,System.Int32)'>
    <summary>Gets the Punycode length of a string (Punycode is defined in RFC 3492).
    </summary>
    <param name='str'>A string containing the desired portion to get the length for.
    </param>
    <param name='index'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The Punycode length of the encoded string. If the string contains code
      points outside the Basic Latin range (U+0000 to U+007F), returns the
      Punycode length plus 4 (the length of the prefix "xn--", which indicates
      an internationalized domain name). If there are only Basic Latin code
      points, returns the length of the string. Returns -1 if an overflow error
      occurs.
    </returns>
    <exception cref='T:System.ArgumentNullException'>Either
      <paramref name='index'/>
       or
      <paramref name='endIndex'/>
       is less than 0 or greater than
      <paramref name='str'/>
       's length, or
      <paramref name='index'/>
       is greater than
      <paramref name='endIndex'/>
       .
    </exception>
  </doc>
  <doc name='T:PeterO.Text.Encodings'>
    <summary>Contains methods for converting text from one character encoding to
      another. This class also contains convenience methods for converting
      strings and other character inputs to sequences of bytes and vice versa.
      <para>The Encoding Standard, which is a Candidate Recommendation as of early
        November 2015, defines algorithms for the most common character
        encodings used on Web pages and recommends the UTF-8 encoding for new
        specifications and Web pages. Calling the
        <c>GetEncoding(name)</c> method returns one of the character encodings with the given name under
        the Encoding Standard.
      </para>
      <para>Now let's define some terms.
      </para>
      <para><b>Encoding Terms</b> </para>
      <list>
        <item>A
          <b>code point</b> is a number that identifies a single text character, such as a
          letter, digit, or symbol. (A collection of such characters is also
          called an
          <i>
             abstract character repertoire
          </i>
           .)
        </item>
        <item>A
          <b>coded character set</b> is a set of code points which are each assigned to a single text
          character. As used here, coded character sets don't define how code
          points are laid out in memory.
        </item>
        <item>A
          <b>character encoding</b> is a mapping from a sequence of code points, in one or more specific
          coded character sets, to a sequence of bytes and vice versa. (For
          brevity, the rest of this documentation may use the term
          <i>
             encoding
          </i>
           instead. RFC 6365 uses the analogous term
          <i>
             charset
          </i>
           instead; in this documentation, however,
          <i>
             charset
          </i>
           is used only to refer to the names that identify a character
          encoding.)
        </item>
        <item><b>ASCII</b> is a 128-code-point coded character set that includes the English
          letters and digits, common punctuation and symbols, and control
          characters. As used here, its code points match the code points within
          the Basic Latin block (0-127 or U+0000 to U+007F) of the Unicode
          Standard.
        </item>
      </list>
      <para>There are several kinds of character encodings:
      </para>
      <list>
        <item><b>Single-byte encodings</b> define a coded character set that assigns one code point to one byte.
          Thus, they can have a maximum of 256 code points. For example:
        </item>
        <item>(a) ISO 8859 encodings and
          <c>windows-1252</c> .
        </item>
        <item>(b) ASCII is usually used as a single-byte encoding where each code
          point fits in the lower 7 bits of an eight-bit byte (in that case, the
          encoding is often called
          <c>US-ASCII</c> ). In the Encoding Standard, all single-byte encodings use the ASCII
          characters as the first 128 code points of their coded character sets.

        </item>
        <item><b>Multi-byte encodings</b> include code points from one or more coded character sets and assign
          some or all code points to several bytes. For example:
        </item>
        <item>(a)
          <c>UTF-16LE</c> and
          <c>UTF-16BE</c> are two encodings defined in the Unicode Standard. They use 2 bytes
          for the most common code points, and 4 bytes for supplementary code
          points.
        </item>
        <item>(b)
          <c>UTF-8</c> is another encoding defined in the Unicode Standard. It uses 1 byte
          for ASCII and 2 to 4 bytes for the other Unicode code points.
        </item>
        <item>(c) Most legacy East Asian encodings, such as
          <c>Shift_JIS</c> ,
          <c>GBK</c> , and
          <c>Big5</c> use 1 byte for ASCII (or a slightly modified version) and, usually, 2
          or more bytes for national standard coded character sets. In many of
          these encodings, notably
          <c>Shift_JIS</c> , characters whose code points use one byte traditionally take half
          the space of characters whose code points use two bytes.
        </item>
        <item><b>Escape-based encodings</b> are combinations of single- and/or multi-byte encodings, and use
          escape sequences and/or shift codes to change which encoding to use
          for the bytes that follow. For example:
        </item>
        <item>(a)
          <c>ISO-2022-JP</c> supports several escape sequences that shift into different
          encodings, including a Katakana, a Kanji, and an ASCII encoding (with
          ASCII as the default).
        </item>
        <item>(b) UTF-7 (not included in the Encoding Standard) is an encoding that
          uses the Unicode Standard's coded character set, which is encoded
          using a limited subset of ASCII. The plus symbol (U+002B) is used to
          shift into a UTF-16BE multi-byte encoding (converted to a modified
          version of base-64) to encode other Unicode code points.
        </item>
        <item>The Encoding Standard also defines a
          <b>replacement encoding</b> , which causes a decoding error and is used to alias a few
          problematic or unsupported encoding names, such as
          <c>hz-gb-2312</c> .
        </item>
      </list>
      <para><b>Getting an Encoding</b> </para>
      <para>The Encoding Standard includes UTF-8, UTF-16, and many legacy encodings,
        and gives each one of them a name. The
        <c>GetEncoding(name)</c> method takes a name string and returns an ICharacterEncoding object
        that implements that encoding, or
        <c>null</c> if the name is unrecognized.
      </para>
      <para>However, the Encoding Standard is designed to include only encodings
        commonly used on Web pages, not in other protocols such as email. For
        email, the Encoding class includes an alternate function
        <c>GetEncoding(name, forEmail)</c> . Setting
        <c>forEmail</c> to
        <c>true</c> will use rules modified from the Encoding Standard to better suit
        encoding and decoding text from email messages.
      </para>
      <para><b>Classes for Character Encodings</b> </para>
      <para>This Encodings class provides access to common character encodings
        through classes as described below:
      </para>
      <list type=''>
        <item>An
          <b>encoder class</b> is a class that converts a sequence of bytes to a sequence of code
          points in the universal character set (otherwise known under the name
          Unicode). An encoder class implements the
          <c>ICharacterEncoder</c> interface.
        </item>
        <item>A
          <b>decoder class</b> is a class that converts a sequence of Unicode code points to a
          sequence of bytes. A decoder class implements the
          <c>ICharacterDecoder</c> interface.
        </item>
        <item>An
          <b>encoding class</b> allows access to both an encoder class and a decoder class and
          implements the
          <c>ICharacterEncoding</c> interface. The encoder and decoder classes should implement the same
          character encoding.
        </item>
      </list>
      <para><b>Custom Encodings</b> </para>
      <para>Classes that implement the ICharacterEncoding interface can provide
        additional character encodings not included in the Encoding Standard.
        Some examples of these include the following:
      </para>
      <list>
        <item>A modified version of UTF-8 used in Java's serialization formats.
        </item>
        <item>A modified version of UTF-7 used in the IMAP email protocol.
        </item>
      </list>
      <para>(Note that this library doesn't implement either encoding.)
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.Encodings.DecodeToString(PeterO.Text.ICharacterEncoding,PeterO.IByteReader)'>
    <summary>Reads bytes from a data source and converts the bytes from a given
      encoding to a text string.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows: "encoding.DecodeString(input)". If the object's class
        already has a DecodeToString method with the same parameters, that
        method takes precedence over this extension method.
      </para>
    </summary>
    <param name='encoding'>An object that implements a given character encoding. Any bytes that can't
      be decoded are converted to the replacement character (U+FFFD).
    </param>
    <param name='input'>An object that implements a byte stream.
    </param>
    <returns>The converted string.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='encoding'/>
       or
      <paramref name='input'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Encodings.DecodeToString(PeterO.Text.ICharacterEncoding,System.Byte[])'>
    <summary>Reads a byte array from a data source and converts the bytes from a given
      encoding to a text string. Errors in decoding are handled by replacing
      erroneous bytes with the replacement character (U+FFFD).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>enc.DecodeToString(bytes)</c> . If the object's class already has a DecodeToString method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='bytes'>A byte array.
    </param>
    <returns>A string consisting of the decoded text.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='enc'/>
       or
      <paramref name='bytes'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Encodings.DecodeToString(PeterO.Text.ICharacterEncoding,System.Byte[],System.Int32,System.Int32)'>
    <summary>Reads a portion of a byte array from a data source and converts the bytes
      from a given encoding to a text string. Errors in decoding are handled by
      replacing erroneous bytes with the replacement character (U+FFFD).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>enc.DecodeToString(bytes, offset, length)</c> . If the object's class already has a DecodeToString method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='bytes'>A byte array containing the desired portion to read.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='bytes'/>
       begins.
    </param>
    <param name='length'>The length, in bytes, of the desired portion of
      <paramref name='bytes'/>
       (but not more than
      <paramref name='bytes'/>
       's length).
    </param>
    <returns>A string consisting of the decoded text.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.DecodeToString(PeterO.Text.ICharacterEncoding,System.IO.Stream)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.DecodeToString(input)</c> . If the object's class already has a DecodeToString method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='input'>A readable byte stream.
    </param>
    <returns>A string consisting of the decoded text.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "encoding" or
      <paramref name='input'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Encodings.DecoderToInputClass.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>This is an internal method.
    </summary>
    <param name='buffer'>An array of 32-bit unsigned integers.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='buffer'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='buffer'/>
       (but not more than
      <paramref name='buffer'/>
       's length).
    </param>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='buffer'/>
       's length, or
      <paramref name='buffer'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Encodings.DecoderToInputClass.ReadChar'>
    <summary>This is an internal method.
    </summary>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToBytes(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoder)'>
    <summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded using a given character encoding. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoder)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoder'>An object that implements a character encoder.
    </param>
    <returns>A byte array.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='encoder'/>
       or
      <paramref name='input'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToBytes(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoding)'>
    <summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded using the given character encoder. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoding)</c> . If the object's class already has an EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoding'>An object that implements a given character encoding.
    </param>
    <returns>A byte array containing the encoded text.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='encoding'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToBytes(System.String,PeterO.Text.ICharacterEncoding)'>
    <summary>Reads Unicode characters from a text string and writes them to a byte
      array encoded in a given character encoding. When reading the string, any
      unpaired surrogate characters are replaced with the replacement character
      (U+FFFD), and when writing to the byte array, any characters that can't be
      encoded are replaced with the byte 0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.EncodeToBytes(enc)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <returns>A byte array.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       or
      <paramref name='enc'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToWriter(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoder,PeterO.IWriter)'>
    <summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded in a given character encoding. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoder)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoder'>An object that implements a character encoder.
    </param>
    <param name='writer'>A byte writer to write the encoded bytes to.
    </param>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToWriter(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoder,System.IO.Stream)'>
    <summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded in a given character encoding. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoder)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoder'>An object that implements a character encoder.
    </param>
    <param name='output'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToWriter(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoding,PeterO.IWriter)'>
    <summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded using the given character encoder. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoding)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoding'>An object that implements a character encoding.
    </param>
    <param name='writer'>A byte writer to write the encoded bytes to.
    </param>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToWriter(PeterO.Text.ICharacterInput,PeterO.Text.ICharacterEncoding,System.IO.Stream)'>
    <summary>Reads Unicode characters from a character input and writes them to a byte
      array encoded using the given character encoder. When writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>input.EncodeToBytes(encoding)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='input'>An object that implements a stream of universal code points.
    </param>
    <param name='encoding'>An object that implements a character encoding.
    </param>
    <param name='output'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToWriter(System.String,PeterO.Text.ICharacterEncoding,PeterO.IWriter)'>
    <summary>Converts a text string to bytes and writes the bytes to an output byte
      writer. When reading the string, any unpaired surrogate characters are
      replaced with the replacement character (U+FFFD), and when writing to the
      byte stream, any characters that can't be encoded are replaced with the
      byte 0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.EncodeToBytes(enc, writer)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>A text string to encode.
    </param>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='writer'>A byte writer where the encoded bytes will be written to.
    </param>
  </doc>
  <doc name='M:PeterO.Text.Encodings.EncodeToWriter(System.String,PeterO.Text.ICharacterEncoding,System.IO.Stream)'>
    <summary>Converts a text string to bytes and writes the bytes to an output data
      stream. When reading the string, any unpaired surrogate characters are
      replaced with the replacement character (U+FFFD), and when writing to the
      byte stream, any characters that can't be encoded are replaced with the
      byte 0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.EncodeToBytes(enc, writer)</c> . If the object's class already has a EncodeToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>A text string to encode.
    </param>
    <param name='enc'>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </param>
    <param name='output'>A writable data stream.
    </param>
  </doc>
  <doc name='M:PeterO.Text.Encodings.GetDecoderInput(PeterO.Text.ICharacterEncoding,PeterO.IByteReader)'>
    <summary>Converts a character encoding into a character input stream, given a
      streamable source of bytes. The input stream doesn't check the first few
      bytes for a byte-order mark indicating a Unicode encoding such as UTF-8
      before using the character encoding's decoder.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows: "encoding.GetDecoderInput(input)". If the object's class
        already has a GetDecoderInput method with the same parameters, that
        method takes precedence over this extension method.
      </para>
    </summary>
    <param name='encoding'>Encoding that exposes a decoder to be converted into a character input
      stream. If the decoder returns -2 (indicating a decode error), the
      character input stream handles the error by returning a replacement
      character in its place.
    </param>
    <param name='stream'>Byte stream to convert into Unicode characters.
    </param>
    <returns>An ICharacterInput object.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.GetDecoderInput(PeterO.Text.ICharacterEncoding,System.IO.Stream)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.GetDecoderInput(input)</c> . If the object's class already has a GetDecoderInput method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='encoding'>Encoding object that exposes a decoder to be converted into a character
      input stream. If the decoder returns -2 (indicating a decode error), the
      character input stream handles the error by returning a replacement
      character in its place.
    </param>
    <param name='input'>Byte stream to convert into Unicode characters.
    </param>
    <returns>An ICharacterInput object.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.GetDecoderInputSkipBom(PeterO.Text.ICharacterEncoding,PeterO.IByteReader)'>
    <summary>Converts a character encoding into a character input stream, given a
      streamable source of bytes. But if the input stream starts with a UTF-8 or
      UTF-16 byte order mark, the input is decoded as UTF-8 or UTF-16, as the
      case may be, rather than the given character encoding.
      <para>This method implements the "decode" algorithm specified in the Encoding
        standard.
      </para>
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.GetDecoderInputSkipBom(input)</c> . If the object's class already has a
        <c>GetDecoderInputSkipBom</c> method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='encoding'>Encoding object that exposes a decoder to be converted into a character
      input stream. If the decoder returns -2 (indicating a decode error), the
      character input stream handles the error by returning a replacement
      character in its place.
    </param>
    <param name='stream'>Byte stream to convert into Unicode characters.
    </param>
    <returns>An ICharacterInput object.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.GetDecoderInputSkipBom(PeterO.Text.ICharacterEncoding,System.IO.Stream)'>
    <summary>Converts a character encoding into a character input stream, given a
      readable data stream. But if the input stream starts with a UTF-8 or
      UTF-16 byte order mark, the input is decoded as UTF-8 or UTF-16, as the
      case may be, rather than the given character encoding.This method
      implements the "decode" algorithm specified in the Encoding standard.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.GetDecoderInputSkipBom(input)</c> . If the object's class already has a
        <c>GetDecoderInputSkipBom</c> method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='encoding'>Encoding object that exposes a decoder to be converted into a character
      input stream. If the decoder returns -2 (indicating a decode error), the
      character input stream handles the error by returning a replacement
      character in its place.
    </param>
    <param name='input'>Byte stream to convert into Unicode characters.
    </param>
    <returns>An ICharacterInput object.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.GetEncoding(System.String)'>
    <summary>Returns a character encoding from the given name.
    </summary>
    <param name='name'>A string naming a character encoding. See the ResolveAlias method. Can be
      null.
    </param>
    <returns>An object implementing a character encoding (gives access to an encoder
      and a decoder).
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.GetEncoding(System.String,System.Boolean)'>
    <summary>Returns a character encoding from the given name.
    </summary>
    <param name='name'>A string naming a character encoding. See the ResolveAlias method. Can be
      null.
    </param>
    <param name='forEmail'>If false, uses the encoding resolution rules in the Encoding Standard. If
      true, uses modified rules as described in the ResolveAliasForEmail method.

    </param>
    <returns>An object that enables encoding and decoding text in the given character
      encoding. Returns null if the name is null or empty, or if it names an
      unrecognized or unsupported encoding.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.GetEncoding(System.String,System.Boolean,System.Boolean)'>
    <summary>Returns a character encoding from the given name.
    </summary>
    <param name='name'>A string naming a character encoding. See the ResolveAlias method. Can be
      null.
    </param>
    <param name='forEmail'>If false, uses the encoding resolution rules in the Encoding Standard. If
      true, uses modified rules as described in the ResolveAliasForEmail method.

    </param>
    <param name='allowReplacement'>Has no effect.
    </param>
    <returns>An object that enables encoding and decoding text in the given character
      encoding. Returns null if the name is null or empty, or if it names an
      unrecognized or unsupported encoding.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.InputToString(PeterO.Text.ICharacterInput)'>
    <summary>Reads Unicode characters from a character input and converts them to a
      text string.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterInput and can be called as
        follows:
        <c>reader.InputToString()</c> . If the object's class already has a InputToString method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='reader'>A character input whose characters will be converted to a text string.
    </param>
    <returns>A text string containing the characters read.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.ResolveAlias(System.String)'>
    <summary>Resolves a character encoding's name to a standard form. This involves
      changing aliases of a character encoding to a standardized name.
      <para>In several Internet specifications, this name is known as a "charset"
        parameter. In HTML and HTTP, for example, the "charset" parameter
        indicates the encoding used to represent text in the HTML page, text
        file, etc.
      </para>
    </summary>
    <param name='name'>A string that names a given character encoding. Can be null. Any leading
      and trailing whitespace is removed and the name converted to lowercase
      before resolving the encoding's name. The Encoding Standard supports only
      the following encodings (and defines aliases for most of them).
      <list type='bullet'>
        <item><c>UTF-8</c> - UTF-8 (8-bit encoding of the universal coded character set, the
          encoding recommended by the Encoding Standard for new data formats)
        </item>
        <item><c>UTF-16LE</c> - UTF-16 little-endian (16-bit UCS)
        </item>
        <item><c>UTF-16BE</c> - UTF-16 big-endian (16-bit UCS)
        </item>
        <item>The special-purpose encoding
          <c>x-user-defined</c> </item>
        <item>The special-purpose encoding
          <c>replacement</c> .
        </item>
        <item>28 legacy single-byte encodings:
          <list type='bullet'>
            <item><c>windows-1252</c> : Western Europe (Note: The Encoding Standard aliases the names
              <c>US-ASCII</c> and
              <c>ISO-8859-1</c> to
              <c>windows-1252</c> , which uses a different coded character set from either; it
              differs from
              <c>ISO-8859-1</c> by assigning different characters to some bytes from 0x80 to
              0x9F. The Encoding Standard does this for compatibility with
              existing Web pages.)
            </item>
            <item><c>ISO-8859-2</c> ,
              <c>windows-1250</c> : Central Europe
            </item>
            <item><c>ISO-8859-10</c> : Northern Europe
            </item>
            <item><c>ISO-8859-4</c> ,
              <c>windows-1257</c> : Baltic
            </item>
            <item><c>ISO-8859-13</c> : Estonian
            </item>
            <item><c>ISO-8859-14</c> : Celtic
            </item>
            <item><c>ISO-8859-16</c> : Romanian
            </item>
            <item><c>ISO-8859-5</c> ,
              <c>IBM-866</c> ,
              <c>KOI8-R</c> ,
              <c>windows-1251</c> ,
              <c>x-mac-cyrillic</c> : Cyrillic
            </item>
            <item><c>KOI8-U</c> : Ukrainian
            </item>
            <item><c>ISO-8859-7</c> ,
              <c>windows-1253</c> : Greek
            </item>
            <item><c>ISO-8859-6</c> ,
              <c>windows-1256</c> : Arabic
            </item>
            <item><c>ISO-8859-8</c> ,
              <c>ISO-8859-8-I</c> ,
              <c>windows-1255</c> : Hebrew
            </item>
            <item><c>ISO-8859-3</c> : Latin 3
            </item>
            <item><c>ISO-8859-15</c> ,
              <c>windows-1254</c> : Turkish
            </item>
            <item><c>windows-874</c> : Thai
            </item>
            <item><c>windows-1258</c> : Vietnamese
            </item>
            <item><c>macintosh</c> : Mac Roman
            </item>
          </list>
        </item>
        <item>Three legacy Japanese encodings:
          <c>Shift_JIS</c> ,
          <c>EUC-JP</c> ,
          <c>ISO-2022-JP</c> </item>
        <item>Two legacy simplified Chinese encodings:
          <c>GBK</c> and
          <c>gb18030</c> </item>
        <item><c>Big5</c> : legacy traditional Chinese encoding
        </item>
        <item><c>EUC-KR</c> : legacy Korean encoding
        </item>
      </list>
      <para>The
        <c>UTF-8</c> ,
        <c>UTF-16LE</c> , and
        <c>UTF-16BE</c> encodings don't encode a byte-order mark at the start of the text
        (doing so is not recommended for
        <c>UTF-8</c> , while in
        <c>UTF-16LE</c> and
        <c>UTF-16BE</c> , the byte-order mark character U+FEFF is treated as an ordinary
        character, unlike in the UTF-16 encoding form). The Encoding Standard
        aliases
        <c>UTF-16</c> to
        <c>UTF-16LE</c> "to deal with deployed content".
      </para>
       .
    </param>
    <returns>A standardized name for the encoding. Returns the empty string if
      <paramref name='name'/>
       is null or empty, or if the encoding name is unsupported.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.ResolveAliasForEmail(System.String)'>
    <summary>Resolves a character encoding's name to a canonical form, using rules more
      suitable for email.
    </summary>
    <param name='name'>A string naming a character encoding. Can be null. Uses a modified version
      of the rules in the Encoding Standard to better conform, in some cases, to
      email standards like MIME. Encoding names and aliases not registered with
      the Internet Assigned Numbers Authority (IANA) are not supported, with the
      exception of
      <c>ascii</c> ,
      <c>utf8</c> ,
      <c>cp1252</c> , and names 10 characters or longer starting with
      <c>iso-8859-</c> . Also, the following additional encodings are supported.
      <list type='bullet'>
        <item><c>US-ASCII</c> - ASCII single-byte encoding, rather than an alias to
          <c>windows-1252</c> as specified in the Encoding Standard. The coded character set's code
          points match those in the Unicode Standard's Basic Latin block (0-127
          or U+0000 to U+007F). The name
          <c>ascii</c> is an alias.
        </item>
        <item><c>ISO-8859-1</c> - Latin-1 single-byte encoding, rather than an alias to
          <c>windows-1252</c> as specified in the Encoding Standard. The coded character set's code
          points match those in the Unicode Standard's Basic Latin and Latin-1
          Supplement blocks (0-255 or U+0000 to U+00FF).
        </item>
        <item><c>UTF-7</c> - UTF-7 (7-bit universal coded character set). The name
          <c>unicode-1-1-utf-7</c> is an alias to
          <c>UTF-7</c> , even though both encodings are defined in different RFCs (1642 and
          2152, respectively), and even though they are linked to Unicode
          versions with nonoverlapping character repertoires (1.1 and 2.0,
          respectively).
        </item>
      </list>
       . In previous versions of this method, the name
      <c>iso-2022-jp-2</c> was also aliased to
      <c>ISO-2022-JP</c> , which is no longer the case.
    </param>
    <returns>A standardized name for the encoding. Returns the empty string if
      <paramref name='name'/>
       is null or empty, or if the encoding name is unsupported.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.StringToBytes(PeterO.Text.ICharacterEncoder,System.String)'>
    <summary>Converts a text string to a byte array using the given character encoder.
      When reading the string, any unpaired surrogate characters are replaced
      with the replacement character (U+FFFD), and when writing to the byte
      array, any characters that can't be encoded are replaced with the byte
      0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoder and can be called as
        follows:
        <c>encoder.StringToBytes(str)</c> . If the object's class already has a StringToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='encoder'>An object that implements a character encoder.
    </param>
    <param name='str'>A text string to encode into a byte array.
    </param>
    <returns>A byte array.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='encoder'/>
       or
      <paramref name='str'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Encodings.StringToBytes(PeterO.Text.ICharacterEncoding,System.String)'>
    <summary>Converts a text string to a byte array encoded in a given character
      encoding. When reading the string, any unpaired surrogate characters are
      replaced with the replacement character (U+FFFD), and when writing to the
      byte array, any characters that can't be encoded are replaced with the
      byte 0x3f (the question mark character).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing ICharacterEncoding and can be called
        as follows:
        <c>encoding.StringToBytes(str)</c> . If the object's class already has a StringToBytes method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='encoding'>An object that implements a character encoding.
    </param>
    <param name='str'>A string to be encoded into a byte array.
    </param>
    <returns>A byte array containing the string encoded in the given text encoding.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.StringToInput(System.String)'>
    <summary>Converts a text string to a character input. The resulting input can then
      be used to encode the text to bytes, or to read the string code point by
      code point, among other things. When reading the string, any unpaired
      surrogate characters are replaced with the replacement character (U+FFFD).

      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.StringToInput(offset, length)</c> . If the object's class already has a StringToInput method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <returns>An ICharacterInput object.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Encodings.StringToInput(System.String,System.Int32,System.Int32)'>
    <summary>Converts a portion of a text string to a character input. The resulting
      input can then be used to encode the text to bytes, or to read the string
      code point by code point, among other things. When reading the string, any
      unpaired surrogate characters are replaced with the replacement character
      (U+FFFD).
      <para>In the .NET implementation, this method is implemented as an extension
        method to any String object and can be called as follows:
        <c>str.StringToInput(offset, length)</c> . If the object's class already has a StringToInput method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The length, in code units, of the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <returns>An ICharacterInput object.
    </returns>
  </doc>
  <doc name='F:PeterO.Text.Encodings.UTF8'>
    <summary>Character encoding object for the UTF-8 character encoding, which
      represents each code point in the universal coded character set using 1 to
      4 bytes.
    </summary>
  </doc>
  <doc name='T:PeterO.Text.ICharacterDecoder'>
    <summary>Defines a method that can be implemented by classes that convert a stream
      of bytes to Unicode code points.
    </summary>
  </doc>
  <doc name='M:PeterO.Text.ICharacterDecoder.ReadChar(PeterO.IByteReader)'>
    <summary>Reads bytes from an input transform until a Unicode code point is decoded
      or until the end of the stream is reached.
      <para>If this method returns -2, indicating an error, the caller of this
        method can take one of a variety of actions to handle the error. For
        example, it can output one or more replacement code points instead (such
        as the Replacement Character 0xfffd), or it can throw an exception. In
        some cases, where the error won't cause data loss or a security problem,
        the caller can also ignore the decoder error.
      </para>
    </summary>
    <param name='input'>Source of bytes to decode into code points. The decoder can maintain
      internal state, including data on bytes already read, so this parameter
      should not change when using the same character decoder object. It's also
      possible for the decoder to read no bytes but still return a code point,
      depending on the encoding it supports and its internal state.
    </param>
    <returns>The Unicode code point decoded, from 0-0xd7ff or from 0xe000 to 0x10ffff.
      Returns -1 if the end of the source is reached or -2 if a decoder error
      occurs.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.ICharacterEncoder'>
    <summary>Defines a method that can be implemented by classes that convert Unicode
      code points to bytes.
    </summary>
  </doc>
  <doc name='M:PeterO.Text.ICharacterEncoder.Encode(System.Int32,PeterO.IWriter)'>
    <summary>Converts a Unicode code point to bytes and writes the bytes to an output
      stream.
      <para>If this method returns -2, indicating an error, the caller of this
        method can take one of a variety of actions to handle the error. For
        example, it can write an escape sequence using the code point (such as
        the HTML error mode in the Encoding Standard), it can replace the code
        point with a "best fit" to that code point (which can consist of one or
        more bytes) and write the "best fit" instead, it can replace the code
        point with an arbitrary byte or sequence of bytes, or it can throw an
        exception. In some cases, where the error won't cause data loss or a
        security problem, the caller can also ignore the encoding error.
      </para>
    </summary>
    <param name='c'>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the stream.
    </param>
    <param name='output'>Output stream where the converted bytes will be written. The decoder can
      maintain internal state, including data on code points already passed as
      input, so this parameter should not change when using the same character
      encoder object.
    </param>
    <returns>The number of bytes written to the stream; -1 if no further code points
      remain (for example, if _c_ is -1 indicating the end of the stream), or -2
      if an encoding error occurs. (Note that it's possible for this method to
      return 0 if, for example, it can't generate new bytes yet based on the
      current input.). If this method returns -2, it should not write any bytes
      to the output stream.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.ICharacterEncoding'>
    <summary>Defines methods that can be implemented by classes that convert to and
      from bytes and character code points.
    </summary>
  </doc>
  <doc name='M:PeterO.Text.ICharacterEncoding.GetDecoder'>
    <summary>Creates a decoder for this character encoding with initial state. If the
      decoder is stateless, multiple calls of this method can return the same
      decoder.
    </summary>
    <returns>A character decoder object.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.ICharacterEncoding.GetEncoder'>
    <summary>Creates an encoder for this character encoding with initial state. If the
      encoder is stateless, multiple calls of this method can return the same
      encoder.
    </summary>
    <returns>A character encoder object.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.ICharacterInput'>
    <summary>An interface for reading Unicode code points from a data source.
    </summary>
  </doc>
  <doc name='M:PeterO.Text.ICharacterInput.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
    <exception cref='T:System.ArgumentNullException'>Should be thrown if "chars" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.ICharacterInput.ReadChar'>
    <summary>Reads a Unicode code point from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.Idna'>
    <summary><para>Contains methods that implement Internationalized Domain Names in
        Applications (IDNA). IDNA enables using a wider range of letters,
        numbers, and certain other characters in domain names. This class
        implements the 2008 revision of IDNA, also known as IDNA2008.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses two internal classes, called
        <c>NormalizationData</c> and
        <c>IdnaData</c> , that include data derived from the Unicode Character Database. See
        the documentation for the NormalizerInput class for the permission
        notice for the Unicode Character Database.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.Idna.EncodeDomainName(System.String)'>
    <summary>Tries to encode each label of a domain name into Punycode.
    </summary>
    <param name='value'>A domain name.
    </param>
    <returns>The domain name where each label with code points outside the Basic Latin
      range (U+0000 to U+007F) is encoded into Punycode. Labels where this is
      not possible remain unchanged.
    </returns>
    <exception cref='T:System.ArgumentNullException'>Value is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Idna.IsValidDomainName(System.String,System.Boolean)'>
    <summary>Determines whether the given string is a syntactically valid domain name.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='lookupRules'>If true, uses rules to apply when looking up the string as a domain name.
      If false, uses rules to apply when registering the string as a domain
      name.
    </param>
    <returns><c>true</c> if the given string is a syntactically valid domain name; otherwise;
      false.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.Normalization'>
    <summary>Represents a Unicode normalization form.
    </summary>
  </doc>
  <doc name='F:PeterO.Text.Normalization.NFC'>
    <summary>Normalization form C: canonical decomposition followed by canonical
      composition.
    </summary>
  </doc>
  <doc name='F:PeterO.Text.Normalization.NFD'>
    <summary>Normalization form D: canonical decomposition.
    </summary>
  </doc>
  <doc name='F:PeterO.Text.Normalization.NFKC'>
    <summary>Normalization form KC: compatibility decomposition followed by canonical
      composition.
    </summary>
  </doc>
  <doc name='F:PeterO.Text.Normalization.NFKD'>
    <summary>Normalization form KD: compatibility decomposition.
    </summary>
  </doc>
  <doc name='T:PeterO.Text.Normalizer'>
    <summary><para>Implements the Unicode normalization algorithm and contains methods and
        functionality to test and convert Unicode strings for Unicode
        normalization.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. See the documentation
        for the NormalizerInput class for the permission notice for the Unicode
        Character Database.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.#ctor(System.String,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.Normalizer'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.IsNormalized(System.String,PeterO.Text.Normalization)'>
    <summary>Returns whether this string is normalized.
    </summary>
    <param name='str'>The string to check.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
    <returns><c>true</c> if this string is normalized; otherwise,
      <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.Normalize(System.String,PeterO.Text.Normalization)'>
    <summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>Index in the output buffer to start writing to.
    </param>
    <param name='length'>Maximum number of code points to write.
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='index'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='chars'/>
       's length, or
      <paramref name='chars'/>
       ' s length minus
      <paramref name='index'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
  </doc>
  <doc name='M:PeterO.Text.Normalizer.ReadChar'>
    <summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.NormalizerInput'>
    <summary><para>A character input class that implements the Unicode normalization
        algorithm and contains methods and functionality to test and convert
        text strings for normalization. This is similar to the deprecated
        Normalizer class, except it implements the ICharacterInput interface.
      </para>
      <para>The Unicode Standard includes characters, such as an acute accent, that
        can be combined with other characters to make new characters. For
        example, the letter E combines with an acute accent to make E-acute (É).
        In some cases, the combined form (E-acute) should be treated as
        equivalent to the uncombined form (E plus acute). For this reason, the
        standard defines four
        <i>
           normalization forms
        </i>
         that convert strings to a single equivalent form:
      </para>
      <list>
        <item><b>NFD</b> (Normalization Form D) decomposes combined forms to their constituent
          characters (E plus acute, for example). This is called canonical
          decomposition.
        </item>
        <item><b>NFC</b> does canonical decomposition, then combines certain constituent
          characters to their composites (E-acute, for example). This is called
          canonical composition.
        </item>
        <item>Two normalization forms,
          <b>NFKC</b> and
          <b>NFKD</b> , are similar to NFC and NFD, except they also "decompose" certain
          characters, such as ligatures, font or positional variants, and
          subscripts, whose visual distinction can matter in some contexts. This
          is called compatibility decomposition.
        </item>
        <item>The four normalization forms also enforce a standardized order for
          combining marks, since they can otherwise appear in an arbitrary
          order.
        </item>
      </list>
      <para>For more information, see Standard Annex 15 at
        <c>http://www.unicode.org/reports/tr15/</c> .
      </para>
      <para><b>Thread safety:</b> This class is mutable; its properties can be changed. None of its
        instance methods are designed to be thread safe. Therefore, access to
        objects from this class must be synchronized if multiple threads can
        access them at the same time.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. In case doing so is
        required, the permission notice for the Unicode Character Database is
        given here:
      </para>
      <para>COPYRIGHT AND PERMISSION NOTICE
      </para>
      <para>Copyright (c) 1991-2014 Unicode, Inc. All rights reserved. Distributed
        under the Terms of Use in http://www.unicode.org/copyright.html.
      </para>
      <para>Permission is hereby granted, free of charge, to any person obtaining a
        copy of the Unicode data files and any associated documentation (the
        "Data Files") or Unicode software and any associated documentation (the
        "Software") to deal in the Data Files or Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, and/or sell copies of the Data Files or Software,
        and to permit persons to whom the Data Files or Software are furnished
        to do so, provided that (a) this copyright and permission notice appear
        with all copies of the Data Files or Software, (b) this copyright and
        permission notice appear in associated documentation, and (c) there is
        clear notice in each modified Data File or in the Software as well as in
        the documentation associated with the Data File(s) or Software that the
        data or software has been modified.
      </para>
      <para>THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
        ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT
        HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR
        ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
        RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
        CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
        CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.
      </para>
      <para>Except as contained in this notice, the name of a copyright holder shall
        not be used in advertising or otherwise to promote the sale, use or
        other dealings in these Data Files or Software without prior written
        authorization of the copyright holder.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(PeterO.Text.ICharacterInput)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizerInput'/>
       class using Normalization Form C.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is an ICharacterInput object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is an ICharacterInput object.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizerInput'/>
       class using Normalization Form C.
    </summary>
    <param name='str'>A string specifying the text to normalize.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(System.String,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizerInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.#ctor(System.String,System.Int32,System.Int32,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizerInput'/>
       class. Uses a portion of a string as the input.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='str'/>
       (but not more than
      <paramref name='str'/>
       's length).
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.IsNormalized(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Determines whether the text provided by a character input is normalized.
    </summary>
    <param name='chars'>A object that implements a streamable character input.
    </param>
    <param name='form'>Specifies the normalization form to check.
    </param>
    <returns><c>true</c> if the text is normalized; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.IsNormalized(System.String,PeterO.Text.Normalization)'>
    <summary>Determines whether the given string is in the given Unicode normalization
      form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given string is in the given Unicode normalization form;
      otherwise,
      <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.Normalize(System.String,PeterO.Text.Normalization)'>
    <summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter
      <paramref name='str'/>
       contains an unpaired surrogate code point.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizerInput.ReadChar'>
    <summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.Text.NormalizingCharacterInput'>
    <summary><para>A character input class that implements the Unicode normalization
        algorithm and contains methods and functionality to test and convert
        text strings for normalization. This is similar to the deprecated
        Normalizer class, except it implements the ICharacterInput interface.
      </para>
      <para>The Unicode Standard includes characters, such as an acute accent, that
        can be combined with other characters to make new characters. For
        example, the letter E combines with an acute accent to make E-acute (É).
        In some cases, the combined form (E-acute) should be treated as
        equivalent to the uncombined form (E plus acute). For this reason, the
        standard defines four
        <i>
           normalization forms
        </i>
         that convert strings to a single equivalent form:
      </para>
      <list>
        <item><b>NFD</b> (Normalization Form D) decomposes combined forms to their constituent
          characters (E plus acute, for example). This is called canonical
          decomposition.
        </item>
        <item><b>NFC</b> does canonical decomposition, then combines certain constituent
          characters to their composites (E-acute, for example). This is called
          canonical composition.
        </item>
        <item>Two normalization forms,
          <b>NFKC</b> and
          <b>NFKD</b> , are similar to NFC and NFD, except they also "decompose" certain
          characters, such as ligatures, font or positional variants, and
          subscripts, whose visual distinction can matter in some contexts. This
          is called compatibility decomposition.
        </item>
        <item>The four normalization forms also enforce a standardized order for
          combining marks, since they can otherwise appear in an arbitrary
          order.
        </item>
      </list>
      <para>For more information, see Standard Annex 15 at
        <c>http://www.unicode.org/reports/tr15/</c> .
      </para>
      <para><b>Thread safety:</b> This class is mutable; its properties can be changed. None of its
        instance methods are designed to be thread safe. Therefore, access to
        objects from this class must be synchronized if multiple threads can
        access them at the same time.
      </para>
      <para>NOTICE: While this class's source code is in the public domain, the
        class uses an internal class, called NormalizationData, that includes
        data derived from the Unicode Character Database. In case doing so is
        required, the permission notice for the Unicode Character Database is
        given here:
      </para>
      <para>COPYRIGHT AND PERMISSION NOTICE
      </para>
      <para>Copyright (c) 1991-2014 Unicode, Inc. All rights reserved. Distributed
        under the Terms of Use in http://www.unicode.org/copyright.html.
      </para>
      <para>Permission is hereby granted, free of charge, to any person obtaining a
        copy of the Unicode data files and any associated documentation (the
        "Data Files") or Unicode software and any associated documentation (the
        "Software") to deal in the Data Files or Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, and/or sell copies of the Data Files or Software,
        and to permit persons to whom the Data Files or Software are furnished
        to do so, provided that (a) this copyright and permission notice appear
        with all copies of the Data Files or Software, (b) this copyright and
        permission notice appear in associated documentation, and (c) there is
        clear notice in each modified Data File or in the Software as well as in
        the documentation associated with the Data File(s) or Software that the
        data or software has been modified.
      </para>
      <para>THE DATA FILES AND SOFTWARE ARE PROVIDED "AS IS", WITHOUT WARRANTY OF
        ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT
        HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR
        ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
        RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
        CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
        CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.
      </para>
      <para>Except as contained in this notice, the name of a copyright holder shall
        not be used in advertising or otherwise to promote the sale, use or
        other dealings in these Data Files or Software without prior written
        authorization of the copyright holder.
      </para>
    </summary>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(PeterO.Text.ICharacterInput)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is a public object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='stream'>The parameter
      <paramref name='stream'/>
       is a public object.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.Collections.Generic.IList{System.Int32})'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='characterList'>The parameter
      <paramref name='characterList'/>
       is an IList object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.Collections.Generic.IList{System.Int32},PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='characterList'>The parameter
      <paramref name='characterList'/>
       is a public object.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       or "input" or "charArray" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.#ctor(System.String,System.Int32,System.Int32,PeterO.Text.Normalization)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.Text.NormalizingCharacterInput'/>
       class.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a public object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='length'>The parameter
      <paramref name='length'/>
       is a 32-bit signed integer.
    </param>
    <param name='form'>The parameter
      <paramref name='form'/>
       is a Normalization object.
    </param>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.GetChars(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Gets a list of normalized code points after reading from a character
      stream.
    </summary>
    <param name='chars'>An object that implements a stream of Unicode characters.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns>A list of the normalized Unicode characters.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.GetChars(System.String,PeterO.Text.Normalization)'>
    <summary>Gets a list of normalized code points after reading from a string.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns>A list of the normalized Unicode characters.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.IsNormalized(PeterO.Text.ICharacterInput,PeterO.Text.Normalization)'>
    <summary>Determines whether the text provided by a character input is normalized.
    </summary>
    <param name='chars'>A object that implements a streamable character input.
    </param>
    <param name='form'>Specifies the normalization form to check.
    </param>
    <returns><c>true</c> if the text is normalized; otherwise,
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.Collections.Generic.IList{System.Int32},PeterO.Text.Normalization)'>
    <summary>Determines whether the given list of characters is in the given Unicode
      normalization form.
    </summary>
    <param name='charList'>A list of Unicode code points.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given list of characters is in the given Unicode normalization
      form; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='charList'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.Int32[],PeterO.Text.Normalization)'>
    <summary>Determines whether the given array of characters is in the given Unicode
      normalization form.
    </summary>
    <param name='charArray'>An array of Unicode code points.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given list of characters is in the given Unicode normalization
      form; otherwise,
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter "charList" is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.IsNormalized(System.String,PeterO.Text.Normalization)'>
    <summary>Determines whether the given string is in the given Unicode normalization
      form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>Specifies the normalization form to use when normalizing the text.
    </param>
    <returns><c>true</c> if the given string is in the given Unicode normalization form;
      otherwise,
      <c>false</c> . Returns
      <c>false</c> if the string contains an unpaired surrogate code point.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.Normalize(System.String,PeterO.Text.Normalization)'>
    <summary>Converts a string to the given Unicode normalization form.
    </summary>
    <param name='str'>An arbitrary string.
    </param>
    <param name='form'>The Unicode normalization form to convert to.
    </param>
    <returns>The parameter
      <paramref name='str'/>
       converted to the given normalization form.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.Read(System.Int32[],System.Int32,System.Int32)'>
    <summary>Reads a sequence of Unicode code points from a data source.
    </summary>
    <param name='chars'>Output buffer.
    </param>
    <param name='index'>A zero-based index showing where the desired portion of
      <paramref name='chars'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='chars'/>
       (but not more than
      <paramref name='chars'/>
       's length).
    </param>
    <returns>The number of Unicode code points read, or 0 if the end of the source is
      reached.
    </returns>
  </doc>
  <doc name='M:PeterO.Text.NormalizingCharacterInput.ReadChar'>
    <summary>Reads a Unicode character from a data source.
    </summary>
    <returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff), or
      the value -1 indicating the end of the source.
    </returns>
  </doc>
  <doc name='T:PeterO.TrapException'>
    <summary><para><b>This class is obsolete. It will be replaced by a new version of this
          class in a different namespace/package and library, called
          <c>PeterO.Numbers.ETrapException</c> in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c> </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.ETrapException</c> in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c> </a>
           artifact (in Java).</b> </para>
       Exception thrown for arithmetic trap errors.
    </summary>
  </doc>
  <doc name='M:PeterO.TrapException.#ctor(System.Int32,PeterO.PrecisionContext,System.Object)'>
    <summary>Initializes a new instance of the
      <see cref='T:PeterO.TrapException'/>
       class.
    </summary>
    <param name='flag'>A flag that specifies the kind of error (PrecisionContext.FlagXXX). This
      will only be one flag, such as FlagInexact or FlagSubnormal.
    </param>
    <param name='ctx'>A context object for arbitrary-precision arithmetic settings.
    </param>
    <param name='result'>The desired result of the operation that caused the trap, such as an
      <c>ExtendedDecimal</c> or
      <c>ExtendedFloat</c> .
    </param>
  </doc>
  <doc name='P:PeterO.TrapException.Context'>
    <summary>Gets the precision context used during the operation that triggered the
      trap. May be null.
    </summary>
    <value>The precision context used during the operation that triggered the trap.
      May be null.
    </value>
  </doc>
  <doc name='P:PeterO.TrapException.Error'>
    <summary>Gets the flag that specifies the kind of error (PrecisionContext.FlagXXX).
      This will only be one flag, such as FlagInexact or FlagSubnormal.
    </summary>
    <value>The flag that specifies the kind of error (PrecisionContext.FlagXXX). This
      will only be one flag, such as FlagInexact or FlagSubnormal.
    </value>
  </doc>
  <doc name='P:PeterO.TrapException.Result'>
    <summary>Gets the defined result of the operation that caused the trap.
    </summary>
    <value>The defined result of the operation that caused the trap.
    </value>
  </doc>
  <doc name='T:PeterO.Util'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.Util.AddIfMissing``1(System.Collections.Generic.IList{``0},``0)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>dict.AddIfMissing&lt;T&gt;(value)</c> . If the object's class already has a AddIfMissing&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='dict'>The parameter
      <paramref name='dict'/>
       is an IList object.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='dict'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.AddIfMissing``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IDictionary and can be called as
        follows:
        <c>dict.AddIfMissing&lt;TKey, TValue&gt;(key, value)</c> . If the object's class already has a AddIfMissing&lt;TKey, TValue&gt;
        method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='dict'>The parameter
      <paramref name='dict'/>
       is an IDictionary object.
    </param>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a TKey object.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a TValue object.
    </param>
    <typeparam name='TKey'>Object type for keys.
    </typeparam>
    <typeparam name='TValue'>Object type for values.
    </typeparam>
  </doc>
  <doc name='M:PeterO.Util.AddOverwrite``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IDictionary and can be called as
        follows:
        <c>dict.AddOverwrite&lt;TKey, TValue&gt;(key, value)</c> . If the object's class already has a AddOverwrite&lt;TKey, TValue&gt;
        method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='dict'>The parameter
      <paramref name='dict'/>
       is an IDictionary object.
    </param>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a TKey object.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a TValue object.
    </param>
    <typeparam name='TKey'>Type parameter not documented yet.
    </typeparam>
  </doc>
  <doc name='M:PeterO.Util.AllSame``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>col.AllSame&lt;T&gt;()</c> . If the object's class already has a AllSame&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='col'>The parameter
      <paramref name='col'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='col'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.AllSame``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>containers.AllSame&lt;TContainer, TItem&gt;(func)</c> . If the object's class already has a AllSame&lt;TContainer, TItem&gt;
        method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='containers'>The parameter
      <paramref name='containers'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Func object.
    </param>
    <typeparam name='TContainer'>Object type representing containers of items. Can also be the same type as
      TItem.
    </typeparam>
    <typeparam name='TItem'>Object type representing items stored in each container.
    </typeparam>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='containers'/>
       or
      <paramref name='func'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.ArrayToString``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>array.ArrayToString&lt;T&gt;()</c> . If the object's class already has a ArrayToString&lt;T&gt; method
        with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='array'>The parameter
      <paramref name='array'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.CopyStream(System.IO.Stream,System.IO.Stream)'>
    <summary>Copies all bytes from one stream to another.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Stream and can be called as follows:
        <c>input.CopyStream(output)</c> . If the object's class already has a CopyStream method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is a Stream object.
    </param>
    <param name='output'>The parameter
      <paramref name='output'/>
       is a Stream object.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='input'/>
       or
      <paramref name='output'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.CopyStream(System.IO.Stream,System.Int32,System.IO.Stream)'>
    <summary>Copies a certain number of bytes from one stream to another.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Stream and can be called as follows:
        <c>input.CopyStream(length, output)</c> . If the object's class already has a CopyStream method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='input'>The parameter
      <paramref name='input'/>
       is a Stream object.
    </param>
    <param name='length'>The parameter
      <paramref name='length'/>
       is a 32-bit signed integer.
    </param>
    <param name='output'>The parameter
      <paramref name='output'/>
       is a Stream object.
    </param>
  </doc>
  <doc name='M:PeterO.Util.CopyStructure``1(``0)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing T and can be called as follows:
        <c>structure.CopyStructure&lt;T&gt;()</c> . If the object's class already has a CopyStructure&lt;T&gt; method
        with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='structure'>The parameter
      <paramref name='structure'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='structure'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.EachWithIndex``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
    </summary>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>The return value'/&gt; is not documented yet.
    </returns>
    <remarks>
       Useful in queries where the index must be manipulated or returned by the
      query. For example:
      <code>from o in Util.EachWithIndex(objects) where IndexMeetsCriteria(o.Second)
        select o.First</code> .
    </remarks>
  </doc>
  <doc name='M:PeterO.Util.GetSegment``1(System.Collections.Generic.IList{``0},System.Int32)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.GetSegment&lt;T&gt;(start)</c> . If the object's class already has a GetSegment&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='start'>The parameter
      <paramref name='start'/>
       is a 32-bit signed integer.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A ListSegment(T) object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.GetSegment``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.GetSegment&lt;T&gt;(start, count)</c> . If the object's class already has a GetSegment&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='start'>The parameter
      <paramref name='start'/>
       is a 32-bit signed integer.
    </param>
    <param name='count'>The parameter
      <paramref name='count'/>
       is a 32-bit signed integer.
    </param>
    <typeparam name='T'>Any object type.
    </typeparam>
    <returns>A ListSegment(T) object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.HasUnique``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>col.HasUnique&lt;T&gt;()</c> . If the object's class already has a HasUnique&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='col'>The parameter
      <paramref name='col'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Util.HasUnique``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>containers.HasUnique&lt;TContainer, TItem&gt;(func)</c> . If the object's class already has a HasUnique&lt;TContainer,
        TItem&gt; method with the same parameters, that method takes precedence
        over this extension method.
      </para>
    </summary>
    <param name='containers'>The parameter
      <paramref name='containers'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Func object.
    </param>
    <typeparam name='TContainer'>Object type representing containers of items. Can also be the same type as
      TItem.
    </typeparam>
    <typeparam name='TItem'>Object type representing items stored in each container.
    </typeparam>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.Util.Implode``1(System.Collections.Generic.IEnumerable{``0},System.String)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>col.Implode&lt;T&gt;(separator)</c> . If the object's class already has a Implode&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='col'>The parameter
      <paramref name='col'/>
       is an IEnumerable object.
    </param>
    <param name='separator'>The parameter
      <paramref name='separator'/>
       is a text string.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A text string.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='col'/>
       or
      <paramref name='separator'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.IndexOf``1(System.Collections.Generic.IList{``0},System.Predicate{``0})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.IndexOf&lt;T&gt;(match)</c> . If the object's class already has a IndexOf&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='match'>The parameter
      <paramref name='match'/>
       is a Predicate object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='list'/>
       or
      <paramref name='match'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.IndexOf``1(System.Collections.Generic.IList{``0},``0)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.IndexOf&lt;T&gt;(obj)</c> . If the object's class already has a IndexOf&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='obj'>The parameter
      <paramref name='obj'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.MakeList``1(``0[])'>
    <summary>Not documented yet.
    </summary>
    <param name='items'>The parameter
      <paramref name='items'/>
       is a params object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>An IList(T) object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.MakePair``2(``0,``1)'>
    <summary>Not documented yet.
    </summary>
    <param name='f'>The parameter
      <paramref name='f'/>
       is a TFirst object.
    </param>
    <param name='s'>The parameter
      <paramref name='s'/>
       is a TSecond object.
    </param>
    <typeparam name='TFirst'>Any object type.
    </typeparam>
    <typeparam name='TSecond'>Any object type.
    </typeparam>
    <returns>A Pair(TFirst, TSecond) object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.MaxOrDefault``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>coll.MaxOrDefault&lt;T&gt;()</c> . If the object's class already has a MaxOrDefault&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='coll'>The parameter
      <paramref name='coll'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Any object type that implements IComparable&lt;T&gt;.
    </typeparam>
    <returns>A T object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='coll'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.MinOrDefault``1(System.Collections.Generic.IEnumerable{``0})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>coll.MinOrDefault&lt;T&gt;()</c> . If the object's class already has a MinOrDefault&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='coll'>The parameter
      <paramref name='coll'/>
       is an IEnumerable object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
  </doc>
  <doc name='F:PeterO.Util.NullDisposable'>
    <summary>An IDisposable object that does nothing when disposed.
    </summary>
  </doc>
  <doc name='M:PeterO.Util.NullDisposableClass.Dispose'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.Util.RemoveAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.RemoveAll&lt;T&gt;(match)</c> . If the object's class already has a RemoveAll&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='match'>The parameter
      <paramref name='match'/>
       is a Predicate object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.SetIfMissing``1(System.Collections.Generic.IList{``0},System.Int32,System.Func{``0})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.SetIfMissing&lt;T&gt;(index, valuefunc)</c> . If the object's class already has a SetIfMissing&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='valuefunc'>The parameter
      <paramref name='valuefunc'/>
       is a Func object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.SetIfMissing``1(System.Collections.Generic.IList{``0},System.Int32,``0)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.SetIfMissing&lt;T&gt;(index, value)</c> . If the object's class already has a SetIfMissing&lt;T&gt; method with
        the same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.SetNewIfMissing``1(System.Collections.Generic.IList{``0},System.Int32)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.SetNewIfMissing&lt;T&gt;(index)</c> . If the object's class already has a SetNewIfMissing&lt;T&gt; method
        with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.SetValue``1(System.Collections.Generic.IList{``0},System.Int32,``0)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.SetValue&lt;T&gt;(index, value)</c> . If the object's class already has a SetValue&lt;T&gt; method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a T object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
  </doc>
  <doc name='M:PeterO.Util.StructureSize(PeterO.IStructure)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IStructure and can be called as
        follows:
        <c>s.StructureSize()</c> . If the object's class already has a StructureSize method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='s'>The parameter
      <paramref name='s'/>
       is an IStructure object.
    </param>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>containers.Sum&lt;T&gt;(func)</c> . If the object's class already has a Sum&lt;T&gt; method with the same
        parameters, that method takes precedence over this extension method.
      </para>
    </summary>
    <param name='containers'>The parameter
      <paramref name='containers'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Func object.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A 32-bit signed integer.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.Transform``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IEnumerable and can be called as
        follows:
        <c>containers.Transform&lt;TInput, TOutput&gt;(func)</c> . If the object's class already has a Transform&lt;TInput, TOutput&gt;
        method with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='containers'>The parameter
      <paramref name='containers'/>
       is an IEnumerable object.
    </param>
    <param name='func'>The parameter
      <paramref name='func'/>
       is a Func object.
    </param>
    <typeparam name='TOutput'>Output type.
    </typeparam>
    <returns>An IEnumerable(TOutput) object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.UpToExcluding(System.Int32,System.Int32)'>
    <summary>Creates an iterator of integers starting at a minimum value and ending at
      one less than the maximum.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Int32 and can be called as follows:
        <c>minValue.UpToExcluding(maxValue)</c> . If the object's class already has a UpToExcluding method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='minValue'>The parameter
      <paramref name='minValue'/>
       is a 32-bit signed integer.
    </param>
    <param name='maxValue'>The parameter
      <paramref name='maxValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>An IEnumerable(int) object.
    </returns>
    <exception cref='T:System.ArgumentException'>The parameter _minValue_ is greater than _maxValue_.
    </exception>
  </doc>
  <doc name='M:PeterO.Util.UpToIncluding(System.Int32,System.Int32)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing Int32 and can be called as follows:
        <c>minValue.UpToIncluding(maxValue)</c> . If the object's class already has a UpToIncluding method with the
        same parameters, that method takes precedence over this extension
        method.
      </para>
    </summary>
    <param name='minValue'>The parameter
      <paramref name='minValue'/>
       is a 32-bit signed integer.
    </param>
    <param name='maxValue'>The parameter
      <paramref name='maxValue'/>
       is a 32-bit signed integer.
    </param>
    <returns>An IEnumerable(int) object.
    </returns>
  </doc>
  <doc name='M:PeterO.Util.ValueOrDefault``1(System.Collections.Generic.IList{``0},System.Int32)'>
    <summary>Not documented yet.
      <para>In the .NET implementation, this method is implemented as an extension
        method to any object implementing IList and can be called as follows:
        <c>list.ValueOrDefault&lt;T&gt;(index)</c> . If the object's class already has a ValueOrDefault&lt;T&gt; method
        with the same parameters, that method takes precedence over this
        extension method.
      </para>
    </summary>
    <param name='list'>The parameter
      <paramref name='list'/>
       is an IList object.
    </param>
    <param name='index'>The parameter
      <paramref name='index'/>
       is a 32-bit signed integer.
    </param>
    <typeparam name='T'>Type parameter not documented yet.
    </typeparam>
    <returns>A T object.
    </returns>
  </doc>
  <doc name='T:PeterO.XEReader'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.XEReader.Create(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <returns>A XEReader object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='file'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.XEReader.Create(System.Xml.XmlReader)'>
    <summary>Not documented yet.
    </summary>
    <param name='reader'>The parameter
      <paramref name='reader'/>
       is a XmlReader object.
    </param>
    <returns>A XEReader object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='reader'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.XEReader.Current'>
    <summary>Not documented yet.
    </summary>
    <returns>A XEReader object.
    </returns>
  </doc>
  <doc name='M:PeterO.XEReader.Dispose'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.XEReader.IsElement(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.XEReader.IsElement(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='namespaceName'>The parameter
      <paramref name='namespaceName'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
    <exception cref='T:System.InvalidOperationException'>This element's content was already read or being read.
    </exception>
  </doc>
  <doc name='P:PeterO.XEReader.IsEmptyElement'>
    <summary>Gets a value indicating whether the currently read element is found to be
      empty.
    </summary>
    <value><c>true</c> If the currently read element is found to be empty; otherwise,
      <c>false</c> .
    </value>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='P:PeterO.XEReader.Item(System.String)'>
    <summary>Gets an attribute from the currently read element.
    </summary>
    <param name='attribute'>The parameter
      <paramref name='attribute'/>
       is a text string.
    </param>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='P:PeterO.XEReader.LocalName'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.XEReader.MoveNext'>
    <summary>Not documented yet.
    </summary>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.XEReader.MoveNext(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='M:PeterO.XEReader.MoveNext(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='namespaceName'>The parameter
      <paramref name='namespaceName'/>
       is a text string.
    </param>
    <returns>Either
      <c>true</c> or
      <c>false</c> .
    </returns>
  </doc>
  <doc name='P:PeterO.XEReader.Name'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='P:PeterO.XEReader.NamespaceName'>
    <summary>Gets a value not documented yet.
    </summary>
    <value>A value not documented yet.
    </value>
  </doc>
  <doc name='M:PeterO.XEReader.ReadContent'>
    <summary>Not documented yet.
    </summary>
    <returns>A text string.
    </returns>
  </doc>
  <doc name='T:PeterO.XEWriter'>
    <summary>Not documented yet.
    </summary>
  </doc>
  <doc name='M:PeterO.XEWriter.AddAttribute(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.XEWriter.AddAttribute(System.String,System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='key'>The parameter
      <paramref name='key'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.XEWriter.AddComment(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.XEWriter.AddContent(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.XEWriter.AddElement(System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
  </doc>
  <doc name='M:PeterO.XEWriter.AddElement(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
  </doc>
  <doc name='M:PeterO.XEWriter.AddSimpleElement(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.XEWriter.AddSimpleElement(System.String,System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <param name='value'>The parameter
      <paramref name='value'/>
       is a text string.
    </param>
  </doc>
  <doc name='M:PeterO.XEWriter.Create(System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
  </doc>
  <doc name='M:PeterO.XEWriter.Create(System.String,System.String,System.Boolean)'>
    <summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='indent'>The parameter
      <paramref name='indent'/>
       is either
      <c>true</c> or
      <c>false</c> .
    </param>
    <returns>A XEWriter object.
    </returns>
  </doc>
  <doc name='M:PeterO.XEWriter.Create(System.String,System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
  </doc>
  <doc name='M:PeterO.XEWriter.Create(System.String,System.String,System.String,System.Boolean)'>
    <summary>Not documented yet.
    </summary>
    <param name='file'>The parameter
      <paramref name='file'/>
       is a text string.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <param name='indent'>The parameter
      <paramref name='indent'/>
       is either
      <c>true</c> or
      <c>false</c> .
    </param>
    <returns>A XEWriter object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='file'/>
       or
      <paramref name='localName'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.XEWriter.Create(System.Xml.XmlWriter,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='writer'>The parameter
      <paramref name='writer'/>
       is a XmlWriter object.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
  </doc>
  <doc name='M:PeterO.XEWriter.Create(System.Xml.XmlWriter,System.String,System.String)'>
    <summary>Not documented yet.
    </summary>
    <param name='writer'>The parameter
      <paramref name='writer'/>
       is a XmlWriter object.
    </param>
    <param name='localName'>The parameter
      <paramref name='localName'/>
       is a text string.
    </param>
    <param name='ns'>The parameter
      <paramref name='ns'/>
       is a text string.
    </param>
    <returns>A XEWriter object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='writer'/>
       or
      <paramref name='localName'/>
       is null.
    </exception>
  </doc>
  <doc name='M:PeterO.XEWriter.Dispose'>
    <summary>Not documented yet.
    </summary>
  </doc>
</docs>
